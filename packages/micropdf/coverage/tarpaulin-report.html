<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","buffer.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse micropdf::fitz::buffer::Buffer;\n\nfn bench_buffer_creation(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/create\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, \u0026size| {\n            b.iter(|| Buffer::new(black_box(size)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_from_data(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/from_slice\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026data, |b, data| {\n            b.iter(|| Buffer::from_slice(black_box(data)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_append(c: \u0026mut Criterion) {\n    let chunk: Vec\u003cu8\u003e = (0..256).map(|i| i as u8).collect();\n\n    let mut group = c.benchmark_group(\"buffer/append\");\n\n    for iterations in [10, 100, 1000].iter() {\n        group.throughput(Throughput::Bytes((256 * iterations) as u64));\n        group.bench_with_input(\n            BenchmarkId::from_parameter(iterations),\n            iterations,\n            |b, \u0026iterations| {\n                b.iter(|| {\n                    let mut buf = Buffer::new(0);\n                    for _ in 0..iterations {\n                        buf.append_data(black_box(\u0026chunk));\n                    }\n                    buf\n                })\n            },\n        );\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_base64(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/base64\");\n\n    for size in [64, 256, 1024, 4096].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::new(\"encode\", size), \u0026buf, |b, buf| {\n            b.iter(|| buf.to_base64())\n        });\n    }\n\n    // Decode benchmarks\n    for size in [64, 256, 1024, 4096].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n        let encoded = buf.to_base64();\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::new(\"decode\", size), \u0026encoded, |b, encoded| {\n            b.iter(|| Buffer::from_base64(black_box(encoded)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_md5(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/md5\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026buf, |b, buf| {\n            b.iter(|| buf.md5_digest())\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_to_vec(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/to_vec\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026buf, |b, buf| {\n            b.iter(|| buf.to_vec())\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_buffer_creation,\n    bench_buffer_from_data,\n    bench_buffer_append,\n    bench_buffer_base64,\n    bench_buffer_md5,\n    bench_buffer_to_vec,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","geometry.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse micropdf::fitz::geometry::{Matrix, Point, Quad, Rect};\n\nfn bench_point_transform(c: \u0026mut Criterion) {\n    let point = Point::new(100.0, 200.0);\n    let matrix = Matrix::rotate(45.0);\n\n    c.bench_function(\"point/transform\", |b| {\n        b.iter(|| black_box(point).transform(black_box(\u0026matrix)))\n    });\n}\n\nfn bench_point_operations(c: \u0026mut Criterion) {\n    let p1 = Point::new(100.0, 200.0);\n    let p2 = Point::new(50.0, 75.0);\n\n    let mut group = c.benchmark_group(\"point\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Point::new(black_box(100.0), black_box(200.0)))\n    });\n\n    group.finish();\n}\n\nfn bench_matrix_operations(c: \u0026mut Criterion) {\n    let m1 = Matrix::translate(100.0, 200.0);\n    let m2 = Matrix::scale(2.0, 2.0);\n    let m3 = Matrix::rotate(45.0);\n\n    let mut group = c.benchmark_group(\"matrix\");\n\n    group.bench_function(\"translate\", |b| {\n        b.iter(|| Matrix::translate(black_box(100.0), black_box(200.0)))\n    });\n\n    group.bench_function(\"scale\", |b| {\n        b.iter(|| Matrix::scale(black_box(2.0), black_box(2.0)))\n    });\n\n    group.bench_function(\"rotate\", |b| {\n        b.iter(|| Matrix::rotate(black_box(45.0)))\n    });\n\n    group.bench_function(\"concat\", |b| {\n        b.iter(|| black_box(\u0026m1).concat(black_box(\u0026m2)))\n    });\n\n    group.bench_function(\"chain_3\", |b| {\n        b.iter(|| {\n            black_box(\u0026m1)\n                .concat(black_box(\u0026m2))\n                .concat(black_box(\u0026m3))\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_rect_operations(c: \u0026mut Criterion) {\n    let r1 = Rect::new(0.0, 0.0, 100.0, 100.0);\n    let r2 = Rect::new(50.0, 50.0, 150.0, 150.0);\n    let point = Point::new(75.0, 75.0);\n\n    let mut group = c.benchmark_group(\"rect\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Rect::new(black_box(0.0), black_box(0.0), black_box(100.0), black_box(100.0)))\n    });\n\n    group.bench_function(\"union\", |b| {\n        b.iter(|| black_box(\u0026r1).union(black_box(\u0026r2)))\n    });\n\n    group.bench_function(\"intersect\", |b| {\n        b.iter(|| black_box(\u0026r1).intersect(black_box(\u0026r2)))\n    });\n\n    group.bench_function(\"contains\", |b| {\n        b.iter(|| black_box(\u0026r1).contains(black_box(75.0), black_box(75.0)))\n    });\n\n    group.bench_function(\"width_height\", |b| {\n        b.iter(|| (black_box(\u0026r1).width(), black_box(\u0026r1).height()))\n    });\n\n    group.bench_function(\"is_empty\", |b| {\n        b.iter(|| black_box(\u0026r1).is_empty())\n    });\n\n    group.finish();\n}\n\nfn bench_quad_operations(c: \u0026mut Criterion) {\n    let rect = Rect::new(0.0, 0.0, 100.0, 100.0);\n    let quad = Quad::from_rect(\u0026rect);\n    let matrix = Matrix::rotate(45.0);\n\n    let mut group = c.benchmark_group(\"quad\");\n\n    group.bench_function(\"from_rect\", |b| {\n        b.iter(|| Quad::from_rect(black_box(\u0026rect)))\n    });\n\n    group.bench_function(\"transform\", |b| {\n        b.iter(|| black_box(\u0026quad).transform(black_box(\u0026matrix)))\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_point_transform,\n    bench_point_operations,\n    bench_matrix_operations,\n    bench_rect_operations,\n    bench_quad_operations,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","pdf_objects.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse micropdf::pdf::object::{Name, Object, ObjRef, PdfString};\nuse std::collections::HashMap;\n\nfn bench_object_creation(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"pdf/object/create\");\n\n    group.bench_function(\"null\", |b| {\n        b.iter(|| Object::Null)\n    });\n\n    group.bench_function(\"bool\", |b| {\n        b.iter(|| Object::Bool(black_box(true)))\n    });\n\n    group.bench_function(\"int\", |b| {\n        b.iter(|| Object::Int(black_box(42)))\n    });\n\n    group.bench_function(\"real\", |b| {\n        b.iter(|| Object::Real(black_box(3.14159)))\n    });\n\n    group.bench_function(\"name\", |b| {\n        b.iter(|| Object::Name(Name::new(black_box(\"Type\"))))\n    });\n\n    group.bench_function(\"string\", |b| {\n        b.iter(|| Object::String(PdfString::new(black_box(b\"Hello, World!\".to_vec()))))\n    });\n\n    group.bench_function(\"ref\", |b| {\n        b.iter(|| Object::Ref(ObjRef::new(black_box(1), black_box(0))))\n    });\n\n    group.finish();\n}\n\nfn bench_name_operations(c: \u0026mut Criterion) {\n    let name1 = Name::new(\"Type\");\n    let name2 = Name::new(\"Type\");\n    let name3 = Name::new(\"Subtype\");\n\n    let mut group = c.benchmark_group(\"pdf/name\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Name::new(black_box(\"FontDescriptor\")))\n    });\n\n    group.bench_function(\"eq_same\", |b| {\n        b.iter(|| black_box(\u0026name1) == black_box(\u0026name2))\n    });\n\n    group.bench_function(\"eq_diff\", |b| {\n        b.iter(|| black_box(\u0026name1) == black_box(\u0026name3))\n    });\n\n    group.bench_function(\"to_string\", |b| {\n        b.iter(|| black_box(\u0026name1).to_string())\n    });\n\n    group.finish();\n}\n\nfn bench_string_operations(c: \u0026mut Criterion) {\n    let literal = PdfString::new(b\"Hello, World!\".to_vec());\n\n    let mut group = c.benchmark_group(\"pdf/string\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| PdfString::new(black_box(b\"Test string content\".to_vec())))\n    });\n\n    group.bench_function(\"as_bytes\", |b| {\n        b.iter(|| black_box(\u0026literal).as_bytes())\n    });\n\n    group.finish();\n}\n\nfn bench_array_operations(c: \u0026mut Criterion) {\n    let small_array: Vec\u003cObject\u003e = (0..10).map(|i| Object::Int(i)).collect();\n    let large_array: Vec\u003cObject\u003e = (0..1000).map(|i| Object::Int(i)).collect();\n\n    let mut group = c.benchmark_group(\"pdf/array\");\n\n    group.bench_function(\"create_10\", |b| {\n        b.iter(|| {\n            Object::Array(\n                (0..10)\n                    .map(|i| Object::Int(black_box(i)))\n                    .collect()\n            )\n        })\n    });\n\n    group.bench_function(\"create_1000\", |b| {\n        b.iter(|| {\n            Object::Array(\n                (0..1000)\n                    .map(|i| Object::Int(black_box(i)))\n                    .collect()\n            )\n        })\n    });\n\n    group.bench_function(\"access_10\", |b| {\n        let arr = Object::Array(small_array.clone());\n        b.iter(|| {\n            if let Object::Array(ref a) = arr {\n                black_box(\u0026a[5])\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.bench_function(\"access_1000\", |b| {\n        let arr = Object::Array(large_array.clone());\n        b.iter(|| {\n            if let Object::Array(ref a) = arr {\n                black_box(\u0026a[500])\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_dict_operations(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"pdf/dict\");\n\n    // Small dictionary (typical PDF object)\n    let mut small_dict: HashMap\u003cName, Object\u003e = HashMap::new();\n    small_dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n    small_dict.insert(Name::new(\"Parent\"), Object::Ref(ObjRef::new(1, 0)));\n    small_dict.insert(Name::new(\"MediaBox\"), Object::Array(vec![\n        Object::Int(0), Object::Int(0), Object::Int(612), Object::Int(792)\n    ]));\n\n    group.bench_function(\"create_small\", |b| {\n        b.iter(|| {\n            let mut dict: HashMap\u003cName, Object\u003e = HashMap::new();\n            dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n            dict.insert(Name::new(\"Parent\"), Object::Ref(ObjRef::new(1, 0)));\n            Object::Dict(dict)\n        })\n    });\n\n    group.bench_function(\"lookup\", |b| {\n        let dict = Object::Dict(small_dict.clone());\n        let key = Name::new(\"Type\");\n        b.iter(|| {\n            if let Object::Dict(ref d) = dict {\n                black_box(d.get(black_box(\u0026key)))\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.bench_function(\"insert\", |b| {\n        b.iter_batched(\n            || HashMap::new(),\n            |mut dict: HashMap\u003cName, Object\u003e| {\n                dict.insert(\n                    Name::new(black_box(\"NewKey\")),\n                    Object::Int(black_box(42))\n                );\n                dict\n            },\n            criterion::BatchSize::SmallInput\n        )\n    });\n\n    group.finish();\n}\n\nfn bench_object_type_checks(c: \u0026mut Criterion) {\n    let objects = vec![\n        Object::Null,\n        Object::Bool(true),\n        Object::Int(42),\n        Object::Real(3.14),\n        Object::Name(Name::new(\"Test\")),\n        Object::String(PdfString::new(b\"Hello\".to_vec())),\n        Object::Array(vec![Object::Int(1), Object::Int(2)]),\n        Object::Dict(HashMap::new()),\n        Object::Ref(ObjRef::new(1, 0)),\n    ];\n\n    let mut group = c.benchmark_group(\"pdf/object/type_check\");\n\n    group.bench_function(\"is_null\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.is_null());\n            }\n        })\n    });\n\n    group.bench_function(\"as_int\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.as_int());\n            }\n        })\n    });\n\n    group.bench_function(\"as_dict\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.as_dict());\n            }\n        })\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_object_creation,\n    bench_name_operations,\n    bench_string_operations,\n    bench_array_operations,\n    bench_dict_operations,\n    bench_object_type_checks,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","buffer.rs"],"content":"//! C FFI for buffer - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, BUFFERS};\nuse std::ffi::{c_char, c_int, c_void};\n\n/// Internal buffer state\npub struct Buffer {\n    data: Vec\u003cu8\u003e,\n}\n\nimpl Buffer {\n    pub fn new(capacity: usize) -\u003e Self {\n        Self {\n            data: Vec::with_capacity(capacity),\n        }\n    }\n\n    pub fn from_data(data: \u0026[u8]) -\u003e Self {\n        Self {\n            data: data.to_vec(),\n        }\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.data.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.data.is_empty()\n    }\n\n    pub fn data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.data\n    }\n\n    pub fn data_mut(\u0026mut self) -\u003e \u0026mut Vec\u003cu8\u003e {\n        \u0026mut self.data\n    }\n\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\n        self.data.extend_from_slice(data);\n    }\n\n    pub fn append_byte(\u0026mut self, byte: u8) {\n        self.data.push(byte);\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.data.clear();\n    }\n\n    pub fn resize(\u0026mut self, new_size: usize) {\n        self.data.resize(new_size, 0);\n    }\n\n    pub fn ensure_null_terminated(\u0026mut self) {\n        if self.data.is_empty() || self.data.last() != Some(\u00260) {\n            self.data.push(0);\n        }\n    }\n}\n\n/// Create a new buffer with given capacity\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_buffer(_ctx: Handle, capacity: usize) -\u003e Handle {\n    BUFFERS.insert(Buffer::new(capacity))\n}\n\n/// Create a buffer from copied data\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `size` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_buffer_from_copied_data(\n    _ctx: Handle,\n    data: *const u8,\n    size: usize,\n) -\u003e Handle {\n    if data.is_null() || size == 0 {\n        return BUFFERS.insert(Buffer::new(0));\n    }\n\n    // SAFETY: Caller guarantees data points to valid memory of `size` bytes\n    #[allow(unsafe_code)]\n    let data_slice = unsafe { std::slice::from_raw_parts(data, size) };\n\n    BUFFERS.insert(Buffer::from_data(data_slice))\n}\n\n/// Keep (increment ref) a buffer - returns same handle\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    BUFFERS.keep(buf)\n}\n\n/// Drop a buffer reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_buffer(_ctx: Handle, buf: Handle) {\n    let _ = BUFFERS.remove(buf);\n}\n\n/// Get buffer storage - returns length, optionally fills data pointer\n///\n/// Note: This function cannot safely return a pointer to internal data\n/// because the buffer may be moved or reallocated. For safe access,\n/// use fz_buffer_len and copy the data.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_buffer_storage(\n    _ctx: Handle,\n    buf: Handle,\n    datap: *mut *mut u8,\n) -\u003e usize {\n    let Some(buffer) = BUFFERS.get(buf) else {\n        if !datap.is_null() {\n            // SAFETY: Caller guarantees datap is valid if non-null\n            #[allow(unsafe_code)]\n            unsafe { *datap = std::ptr::null_mut(); }\n        }\n        return 0;\n    };\n\n    let guard = buffer.lock().unwrap();\n    let len = guard.len();\n\n    if !datap.is_null() {\n        // We can't safely return a pointer to internal data\n        // because the buffer may be reallocated\n        #[allow(unsafe_code)]\n        unsafe { *datap = std::ptr::null_mut(); }\n    }\n\n    len\n}\n\n/// Get buffer as null-terminated C string\n///\n/// Note: This function cannot safely return a pointer to internal buffer data\n/// because the data may be moved or reallocated. Returns empty string for now.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_string_from_buffer(_ctx: Handle, _buf: Handle) -\u003e *const c_char {\n    // Can't return internal pointer safely without stable address\n    // Return empty string for now\n    c\"\".as_ptr()\n}\n\n/// Resize buffer to new capacity\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_resize_buffer(_ctx: Handle, buf: Handle, capacity: usize) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.resize(capacity);\n        }\n    }\n}\n\n/// Grow buffer (double capacity or minimum 256)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_grow_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            let current_cap = guard.data.capacity();\n            let new_cap = (current_cap * 2).max(256);\n            guard.data.reserve(new_cap.saturating_sub(current_cap));\n        }\n    }\n}\n\n/// Trim buffer to fit contents\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_trim_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.data.shrink_to_fit();\n        }\n    }\n}\n\n/// Clear buffer contents\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.clear();\n        }\n    }\n}\n\n/// Append data to buffer\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_data(\n    _ctx: Handle,\n    buf: Handle,\n    data: *const c_void,\n    len: usize,\n) {\n    if data.is_null() || len == 0 {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            // SAFETY: Caller guarantees data points to valid memory of `len` bytes\n            #[allow(unsafe_code)]\n            let slice = unsafe { std::slice::from_raw_parts(data as *const u8, len) };\n            guard.append(slice);\n        }\n    }\n}\n\n/// Append C string to buffer\n///\n/// # Safety\n/// Caller must ensure `data` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_string(_ctx: Handle, buf: Handle, data: *const c_char) {\n    if data.is_null() {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            // SAFETY: Caller guarantees data is a valid null-terminated C string\n            #[allow(unsafe_code)]\n            let c_str = unsafe { std::ffi::CStr::from_ptr(data) };\n            guard.append(c_str.to_bytes());\n        }\n    }\n}\n\n/// Append single byte to buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_byte(_ctx: Handle, buf: Handle, c: c_int) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.append_byte(c as u8);\n        }\n    }\n}\n\n/// Null-terminate buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_terminate_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.ensure_null_terminated();\n        }\n    }\n}\n\n/// Compute MD5 digest of buffer contents\n///\n/// # Safety\n/// Caller must ensure `digest` points to valid writable memory of 16 bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_md5_buffer(\n    _ctx: Handle,\n    buf: Handle,\n    digest: *mut [u8; 16],\n) {\n    if digest.is_null() {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            use md5::{Digest, Md5};\n            let mut hasher = Md5::new();\n            hasher.update(guard.data());\n            let result = hasher.finalize();\n\n            // SAFETY: Caller guarantees digest points to valid writable [u8; 16]\n            #[allow(unsafe_code)]\n            unsafe {\n                (*digest).copy_from_slice(\u0026result);\n            }\n        }\n    }\n}\n\n/// Clone a buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clone_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return BUFFERS.insert(Buffer::from_data(guard.data()));\n        }\n    }\n    0\n}\n\n/// Get buffer length\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_buffer_len(_ctx: Handle, buf: Handle) -\u003e usize {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return guard.len();\n        }\n    }\n    0\n}\n\n// Note: Some functions that return raw pointers to internal data\n// cannot be implemented safely. They would require:\n// 1. A stable buffer address (Box::leak or similar)\n// 2. Unsafe blocks to convert to raw pointers\n//\n// For a fully safe API, consider returning handles or using\n// callback-based APIs instead.\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_buffer_create_and_drop() {\n        let handle = fz_new_buffer(0, 100);\n        assert_ne!(handle, 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_append_byte() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_append_byte(0, handle, b'B' as i32);\n\n        let len = fz_buffer_len(0, handle);\n        assert_eq!(len, 2);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_clear() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'X' as i32);\n        assert_eq!(fz_buffer_len(0, handle), 1);\n\n        fz_clear_buffer(0, handle);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_keep() {\n        let handle = fz_new_buffer(0, 0);\n        let kept = fz_keep_buffer(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_resize() {\n        let handle = fz_new_buffer(0, 10);\n        fz_resize_buffer(0, handle, 100);\n        // Resize should succeed\n        assert_eq!(fz_buffer_len(0, handle), 100);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_grow() {\n        let handle = fz_new_buffer(0, 10);\n        fz_grow_buffer(0, handle);\n        // Buffer should be able to accommodate growth\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_trim() {\n        let handle = fz_new_buffer(0, 100);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_trim_buffer(0, handle);\n        assert_eq!(fz_buffer_len(0, handle), 1);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_clone() {\n        let handle1 = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle1, b'X' as i32);\n        fz_append_byte(0, handle1, b'Y' as i32);\n\n        let handle2 = fz_clone_buffer(0, handle1);\n        assert_ne!(handle2, 0);\n        assert_eq!(fz_buffer_len(0, handle2), 2);\n\n        // Modify original, clone should be unchanged\n        fz_clear_buffer(0, handle1);\n        assert_eq!(fz_buffer_len(0, handle1), 0);\n        assert_eq!(fz_buffer_len(0, handle2), 2);\n\n        fz_drop_buffer(0, handle1);\n        fz_drop_buffer(0, handle2);\n    }\n\n    #[test]\n    fn test_buffer_len_invalid() {\n        let len = fz_buffer_len(0, 0);\n        assert_eq!(len, 0);\n    }\n\n    #[test]\n    fn test_buffer_append_multiple() {\n        let handle = fz_new_buffer(0, 0);\n        for i in 0..100 {\n            fz_append_byte(0, handle, i as i32);\n        }\n        assert_eq!(fz_buffer_len(0, handle), 100);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_append_byte(0, handle, b'i' as i32);\n\n        let mut datap: *mut u8 = std::ptr::null_mut();\n        let size = fz_buffer_storage(0, handle, \u0026mut datap);\n\n        // Size should be the length of the buffer\n        assert_eq!(size, 2);\n        // datap will be null because we can't safely return internal pointer\n        assert!(datap.is_null());\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_internal() {\n        let buf = Buffer::new(10);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.data().is_empty());\n    }\n\n    #[test]\n    fn test_buffer_from_data() {\n        let data = [1u8, 2, 3, 4, 5];\n        let buf = Buffer::from_data(\u0026data);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.data(), \u0026data);\n    }\n\n    #[test]\n    fn test_buffer_append_internal() {\n        let mut buf = Buffer::new(0);\n        buf.append_byte(0x42);\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.data(), \u0026[0x42]);\n    }\n\n    #[test]\n    fn test_buffer_clear_internal() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n    }\n\n    // ============================================================================\n    // Additional tests for better coverage\n    // ============================================================================\n\n    #[test]\n    fn test_buffer_from_copied_data() {\n        let data = [1u8, 2, 3, 4, 5];\n        let handle = fz_new_buffer_from_copied_data(0, data.as_ptr(), data.len());\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_from_copied_data_null() {\n        let handle = fz_new_buffer_from_copied_data(0, std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_from_copied_data_null_with_size() {\n        // Even with non-zero size, null ptr should return empty buffer\n        let handle = fz_new_buffer_from_copied_data(0, std::ptr::null(), 100);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage_null_datap() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n\n        // Pass null pointer for datap\n        let size = fz_buffer_storage(0, handle, std::ptr::null_mut());\n        assert_eq!(size, 1);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage_invalid_handle() {\n        let mut datap: *mut u8 = std::ptr::null_mut();\n        let size = fz_buffer_storage(0, 99999, \u0026mut datap);\n        assert_eq!(size, 0);\n        assert!(datap.is_null());\n    }\n\n    #[test]\n    fn test_fz_string_from_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n\n        let ptr = fz_string_from_buffer(0, handle);\n        assert!(!ptr.is_null());\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_resize_invalid_handle() {\n        // Should not panic\n        fz_resize_buffer(0, 99999, 100);\n    }\n\n    #[test]\n    fn test_buffer_grow_invalid_handle() {\n        // Should not panic\n        fz_grow_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_buffer_trim_invalid_handle() {\n        // Should not panic\n        fz_trim_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_buffer_clear_invalid_handle() {\n        // Should not panic\n        fz_clear_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_fz_append_data() {\n        let handle = fz_new_buffer(0, 0);\n        let data = [1u8, 2, 3, 4, 5];\n        fz_append_data(0, handle, data.as_ptr() as *const c_void, data.len());\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_data_null() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_data(0, handle, std::ptr::null(), 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_data_invalid_handle() {\n        let data = [1u8, 2, 3];\n        // Should not panic\n        fz_append_data(0, 99999, data.as_ptr() as *const c_void, data.len());\n    }\n\n    #[test]\n    fn test_fz_append_string() {\n        let handle = fz_new_buffer(0, 0);\n        let s = std::ffi::CString::new(\"Hello\").unwrap();\n        fz_append_string(0, handle, s.as_ptr());\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_string_null() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_string(0, handle, std::ptr::null());\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_string_invalid_handle() {\n        let s = std::ffi::CString::new(\"Hello\").unwrap();\n        // Should not panic\n        fz_append_string(0, 99999, s.as_ptr());\n    }\n\n    #[test]\n    fn test_fz_append_byte_invalid_handle() {\n        // Should not panic\n        fz_append_byte(0, 99999, b'X' as i32);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_terminate_buffer(0, handle);\n        // After termination, buffer should have a null byte\n        assert_eq!(fz_buffer_len(0, handle), 2);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer_invalid_handle() {\n        // Should not panic\n        fz_terminate_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer_already_terminated() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_append_byte(0, handle, 0); // Already has null\n        fz_terminate_buffer(0, handle);\n        // Should not add another null\n        assert_eq!(fz_buffer_len(0, handle), 2);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_append_byte(0, handle, b'B' as i32);\n        fz_append_byte(0, handle, b'C' as i32);\n\n        let mut digest = [0u8; 16];\n        fz_md5_buffer(0, handle, \u0026mut digest);\n\n        // MD5(\"ABC\") is known\n        assert_ne!(digest, [0u8; 16]);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer_null_digest() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        // Should not panic\n        fz_md5_buffer(0, handle, std::ptr::null_mut());\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer_invalid_handle() {\n        let mut digest = [0u8; 16];\n        // Should not panic\n        fz_md5_buffer(0, 99999, \u0026mut digest);\n    }\n\n    #[test]\n    fn test_fz_clone_buffer_invalid_handle() {\n        let handle = fz_clone_buffer(0, 99999);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_buffer_is_empty() {\n        let buf = Buffer::new(10);\n        assert!(buf.is_empty());\n\n        let buf2 = Buffer::from_data(\u0026[1, 2, 3]);\n        assert!(!buf2.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_data_mut() {\n        let mut buf = Buffer::new(0);\n        buf.data_mut().push(1);\n        buf.data_mut().push(2);\n        assert_eq!(buf.len(), 2);\n    }\n\n    #[test]\n    fn test_buffer_append() {\n        let mut buf = Buffer::new(0);\n        buf.append(\u0026[1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        buf.append(\u0026[4, 5]);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.data(), \u0026[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_resize_internal() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.resize(5);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(\u0026buf.data()[..3], \u0026[1, 2, 3]);\n        assert_eq!(\u0026buf.data()[3..], \u0026[0, 0]);\n    }\n\n    #[test]\n    fn test_buffer_ensure_null_terminated() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 4);\n        assert_eq!(buf.data().last(), Some(\u00260));\n\n        // Should not add another null\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 4);\n    }\n\n    #[test]\n    fn test_buffer_ensure_null_terminated_empty() {\n        let mut buf = Buffer::new(0);\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.data(), \u0026[0]);\n    }\n}\n","traces":[{"line":13,"address":[2016048],"length":1,"stats":{"Line":7}},{"line":15,"address":[1458595],"length":1,"stats":{"Line":7}},{"line":19,"address":[1458656],"length":1,"stats":{"Line":4}},{"line":21,"address":[1458679],"length":1,"stats":{"Line":4}},{"line":25,"address":[1458736],"length":1,"stats":{"Line":3}},{"line":26,"address":[1458741],"length":1,"stats":{"Line":4}},{"line":29,"address":[1458752],"length":1,"stats":{"Line":1}},{"line":30,"address":[1458757],"length":1,"stats":{"Line":1}},{"line":33,"address":[2016240],"length":1,"stats":{"Line":5}},{"line":34,"address":[1458773],"length":1,"stats":{"Line":1}},{"line":37,"address":[1458784],"length":1,"stats":{"Line":1}},{"line":41,"address":[1458800],"length":1,"stats":{"Line":1}},{"line":42,"address":[1458818],"length":1,"stats":{"Line":1}},{"line":45,"address":[1458848],"length":1,"stats":{"Line":2}},{"line":46,"address":[2016336],"length":1,"stats":{"Line":2}},{"line":49,"address":[1458896],"length":1,"stats":{"Line":1}},{"line":50,"address":[1458901],"length":1,"stats":{"Line":1}},{"line":53,"address":[1458912],"length":1,"stats":{"Line":1}},{"line":54,"address":[2016398],"length":1,"stats":{"Line":1}},{"line":57,"address":[1458960],"length":1,"stats":{"Line":2}},{"line":58,"address":[1458973],"length":1,"stats":{"Line":2}},{"line":59,"address":[1459038],"length":1,"stats":{"Line":2}},{"line":66,"address":[1459072,1459167,1459114],"length":1,"stats":{"Line":13}},{"line":67,"address":[1459125,1459091],"length":1,"stats":{"Line":26}},{"line":75,"address":[1459476,1459269,1459200],"length":1,"stats":{"Line":3}},{"line":80,"address":[1459279,1459254],"length":1,"stats":{"Line":6}},{"line":81,"address":[2016768,2016992],"length":1,"stats":{"Line":4}},{"line":86,"address":[1459332],"length":1,"stats":{"Line":1}},{"line":88,"address":[1459509,1459395],"length":1,"stats":{"Line":2}},{"line":93,"address":[1459600,1459642],"length":1,"stats":{"Line":1}},{"line":94,"address":[1459619,1459658],"length":1,"stats":{"Line":2}},{"line":99,"address":[1459696,1459796,1459738],"length":1,"stats":{"Line":6}},{"line":100,"address":[1459715,1459754],"length":1,"stats":{"Line":13}},{"line":109,"address":[1460456,1460482,1459824,1459888,1460415],"length":1,"stats":{"Line":1}},{"line":114,"address":[1459904,1459865],"length":1,"stats":{"Line":2}},{"line":115,"address":[1460492,1460596,1460467],"length":1,"stats":{"Line":3}},{"line":118,"address":[1460498,1460598,1460529],"length":1,"stats":{"Line":2}},{"line":120,"address":[1460513],"length":1,"stats":{"Line":1}},{"line":123,"address":[1459968,1460054],"length":1,"stats":{"Line":3}},{"line":124,"address":[1460207,1460134],"length":1,"stats":{"Line":4}},{"line":126,"address":[1460384,1460241],"length":1,"stats":{"Line":3}},{"line":130,"address":[1460266,1460316,1460386],"length":1,"stats":{"Line":2}},{"line":133,"address":[1460287],"length":1,"stats":{"Line":1}},{"line":141,"address":[1460624,1460661],"length":1,"stats":{"Line":1}},{"line":144,"address":[1460638],"length":1,"stats":{"Line":1}},{"line":149,"address":[1460688,1461176,1460746,1461151],"length":1,"stats":{"Line":1}},{"line":150,"address":[2018083,2018118],"length":1,"stats":{"Line":2}},{"line":151,"address":[1460826,1460912,1460958],"length":1,"stats":{"Line":3}},{"line":152,"address":[1461045,1460976],"length":1,"stats":{"Line":2}},{"line":159,"address":[1461216,1461267,1461862,1461837],"length":1,"stats":{"Line":1}},{"line":160,"address":[1461244,1461283],"length":1,"stats":{"Line":2}},{"line":161,"address":[1461433,1461479,1461347],"length":1,"stats":{"Line":3}},{"line":162,"address":[1461567,1461500],"length":1,"stats":{"Line":2}},{"line":163,"address":[1461596],"length":1,"stats":{"Line":1}},{"line":164,"address":[2018954],"length":1,"stats":{"Line":1}},{"line":171,"address":[1462372,1461904,1461949,1462347],"length":1,"stats":{"Line":1}},{"line":172,"address":[1461926,1461965],"length":1,"stats":{"Line":2}},{"line":173,"address":[1462029,1462112,1462158],"length":1,"stats":{"Line":3}},{"line":174,"address":[2019465,2019417],"length":1,"stats":{"Line":2}},{"line":181,"address":[1462416,1462877,1462461,1462852],"length":1,"stats":{"Line":1}},{"line":182,"address":[2019654,2019689],"length":1,"stats":{"Line":2}},{"line":183,"address":[1462624,1462541,1462670],"length":1,"stats":{"Line":3}},{"line":184,"address":[1462688,1462749],"length":1,"stats":{"Line":2}},{"line":194,"address":[1462912,1463574,1462994,1463602],"length":1,"stats":{"Line":1}},{"line":200,"address":[2020168,2020147],"length":1,"stats":{"Line":2}},{"line":204,"address":[1463029],"length":1,"stats":{"Line":1}},{"line":205,"address":[1463126,1463212,1463277],"length":1,"stats":{"Line":3}},{"line":208,"address":[2020440,2020508],"length":1,"stats":{"Line":2}},{"line":209,"address":[1463414],"length":1,"stats":{"Line":1}},{"line":219,"address":[1464297,1463632,1463701,1464325],"length":1,"stats":{"Line":3}},{"line":220,"address":[2020811,2020790],"length":1,"stats":{"Line":6}},{"line":224,"address":[2020817,2020854],"length":1,"stats":{"Line":4}},{"line":225,"address":[2020925,2021002,2021046],"length":1,"stats":{"Line":3}},{"line":228,"address":[1464004,1464075],"length":1,"stats":{"Line":2}},{"line":229,"address":[2021183],"length":1,"stats":{"Line":1}},{"line":236,"address":[2021460,2021408,2021816,2021837],"length":1,"stats":{"Line":2}},{"line":237,"address":[2021441,2021476],"length":1,"stats":{"Line":4}},{"line":238,"address":[1464636,1464504,1464590],"length":1,"stats":{"Line":12}},{"line":239,"address":[1464654,1464722],"length":1,"stats":{"Line":8}},{"line":246,"address":[1465357,1465332,1464896,1464941],"length":1,"stats":{"Line":3}},{"line":247,"address":[2021910,2021945],"length":1,"stats":{"Line":6}},{"line":248,"address":[2022114,2022010,2022081],"length":1,"stats":{"Line":6}},{"line":249,"address":[1465168,1465229],"length":1,"stats":{"Line":4}},{"line":259,"address":[1465392,1466209,1466234,1465461],"length":1,"stats":{"Line":3}},{"line":264,"address":[1465446,1465471],"length":1,"stats":{"Line":6}},{"line":268,"address":[1465477,1465518],"length":1,"stats":{"Line":4}},{"line":269,"address":[1465665,1465582,1465711],"length":1,"stats":{"Line":3}},{"line":271,"address":[1465741],"length":1,"stats":{"Line":1}},{"line":272,"address":[1465804],"length":1,"stats":{"Line":1}},{"line":273,"address":[1465883],"length":1,"stats":{"Line":1}},{"line":278,"address":[2022899],"length":1,"stats":{"Line":1}},{"line":286,"address":[1466323,1466842,1466883,1466272],"length":1,"stats":{"Line":2}},{"line":287,"address":[1466339,1466300],"length":1,"stats":{"Line":3}},{"line":288,"address":[1466535,1466403,1466489],"length":1,"stats":{"Line":3}},{"line":289,"address":[2023395,2023462],"length":1,"stats":{"Line":2}},{"line":292,"address":[1466924],"length":1,"stats":{"Line":1}},{"line":297,"address":[1467407,1466992,1466944,1467448],"length":1,"stats":{"Line":2}},{"line":298,"address":[1467008,1466969],"length":1,"stats":{"Line":4}},{"line":299,"address":[1467158,1467204,1467072],"length":1,"stats":{"Line":6}},{"line":300,"address":[1467222,1467286],"length":1,"stats":{"Line":9}},{"line":303,"address":[1467489],"length":1,"stats":{"Line":1}}],"covered":101,"coverable":101},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","colorspace.rs"],"content":"//! C FFI for colorspace - MuPDF compatible\n//! Safe Rust implementation\n\nuse std::ffi::c_char;\n\n/// Colorspace type enumeration\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ColorspaceType {\n    None = 0,\n    Gray = 1,\n    Rgb = 2,\n    Bgr = 3,\n    Cmyk = 4,\n    Lab = 5,\n    Indexed = 6,\n    Separation = 7,\n}\n\n/// Colorspace handle - we use small integers for device colorspaces\n/// Handles 1-4 are reserved for device colorspaces\n/// 0 = invalid/null\npub type ColorspaceHandle = u64;\n\npub const FZ_COLORSPACE_GRAY: ColorspaceHandle = 1;\npub const FZ_COLORSPACE_RGB: ColorspaceHandle = 2;\npub const FZ_COLORSPACE_BGR: ColorspaceHandle = 3;\npub const FZ_COLORSPACE_CMYK: ColorspaceHandle = 4;\npub const FZ_COLORSPACE_LAB: ColorspaceHandle = 5;\n\n/// Get number of components for a colorspace\nfn colorspace_n(handle: ColorspaceHandle) -\u003e i32 {\n    match handle {\n        FZ_COLORSPACE_GRAY =\u003e 1,\n        FZ_COLORSPACE_RGB | FZ_COLORSPACE_BGR =\u003e 3,\n        FZ_COLORSPACE_CMYK =\u003e 4,\n        FZ_COLORSPACE_LAB =\u003e 3,\n        _ =\u003e 0,\n    }\n}\n\n/// Get colorspace type\nfn colorspace_type(handle: ColorspaceHandle) -\u003e ColorspaceType {\n    match handle {\n        FZ_COLORSPACE_GRAY =\u003e ColorspaceType::Gray,\n        FZ_COLORSPACE_RGB =\u003e ColorspaceType::Rgb,\n        FZ_COLORSPACE_BGR =\u003e ColorspaceType::Bgr,\n        FZ_COLORSPACE_CMYK =\u003e ColorspaceType::Cmyk,\n        FZ_COLORSPACE_LAB =\u003e ColorspaceType::Lab,\n        _ =\u003e ColorspaceType::None,\n    }\n}\n\n/// Get device gray colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_gray(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_GRAY\n}\n\n/// Get device RGB colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_rgb(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_RGB\n}\n\n/// Get device BGR colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_bgr(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_BGR\n}\n\n/// Get device CMYK colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_cmyk(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_CMYK\n}\n\n/// Get device Lab colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_lab(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_LAB\n}\n\n/// Keep (increment ref) colorspace - device colorspaces are immortal\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_colorspace(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e ColorspaceHandle {\n    cs // Device colorspaces don't need ref counting\n}\n\n/// Drop colorspace reference - device colorspaces are immortal\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_colorspace(_ctx: super::Handle, _cs: ColorspaceHandle) {\n    // Device colorspaces are never freed\n}\n\n/// Get number of components in colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_n(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    colorspace_n(cs)\n}\n\n/// Check if colorspace is gray\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_gray(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Gray)\n}\n\n/// Check if colorspace is RGB\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_rgb(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Rgb)\n}\n\n/// Check if colorspace is CMYK\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_cmyk(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Cmyk)\n}\n\n/// Check if colorspace is Lab\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_lab(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Lab)\n}\n\n/// Check if colorspace is device colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_device(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(cs \u003e= FZ_COLORSPACE_GRAY \u0026\u0026 cs \u003c= FZ_COLORSPACE_LAB)\n}\n\n/// Get colorspace name\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_name(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e *const c_char {\n    match cs {\n        FZ_COLORSPACE_GRAY =\u003e c\"DeviceGray\".as_ptr(),\n        FZ_COLORSPACE_RGB =\u003e c\"DeviceRGB\".as_ptr(),\n        FZ_COLORSPACE_BGR =\u003e c\"DeviceBGR\".as_ptr(),\n        FZ_COLORSPACE_CMYK =\u003e c\"DeviceCMYK\".as_ptr(),\n        FZ_COLORSPACE_LAB =\u003e c\"Lab\".as_ptr(),\n        _ =\u003e c\"Unknown\".as_ptr(),\n    }\n}\n\n/// Convert color from one colorspace to another\n///\n/// # Safety\n/// Caller must ensure:\n/// - `src` points to valid memory of at least `src_cs.n` floats\n/// - `dst` points to writable memory of at least `dst_cs.n` floats\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_convert_color(\n    _ctx: super::Handle,\n    src_cs: ColorspaceHandle,\n    src: *const f32,\n    dst_cs: ColorspaceHandle,\n    dst: *mut f32,\n    _proof_cs: ColorspaceHandle,\n) {\n    if src.is_null() || dst.is_null() {\n        return;\n    }\n\n    let src_n = colorspace_n(src_cs) as usize;\n    let dst_n = colorspace_n(dst_cs) as usize;\n\n    if src_n == 0 || dst_n == 0 {\n        return;\n    }\n\n    // SAFETY: Caller guarantees src and dst point to valid memory\n    #[allow(unsafe_code)]\n    let (src_slice, dst_slice) = unsafe {\n        (\n            std::slice::from_raw_parts(src, src_n),\n            std::slice::from_raw_parts_mut(dst, dst_n),\n        )\n    };\n\n    // Simple color conversion (Gray -\u003e RGB, RGB -\u003e Gray, etc.)\n    match (colorspace_type(src_cs), colorspace_type(dst_cs)) {\n        (ColorspaceType::Gray, ColorspaceType::Rgb) =\u003e {\n            let g = src_slice[0];\n            dst_slice[0] = g;\n            dst_slice[1] = g;\n            dst_slice[2] = g;\n        }\n        (ColorspaceType::Rgb, ColorspaceType::Gray) =\u003e {\n            // Luminance formula\n            dst_slice[0] = src_slice[0] * 0.299 + src_slice[1] * 0.587 + src_slice[2] * 0.114;\n        }\n        (ColorspaceType::Rgb, ColorspaceType::Cmyk) =\u003e {\n            let r = src_slice[0];\n            let g = src_slice[1];\n            let b = src_slice[2];\n            let k = 1.0 - r.max(g).max(b);\n            if k \u003c 1.0 {\n                let inv_k = 1.0 / (1.0 - k);\n                dst_slice[0] = (1.0 - r - k) * inv_k;\n                dst_slice[1] = (1.0 - g - k) * inv_k;\n                dst_slice[2] = (1.0 - b - k) * inv_k;\n            } else {\n                dst_slice[0] = 0.0;\n                dst_slice[1] = 0.0;\n                dst_slice[2] = 0.0;\n            }\n            dst_slice[3] = k;\n        }\n        (ColorspaceType::Cmyk, ColorspaceType::Rgb) =\u003e {\n            let c = src_slice[0];\n            let m = src_slice[1];\n            let y = src_slice[2];\n            let k = src_slice[3];\n            dst_slice[0] = (1.0 - c) * (1.0 - k);\n            dst_slice[1] = (1.0 - m) * (1.0 - k);\n            dst_slice[2] = (1.0 - y) * (1.0 - k);\n        }\n        _ if src_cs == dst_cs =\u003e {\n            // Same colorspace, just copy\n            dst_slice[..src_n.min(dst_n)].copy_from_slice(\u0026src_slice[..src_n.min(dst_n)]);\n        }\n        _ =\u003e {\n            // Default: fill with zeros\n            dst_slice.fill(0.0);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_device_colorspaces() {\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_RGB), 3);\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_CMYK), 4);\n    }\n\n    #[test]\n    fn test_colorspace_checks() {\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_RGB), 1);\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_CMYK), 1);\n    }\n\n    #[test]\n    fn test_colorspace_is_gray_negative() {\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_RGB), 0);\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_CMYK), 0);\n    }\n\n    #[test]\n    fn test_colorspace_is_rgb_negative() {\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_GRAY), 0);\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_CMYK), 0);\n    }\n\n    #[test]\n    fn test_colorspace_is_cmyk_negative() {\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_GRAY), 0);\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_RGB), 0);\n    }\n\n    #[test]\n    fn test_colorspace_type() {\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_GRAY), ColorspaceType::Gray));\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_RGB), ColorspaceType::Rgb));\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_CMYK), ColorspaceType::Cmyk));\n        assert!(matches!(colorspace_type(99), ColorspaceType::None));\n    }\n\n    #[test]\n    fn test_colorspace_n() {\n        assert_eq!(colorspace_n(FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(colorspace_n(FZ_COLORSPACE_RGB), 3);\n        assert_eq!(colorspace_n(FZ_COLORSPACE_CMYK), 4);\n        assert_eq!(colorspace_n(99), 0);\n    }\n\n    #[test]\n    fn test_device_gray_handle() {\n        let handle = fz_device_gray(0);\n        assert_eq!(handle, FZ_COLORSPACE_GRAY);\n    }\n\n    #[test]\n    fn test_device_rgb_handle() {\n        let handle = fz_device_rgb(0);\n        assert_eq!(handle, FZ_COLORSPACE_RGB);\n    }\n\n    #[test]\n    fn test_device_cmyk_handle() {\n        let handle = fz_device_cmyk(0);\n        assert_eq!(handle, FZ_COLORSPACE_CMYK);\n    }\n\n    #[test]\n    fn test_keep_drop_colorspace() {\n        // Keep and drop should not panic\n        let handle = fz_keep_colorspace(0, FZ_COLORSPACE_RGB);\n        assert_eq!(handle, FZ_COLORSPACE_RGB);\n        fz_drop_colorspace(0, handle);\n    }\n\n    #[test]\n    fn test_convert_color_gray_to_rgb() {\n        let src = [0.5f32];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_GRAY,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert!((dst[0] - 0.5).abs() \u003c 0.01);\n        assert!((dst[1] - 0.5).abs() \u003c 0.01);\n        assert!((dst[2] - 0.5).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_rgb_to_gray() {\n        let src = [1.0f32, 1.0, 1.0]; // White\n        let mut dst = [0.0f32];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_GRAY,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        // Luminance should be close to 1.0 for white\n        assert!((dst[0] - 1.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_rgb_to_cmyk() {\n        let src = [1.0f32, 0.0, 0.0]; // Red\n        let mut dst = [0.0f32; 4];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_CMYK,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        // Red in CMYK: C=0, M=1, Y=1, K=0\n        assert!(dst[0] \u003c 0.1); // Cyan should be low\n        assert_eq!(dst[3], 0.0); // Black should be 0\n    }\n\n    #[test]\n    fn test_convert_color_cmyk_to_rgb() {\n        let src = [0.0f32, 0.0, 0.0, 0.0]; // No ink = white\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_CMYK,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert!((dst[0] - 1.0).abs() \u003c 0.01);\n        assert!((dst[1] - 1.0).abs() \u003c 0.01);\n        assert!((dst[2] - 1.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_same_colorspace() {\n        let src = [0.25f32, 0.5, 0.75];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert_eq!(dst, src);\n    }\n\n    #[test]\n    fn test_convert_color_null_pointers() {\n        // Should not panic with null pointers\n        fz_convert_color(0, FZ_COLORSPACE_RGB, std::ptr::null(), FZ_COLORSPACE_GRAY, std::ptr::null_mut(), 0);\n    }\n\n    #[test]\n    fn test_convert_color_invalid_colorspace() {\n        let src = [0.5f32];\n        let mut dst = [1.0f32; 3];\n\n        // Invalid source colorspace - dst should be filled with zeros\n        fz_convert_color(0, 99, src.as_ptr(), FZ_COLORSPACE_RGB, dst.as_mut_ptr(), 0);\n        // Operation should not panic even with invalid colorspace\n    }\n\n    #[test]\n    fn test_colorspace_is_device() {\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_RGB), 1);\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_CMYK), 1);\n    }\n}\n","traces":[{"line":32,"address":[2287472],"length":1,"stats":{"Line":2}},{"line":33,"address":[1339528],"length":1,"stats":{"Line":3}},{"line":34,"address":[1339573],"length":1,"stats":{"Line":2}},{"line":35,"address":[1339583],"length":1,"stats":{"Line":6}},{"line":36,"address":[1339593],"length":1,"stats":{"Line":2}},{"line":37,"address":[1339603],"length":1,"stats":{"Line":0}},{"line":38,"address":[2287515],"length":1,"stats":{"Line":1}},{"line":43,"address":[1339616],"length":1,"stats":{"Line":2}},{"line":44,"address":[2287576],"length":1,"stats":{"Line":3}},{"line":45,"address":[1339669],"length":1,"stats":{"Line":3}},{"line":46,"address":[1339679],"length":1,"stats":{"Line":2}},{"line":47,"address":[1339689],"length":1,"stats":{"Line":0}},{"line":48,"address":[2287651],"length":1,"stats":{"Line":2}},{"line":49,"address":[1339709],"length":1,"stats":{"Line":0}},{"line":50,"address":[1339659],"length":1,"stats":{"Line":1}},{"line":56,"address":[1339728],"length":1,"stats":{"Line":3}},{"line":62,"address":[1339744],"length":1,"stats":{"Line":2}},{"line":68,"address":[1339760],"length":1,"stats":{"Line":0}},{"line":74,"address":[1339776],"length":1,"stats":{"Line":2}},{"line":80,"address":[1339792],"length":1,"stats":{"Line":0}},{"line":86,"address":[1339808],"length":1,"stats":{"Line":1}},{"line":92,"address":[1339824],"length":1,"stats":{"Line":1}},{"line":98,"address":[1339878,1339840],"length":1,"stats":{"Line":2}},{"line":99,"address":[1339867],"length":1,"stats":{"Line":2}},{"line":104,"address":[1339942,1339904],"length":1,"stats":{"Line":2}},{"line":105,"address":[1339931,1339952],"length":1,"stats":{"Line":4}},{"line":110,"address":[1340016,1340054],"length":1,"stats":{"Line":3}},{"line":111,"address":[1340043,1340064],"length":1,"stats":{"Line":5}},{"line":116,"address":[1340166,1340128],"length":1,"stats":{"Line":2}},{"line":117,"address":[1340155,1340176],"length":1,"stats":{"Line":4}},{"line":122,"address":[1340240,1340278],"length":1,"stats":{"Line":0}},{"line":123,"address":[1340267,1340288],"length":1,"stats":{"Line":0}},{"line":128,"address":[1340352,1340418],"length":1,"stats":{"Line":1}},{"line":129,"address":[1340371],"length":1,"stats":{"Line":1}},{"line":134,"address":[1340448,1340647],"length":1,"stats":{"Line":0}},{"line":135,"address":[1340465],"length":1,"stats":{"Line":0}},{"line":136,"address":[1340527,1340658],"length":1,"stats":{"Line":0}},{"line":137,"address":[1340551,1340678],"length":1,"stats":{"Line":0}},{"line":138,"address":[1340690,1340575],"length":1,"stats":{"Line":0}},{"line":139,"address":[1340599,1340702],"length":1,"stats":{"Line":0}},{"line":140,"address":[1340714,1340623],"length":1,"stats":{"Line":0}},{"line":141,"address":[1340726,1340500],"length":1,"stats":{"Line":0}},{"line":152,"address":[1340860,1340736],"length":1,"stats":{"Line":5}},{"line":160,"address":[2288794,2288821,2288864],"length":1,"stats":{"Line":19}},{"line":164,"address":[2288878],"length":1,"stats":{"Line":4}},{"line":165,"address":[2288925],"length":1,"stats":{"Line":2}},{"line":167,"address":[1341029],"length":1,"stats":{"Line":7}},{"line":175,"address":[1341073],"length":1,"stats":{"Line":6}},{"line":176,"address":[2289088],"length":1,"stats":{"Line":4}},{"line":181,"address":[1341492,1341343],"length":1,"stats":{"Line":8}},{"line":183,"address":[1341643,1341581],"length":1,"stats":{"Line":2}},{"line":184,"address":[2289628,2289562,2289652],"length":1,"stats":{"Line":4}},{"line":185,"address":[2289724,2289632,2289699],"length":1,"stats":{"Line":4}},{"line":186,"address":[1341831,1341849,1341768],"length":1,"stats":{"Line":4}},{"line":188,"address":[2290146],"length":1,"stats":{"Line":1}},{"line":190,"address":[1341883,1342223,1341932],"length":1,"stats":{"Line":2}},{"line":193,"address":[2289836,2290200,2290242],"length":1,"stats":{"Line":2}},{"line":194,"address":[1342390,1342286,1342347],"length":1,"stats":{"Line":2}},{"line":195,"address":[2290425,2290378,2290306],"length":1,"stats":{"Line":2}},{"line":196,"address":[1342465,1342533],"length":1,"stats":{"Line":2}},{"line":197,"address":[2291150,2290814,2290524],"length":1,"stats":{"Line":2}},{"line":198,"address":[1342647],"length":1,"stats":{"Line":1}},{"line":199,"address":[2290923,2290622,2290973],"length":1,"stats":{"Line":2}},{"line":200,"address":[1343159,1343108,1342995],"length":1,"stats":{"Line":2}},{"line":201,"address":[1343227,1343117,1343205],"length":1,"stats":{"Line":2}},{"line":203,"address":[1342609,1342740,1342767],"length":1,"stats":{"Line":0}},{"line":204,"address":[1342747,1342808,1342836],"length":1,"stats":{"Line":0}},{"line":205,"address":[1342888,1342816,1342870],"length":1,"stats":{"Line":0}},{"line":207,"address":[1343270,1343288,1342922],"length":1,"stats":{"Line":2}},{"line":210,"address":[1343322,1343384],"length":1,"stats":{"Line":1}},{"line":211,"address":[2291361,2291401,2291300],"length":1,"stats":{"Line":2}},{"line":212,"address":[1343547,1343507,1343445],"length":1,"stats":{"Line":2}},{"line":213,"address":[2291607,2291531,2291463],"length":1,"stats":{"Line":2}},{"line":214,"address":[1343737,1343804,1343615],"length":1,"stats":{"Line":2}},{"line":215,"address":[1343745,1343934,1343869],"length":1,"stats":{"Line":2}},{"line":216,"address":[1343878,1344002,1343980],"length":1,"stats":{"Line":2}},{"line":218,"address":[1341478],"length":1,"stats":{"Line":1}},{"line":220,"address":[1344074,1344116],"length":1,"stats":{"Line":2}},{"line":224,"address":[1344090,1344044],"length":1,"stats":{"Line":0}}],"covered":60,"coverable":79},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","context.rs"],"content":"//! C FFI for context - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, CONTEXTS};\nuse std::ffi::c_void;\n\n/// Internal context state\npub struct Context {\n    user_data: Option\u003cusize\u003e, // Store as usize to avoid raw pointers\n    error_code: i32,\n    error_message: String,\n}\n\nimpl Default for Context {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Context {\n    pub fn new() -\u003e Self {\n        Self {\n            user_data: None,\n            error_code: 0,\n            error_message: String::new(),\n        }\n    }\n\n    pub fn set_error(\u0026mut self, code: i32, message: \u0026str) {\n        self.error_code = code;\n        self.error_message = message.to_string();\n    }\n\n    pub fn clear_error(\u0026mut self) {\n        self.error_code = 0;\n        self.error_message.clear();\n    }\n}\n\n// Error codes matching MuPDF\npub const FZ_ERROR_NONE: i32 = 0;\npub const FZ_ERROR_MEMORY: i32 = 1;\npub const FZ_ERROR_GENERIC: i32 = 2;\npub const FZ_ERROR_SYNTAX: i32 = 3;\npub const FZ_ERROR_MINOR: i32 = 4;\npub const FZ_ERROR_TRYLATER: i32 = 5;\npub const FZ_ERROR_ABORT: i32 = 6;\npub const FZ_ERROR_SYSTEM: i32 = 7;\npub const FZ_ERROR_LIBRARY: i32 = 8;\npub const FZ_ERROR_FORMAT: i32 = 9;\npub const FZ_ERROR_LIMIT: i32 = 10;\npub const FZ_ERROR_UNSUPPORTED: i32 = 11;\npub const FZ_ERROR_ARGUMENT: i32 = 12;\n\n/// Create a new context\n/// Returns a handle (non-zero on success, 0 on failure)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_context(\n    _alloc: *const c_void,\n    _locks: *const c_void,\n    _max_store: usize,\n) -\u003e Handle {\n    CONTEXTS.insert(Context::new())\n}\n\n/// Clone a context (creates a new handle sharing state conceptually)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clone_context(ctx: Handle) -\u003e Handle {\n    if CONTEXTS.get(ctx).is_some() {\n        CONTEXTS.insert(Context::new())\n    } else {\n        0\n    }\n}\n\n/// Drop a context reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_context(ctx: Handle) {\n    let _ = CONTEXTS.remove(ctx);\n}\n\n/// Set user data on context\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_set_user_context(ctx: Handle, user: *mut c_void) {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(mut ctx) = context.lock() {\n            ctx.user_data = Some(user as usize);\n        }\n    }\n}\n\n/// Get user data from context\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_user_context(ctx: Handle) -\u003e *mut c_void {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(guard) = context.lock() {\n            if let Some(ud) = guard.user_data {\n                return ud as *mut c_void;\n            }\n        }\n    }\n    std::ptr::null_mut()\n}\n\n/// Get the error code from the last caught exception\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_caught(ctx: Handle) -\u003e i32 {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(guard) = context.lock() {\n            return guard.error_code;\n        }\n    }\n    0\n}\n\n/// Get the error message from the last caught exception\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_caught_message(_ctx: Handle) -\u003e *const std::ffi::c_char {\n    // Return a static string for now - proper implementation would\n    // need to maintain a stable pointer to the error message\n    c\"No error\".as_ptr()\n}\n\n/// Memory allocation through Rust's allocator\n/// Returns null pointer on failure\n///\n/// # Safety\n/// Memory allocation requires unsafe - this is unavoidable for C FFI.\n/// The allocated memory must be freed with fz_free.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_malloc(_ctx: Handle, size: usize) -\u003e *mut c_void {\n    if size == 0 {\n        return std::ptr::null_mut();\n    }\n\n    let layout = match std::alloc::Layout::from_size_align(size, 8) {\n        Ok(l) =\u003e l,\n        Err(_) =\u003e return std::ptr::null_mut(),\n    };\n\n    // SAFETY: Memory allocation is inherently unsafe but necessary for C FFI.\n    // We use the global allocator which is safe to use from any thread.\n    #[allow(unsafe_code)]\n    unsafe {\n        std::alloc::alloc(layout) as *mut c_void\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_free(_ctx: Handle, _ptr: *mut c_void) {\n    // Note: Proper deallocation would require tracking the size\n    // For a real implementation, consider using a slab allocator\n    // or tracking allocations in a HashMap\n}\n\n/// Duplicate a C string (allocates new memory)\n///\n/// # Safety\n/// This function interfaces with C code and requires minimal unsafe for:\n/// - Reading from C string pointer (CStr::from_ptr)\n/// - Writing to allocated memory\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_strdup(ctx: Handle, s: *const std::ffi::c_char) -\u003e *mut std::ffi::c_char {\n    if s.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    // SAFETY: Caller guarantees s is a valid null-terminated C string\n    let c_str = match std::panic::catch_unwind(|| {\n        // This is the minimal unsafe needed to read a C string\n        #[allow(unsafe_code)]\n        unsafe { std::ffi::CStr::from_ptr(s) }\n    }) {\n        Ok(c) =\u003e c,\n        Err(_) =\u003e return std::ptr::null_mut(),\n    };\n\n    let bytes = c_str.to_bytes_with_nul();\n    let len = bytes.len();\n\n    let ptr = fz_malloc(ctx, len);\n    if ptr.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    // SAFETY: We just allocated this memory and know its size\n    #[allow(unsafe_code)]\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr as *mut u8, len);\n    }\n\n    ptr as *mut std::ffi::c_char\n}\n\nimpl Drop for Context {\n    fn drop(\u0026mut self) {\n        // Clean up any resources\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_context_new() {\n        let ctx = Context::new();\n        assert_eq!(ctx.error_code, 0);\n        assert!(ctx.error_message.is_empty());\n        assert!(ctx.user_data.is_none());\n    }\n\n    #[test]\n    fn test_context_default() {\n        let ctx: Context = Default::default();\n        assert_eq!(ctx.error_code, 0);\n    }\n\n    #[test]\n    fn test_context_set_error() {\n        let mut ctx = Context::new();\n        ctx.set_error(FZ_ERROR_GENERIC, \"Test error\");\n        assert_eq!(ctx.error_code, FZ_ERROR_GENERIC);\n        assert_eq!(ctx.error_message, \"Test error\");\n    }\n\n    #[test]\n    fn test_context_clear_error() {\n        let mut ctx = Context::new();\n        ctx.set_error(FZ_ERROR_SYNTAX, \"Syntax error\");\n        ctx.clear_error();\n        assert_eq!(ctx.error_code, FZ_ERROR_NONE);\n        assert!(ctx.error_message.is_empty());\n    }\n\n    #[test]\n    fn test_fz_new_context() {\n        let handle = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        fz_drop_context(handle);\n    }\n\n    #[test]\n    fn test_fz_clone_context() {\n        let handle1 = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let handle2 = fz_clone_context(handle1);\n        assert_ne!(handle2, 0);\n        assert_ne!(handle1, handle2);\n        fz_drop_context(handle1);\n        fz_drop_context(handle2);\n    }\n\n    #[test]\n    fn test_fz_clone_invalid_context() {\n        let handle = fz_clone_context(0);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_user_context() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Initially null\n        let user = fz_user_context(ctx);\n        assert!(user.is_null());\n\n        // Set user data\n        let data: usize = 0x12345678;\n        fz_set_user_context(ctx, data as *mut c_void);\n\n        // Get it back\n        let user = fz_user_context(ctx);\n        assert_eq!(user as usize, data);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_caught() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Initially 0\n        assert_eq!(fz_caught(ctx), 0);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_caught_message() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let msg = fz_caught_message(ctx);\n        assert!(!msg.is_null());\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_malloc() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Zero size returns null\n        let ptr = fz_malloc(ctx, 0);\n        assert!(ptr.is_null());\n\n        // Normal allocation\n        let ptr = fz_malloc(ctx, 100);\n        assert!(!ptr.is_null());\n        fz_free(ctx, ptr);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_strdup() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Null input returns null\n        let result = fz_strdup(ctx, std::ptr::null());\n        assert!(result.is_null());\n\n        // Valid string\n        let s = c\"Hello, World!\";\n        let result = fz_strdup(ctx, s.as_ptr());\n        assert!(!result.is_null());\n        fz_free(ctx, result as *mut c_void);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_error_codes() {\n        assert_eq!(FZ_ERROR_NONE, 0);\n        assert_eq!(FZ_ERROR_MEMORY, 1);\n        assert_eq!(FZ_ERROR_GENERIC, 2);\n        assert_eq!(FZ_ERROR_SYNTAX, 3);\n        assert_eq!(FZ_ERROR_MINOR, 4);\n        assert_eq!(FZ_ERROR_TRYLATER, 5);\n        assert_eq!(FZ_ERROR_ABORT, 6);\n        assert_eq!(FZ_ERROR_SYSTEM, 7);\n        assert_eq!(FZ_ERROR_LIBRARY, 8);\n        assert_eq!(FZ_ERROR_FORMAT, 9);\n        assert_eq!(FZ_ERROR_LIMIT, 10);\n        assert_eq!(FZ_ERROR_UNSUPPORTED, 11);\n        assert_eq!(FZ_ERROR_ARGUMENT, 12);\n    }\n\n    #[test]\n    fn test_fz_user_context_invalid_handle() {\n        let user = fz_user_context(0);\n        assert!(user.is_null());\n    }\n\n    #[test]\n    fn test_fz_caught_invalid_handle() {\n        assert_eq!(fz_caught(0), 0);\n    }\n}\n","traces":[{"line":15,"address":[2283488],"length":1,"stats":{"Line":1}},{"line":16,"address":[2283496],"length":1,"stats":{"Line":1}},{"line":21,"address":[1566800],"length":1,"stats":{"Line":2}},{"line":25,"address":[1566822],"length":1,"stats":{"Line":2}},{"line":29,"address":[1566912,1567034],"length":1,"stats":{"Line":1}},{"line":30,"address":[1566965],"length":1,"stats":{"Line":1}},{"line":31,"address":[1566968,1567065,1567007],"length":1,"stats":{"Line":4}},{"line":34,"address":[1567104],"length":1,"stats":{"Line":1}},{"line":35,"address":[2283829],"length":1,"stats":{"Line":1}},{"line":36,"address":[1567116],"length":1,"stats":{"Line":1}},{"line":58,"address":[1567136,1567178,1567225],"length":1,"stats":{"Line":4}},{"line":63,"address":[1567155,1567184],"length":1,"stats":{"Line":6}},{"line":68,"address":[1567443,1567264,1567304,1567565],"length":1,"stats":{"Line":1}},{"line":69,"address":[1567281,1567320],"length":1,"stats":{"Line":2}},{"line":70,"address":[1567490],"length":1,"stats":{"Line":1}},{"line":72,"address":[1567468],"length":1,"stats":{"Line":1}},{"line":78,"address":[1567677,1567584,1567621],"length":1,"stats":{"Line":2}},{"line":79,"address":[1567598,1567637],"length":1,"stats":{"Line":7}},{"line":84,"address":[1567765,1568188,1567712,1568213],"length":1,"stats":{"Line":1}},{"line":85,"address":[1567742,1567781],"length":1,"stats":{"Line":2}},{"line":86,"address":[1567931,1567845,1567982],"length":1,"stats":{"Line":3}},{"line":87,"address":[1568000,1568076],"length":1,"stats":{"Line":2}},{"line":94,"address":[1568735,1568256,1568860,1568819,1568296],"length":1,"stats":{"Line":1}},{"line":95,"address":[1568273,1568312],"length":1,"stats":{"Line":2}},{"line":96,"address":[1568462,1568508,1568376],"length":1,"stats":{"Line":3}},{"line":97,"address":[1568526,1568590],"length":1,"stats":{"Line":2}},{"line":98,"address":[1568616],"length":1,"stats":{"Line":1}},{"line":102,"address":[1568871,1568844],"length":1,"stats":{"Line":2}},{"line":107,"address":[1569307,1569344,1568920,1568880],"length":1,"stats":{"Line":1}},{"line":108,"address":[1568936,1568897],"length":1,"stats":{"Line":2}},{"line":109,"address":[1569129,1569000,1569083],"length":1,"stats":{"Line":3}},{"line":110,"address":[1569147,1569208],"length":1,"stats":{"Line":2}},{"line":113,"address":[1569385],"length":1,"stats":{"Line":1}},{"line":118,"address":[1569408,1569441],"length":1,"stats":{"Line":1}},{"line":121,"address":[2285881],"length":1,"stats":{"Line":1}},{"line":131,"address":[1569540,1569472],"length":1,"stats":{"Line":1}},{"line":132,"address":[1569491],"length":1,"stats":{"Line":1}},{"line":133,"address":[1569497,1569551],"length":1,"stats":{"Line":2}},{"line":136,"address":[1569576,1569523],"length":1,"stats":{"Line":2}},{"line":137,"address":[1569627],"length":1,"stats":{"Line":1}},{"line":138,"address":[2286071,2286130],"length":1,"stats":{"Line":0}},{"line":145,"address":[1569647],"length":1,"stats":{"Line":1}},{"line":150,"address":[2286144],"length":1,"stats":{"Line":1}},{"line":163,"address":[1569757,1569910,1570261,1570267,1569712],"length":1,"stats":{"Line":1}},{"line":164,"address":[2286211,2286185],"length":1,"stats":{"Line":2}},{"line":165,"address":[1570278,1569797],"length":1,"stats":{"Line":2}},{"line":169,"address":[2026144],"length":1,"stats":{"Line":3}},{"line":172,"address":[2026149],"length":1,"stats":{"Line":1}},{"line":174,"address":[1569849],"length":1,"stats":{"Line":1}},{"line":175,"address":[1569830,1570234],"length":1,"stats":{"Line":0}},{"line":178,"address":[1569948],"length":1,"stats":{"Line":1}},{"line":179,"address":[2286440],"length":1,"stats":{"Line":1}},{"line":181,"address":[1570020],"length":1,"stats":{"Line":1}},{"line":182,"address":[1570048],"length":1,"stats":{"Line":1}},{"line":183,"address":[1570175,1570099],"length":1,"stats":{"Line":0}},{"line":189,"address":[1570130,1570083],"length":1,"stats":{"Line":2}},{"line":192,"address":[1570146],"length":1,"stats":{"Line":1}},{"line":196,"address":[1370800],"length":1,"stats":{"Line":2}}],"covered":55,"coverable":58},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","document.rs"],"content":"//! C FFI for document - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, DOCUMENTS, STREAMS};\nuse std::ffi::c_char;\n\n/// Internal document state\npub struct Document {\n    // PDF document data - will be expanded with actual PDF parsing\n    data: Vec\u003cu8\u003e,\n    page_count: i32,\n    needs_password: bool,\n    authenticated: bool,\n}\n\nimpl Document {\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self {\n        // Basic PDF detection and page count estimation\n        // In a real implementation, this would parse the PDF structure\n        let page_count = Self::estimate_page_count(\u0026data);\n\n        Self {\n            data,\n            page_count,\n            needs_password: false,\n            authenticated: true,\n        }\n    }\n\n    fn estimate_page_count(data: \u0026[u8]) -\u003e i32 {\n        // Simple heuristic: count /Type /Page occurrences\n        // Real implementation would parse the PDF properly\n        let mut count = 0;\n        let pattern = b\"/Type /Page\";\n\n        for window in data.windows(pattern.len()) {\n            if window == pattern {\n                count += 1;\n            }\n        }\n\n        count.max(1) // At least 1 page\n    }\n}\n\n/// Open a document from file\n///\n/// # Safety\n/// Caller must ensure `filename` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_document(_ctx: Handle, filename: *const c_char) -\u003e Handle {\n    if filename.is_null() {\n        return 0;\n    }\n\n    // SAFETY: Caller guarantees filename is a valid null-terminated C string\n    #[allow(unsafe_code)]\n    let c_str = unsafe { std::ffi::CStr::from_ptr(filename) };\n    let path = match c_str.to_str() {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return 0,\n    };\n\n    match std::fs::read(path) {\n        Ok(data) =\u003e DOCUMENTS.insert(Document::new(data)),\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Open a document from stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_document_with_stream(\n    _ctx: Handle,\n    _magic: *const c_char,\n    stm: Handle,\n) -\u003e Handle {\n    // Read all data from stream\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return DOCUMENTS.insert(Document::new(guard.data.clone()));\n        }\n    }\n    0\n}\n\n/// Keep (increment ref) document\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_document(_ctx: Handle, doc: Handle) -\u003e Handle {\n    DOCUMENTS.keep(doc)\n}\n\n/// Drop document reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_document(_ctx: Handle, doc: Handle) {\n    let _ = DOCUMENTS.remove(doc);\n}\n\n/// Check if document needs a password\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_needs_password(_ctx: Handle, doc: Handle) -\u003e i32 {\n    if let Some(d) = DOCUMENTS.get(doc) {\n        if let Ok(guard) = d.lock() {\n            return i32::from(guard.needs_password);\n        }\n    }\n    0\n}\n\n/// Authenticate with password\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_authenticate_password(\n    _ctx: Handle,\n    doc: Handle,\n    _password: *const c_char,\n) -\u003e i32 {\n    if let Some(document) = DOCUMENTS.get(doc) {\n        if let Ok(mut d) = document.lock() {\n            // For now, always succeed if no password needed\n            if !d.needs_password {\n                d.authenticated = true;\n                return 1;\n            }\n            // TODO: Implement actual password verification\n        }\n    }\n    0\n}\n\n/// Count pages in document\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_pages(_ctx: Handle, doc: Handle) -\u003e i32 {\n    if let Some(d) = DOCUMENTS.get(doc) {\n        if let Ok(guard) = d.lock() {\n            return guard.page_count;\n        }\n    }\n    0\n}\n\n/// Count chapters in document (PDF has 1 chapter)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_chapters(_ctx: Handle, _doc: Handle) -\u003e i32 {\n    1\n}\n\n/// Count pages in chapter\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_chapter_pages(_ctx: Handle, doc: Handle, _chapter: i32) -\u003e i32 {\n    fz_count_pages(_ctx, doc)\n}\n\n/// Get page number from location\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_page_number_from_location(\n    _ctx: Handle,\n    _doc: Handle,\n    chapter: i32,\n    page: i32,\n) -\u003e i32 {\n    if chapter == 0 {\n        page\n    } else {\n        -1\n    }\n}\n\n/// Check document permission\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_has_permission(_ctx: Handle, doc: Handle, _permission: i32) -\u003e i32 {\n    // For now, allow all permissions if document is open\n    if DOCUMENTS.get(doc).is_some() {\n        1\n    } else {\n        0\n    }\n}\n\n// Permission flags\npub const FZ_PERMISSION_PRINT: i32 = 1 \u003c\u003c 0;\npub const FZ_PERMISSION_COPY: i32 = 1 \u003c\u003c 1;\npub const FZ_PERMISSION_EDIT: i32 = 1 \u003c\u003c 2;\npub const FZ_PERMISSION_ANNOTATE: i32 = 1 \u003c\u003c 3;\n\n/// Lookup metadata\n///\n/// # Safety\n/// Caller must ensure `buf` points to writable memory of at least `size` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_lookup_metadata(\n    _ctx: Handle,\n    _doc: Handle,\n    _key: *const c_char,\n    buf: *mut c_char,\n    size: i32,\n) -\u003e i32 {\n    // Return empty string for now\n    if !buf.is_null() \u0026\u0026 size \u003e 0 {\n        // SAFETY: Caller guarantees buf points to writable memory of `size` bytes\n        #[allow(unsafe_code)]\n        unsafe {\n            *buf = 0; // Null terminate\n        }\n    }\n    -1 // Key not found\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use super::super::STREAMS;\n    use super::super::stream::Stream;\n\n    #[test]\n    fn test_document_handle() {\n        // Create a minimal \"PDF\" for testing\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n\n        let handle = DOCUMENTS.insert(doc);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_count_chapters(0, handle), 1);\n        assert!(fz_count_pages(0, handle) \u003e= 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_document_new() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        assert_eq!(doc.page_count, 2);\n        assert!(!doc.needs_password);\n        assert!(doc.authenticated);\n    }\n\n    #[test]\n    fn test_document_estimate_page_count() {\n        // No pages\n        let empty = b\"%PDF-1.4\\n%%EOF\";\n        let doc1 = Document::new(empty.to_vec());\n        assert_eq!(doc1.page_count, 1); // Minimum 1\n\n        // Multiple pages\n        let multi = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc2 = Document::new(multi.to_vec());\n        assert_eq!(doc2.page_count, 3);\n    }\n\n    #[test]\n    fn test_keep_document() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        let kept = fz_keep_document(0, handle);\n        assert_eq!(kept, handle);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_needs_password() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_needs_password(0, handle), 0);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_needs_password_invalid_handle() {\n        assert_eq!(fz_needs_password(0, 0), 0);\n    }\n\n    #[test]\n    fn test_authenticate_password() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        // No password needed, should succeed\n        let result = fz_authenticate_password(0, handle, c\"\".as_ptr());\n        assert_eq!(result, 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_authenticate_password_invalid_handle() {\n        let result = fz_authenticate_password(0, 0, c\"\".as_ptr());\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_count_pages() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_count_pages(0, handle), 2);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_count_pages_invalid_handle() {\n        assert_eq!(fz_count_pages(0, 0), 0);\n    }\n\n    #[test]\n    fn test_count_chapters() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        // PDFs always have 1 chapter\n        assert_eq!(fz_count_chapters(0, handle), 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_count_chapter_pages() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_count_chapter_pages(0, handle, 0), 2);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_page_number_from_location() {\n        assert_eq!(fz_page_number_from_location(0, 0, 0, 5), 5);\n        assert_eq!(fz_page_number_from_location(0, 0, 0, 0), 0);\n        assert_eq!(fz_page_number_from_location(0, 0, 1, 5), -1); // Invalid chapter\n    }\n\n    #[test]\n    fn test_has_permission() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_PRINT), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_COPY), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_EDIT), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_ANNOTATE), 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_has_permission_invalid_handle() {\n        assert_eq!(fz_has_permission(0, 0, FZ_PERMISSION_PRINT), 0);\n    }\n\n    #[test]\n    fn test_lookup_metadata() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        let mut buf = [0i8; 100];\n        let result = fz_lookup_metadata(0, handle, c\"Title\".as_ptr(), buf.as_mut_ptr(), 100);\n        assert_eq!(result, -1); // Not found\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_lookup_metadata_null_buffer() {\n        let result = fz_lookup_metadata(0, 0, c\"Title\".as_ptr(), std::ptr::null_mut(), 0);\n        assert_eq!(result, -1);\n    }\n\n    #[test]\n    fn test_open_document_null_filename() {\n        let handle = fz_open_document(0, std::ptr::null());\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_open_document_with_stream() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let stream = Stream::from_memory(pdf_data.to_vec());\n        let stream_handle = STREAMS.insert(stream);\n\n        let doc_handle = fz_open_document_with_stream(0, std::ptr::null(), stream_handle);\n        assert_ne!(doc_handle, 0);\n\n        assert_eq!(fz_count_pages(0, doc_handle), 1);\n\n        fz_drop_document(0, doc_handle);\n        super::super::STREAMS.remove(stream_handle);\n    }\n\n    #[test]\n    fn test_open_document_with_invalid_stream() {\n        let doc_handle = fz_open_document_with_stream(0, std::ptr::null(), 0);\n        assert_eq!(doc_handle, 0);\n    }\n\n    #[test]\n    fn test_permission_constants() {\n        assert_eq!(FZ_PERMISSION_PRINT, 1);\n        assert_eq!(FZ_PERMISSION_COPY, 2);\n        assert_eq!(FZ_PERMISSION_EDIT, 4);\n        assert_eq!(FZ_PERMISSION_ANNOTATE, 8);\n    }\n}\n\n","traces":[{"line":17,"address":[2032051,2031856],"length":1,"stats":{"Line":11}},{"line":20,"address":[2031883,2031949],"length":1,"stats":{"Line":22}},{"line":30,"address":[1562736],"length":1,"stats":{"Line":11}},{"line":33,"address":[1562762],"length":1,"stats":{"Line":1}},{"line":34,"address":[1562770],"length":1,"stats":{"Line":11}},{"line":36,"address":[1562782,1562851],"length":1,"stats":{"Line":22}},{"line":37,"address":[1562986,1562920],"length":1,"stats":{"Line":22}},{"line":38,"address":[1562965,1562991],"length":1,"stats":{"Line":10}},{"line":42,"address":[2032283],"length":1,"stats":{"Line":1}},{"line":51,"address":[1563577,1563008,1563072,1563571],"length":1,"stats":{"Line":1}},{"line":52,"address":[1563082,1563049],"length":1,"stats":{"Line":2}},{"line":53,"address":[1563110],"length":1,"stats":{"Line":1}},{"line":58,"address":[1563134,1563093],"length":1,"stats":{"Line":0}},{"line":59,"address":[1563150],"length":1,"stats":{"Line":0}},{"line":60,"address":[1563191],"length":1,"stats":{"Line":0}},{"line":61,"address":[1563177],"length":1,"stats":{"Line":0}},{"line":64,"address":[1563217],"length":1,"stats":{"Line":0}},{"line":65,"address":[1563281,1563335,1563555],"length":1,"stats":{"Line":0}},{"line":66,"address":[1563267],"length":1,"stats":{"Line":0}},{"line":72,"address":[1563723,1563664,1564263,1564222],"length":1,"stats":{"Line":1}},{"line":78,"address":[1563739,1563700],"length":1,"stats":{"Line":2}},{"line":79,"address":[1563889,1563935,1563803],"length":1,"stats":{"Line":3}},{"line":80,"address":[1563953,1564017],"length":1,"stats":{"Line":2}},{"line":83,"address":[1564304],"length":1,"stats":{"Line":1}},{"line":88,"address":[1564362,1564320],"length":1,"stats":{"Line":1}},{"line":89,"address":[1564339,1564378],"length":1,"stats":{"Line":2}},{"line":94,"address":[1564458,1564516,1564416],"length":1,"stats":{"Line":1}},{"line":95,"address":[1564435,1564474],"length":1,"stats":{"Line":6}},{"line":100,"address":[1564544,1564592,1565004,1565044],"length":1,"stats":{"Line":1}},{"line":101,"address":[1564569,1564608],"length":1,"stats":{"Line":2}},{"line":102,"address":[1564672,1564804,1564758],"length":1,"stats":{"Line":3}},{"line":103,"address":[1564886,1564822],"length":1,"stats":{"Line":2}},{"line":106,"address":[1565085],"length":1,"stats":{"Line":1}},{"line":111,"address":[1565104,1565610,1565157,1565693],"length":1,"stats":{"Line":1}},{"line":116,"address":[2034302,2034337],"length":1,"stats":{"Line":2}},{"line":117,"address":[1565369,1565237,1565323],"length":1,"stats":{"Line":3}},{"line":119,"address":[1565451,1565387],"length":1,"stats":{"Line":2}},{"line":120,"address":[1565500,1565457],"length":1,"stats":{"Line":2}},{"line":121,"address":[1565504],"length":1,"stats":{"Line":1}},{"line":126,"address":[1565718],"length":1,"stats":{"Line":1}},{"line":131,"address":[2034832,2034873,2035251,2035214],"length":1,"stats":{"Line":1}},{"line":132,"address":[1565789,1565750],"length":1,"stats":{"Line":2}},{"line":133,"address":[2035025,2035058,2034954],"length":1,"stats":{"Line":9}},{"line":134,"address":[1566059,1566000],"length":1,"stats":{"Line":8}},{"line":137,"address":[2035284],"length":1,"stats":{"Line":1}},{"line":142,"address":[1566256],"length":1,"stats":{"Line":2}},{"line":148,"address":[2035312],"length":1,"stats":{"Line":1}},{"line":149,"address":[1566289],"length":1,"stats":{"Line":1}},{"line":154,"address":[2035344],"length":1,"stats":{"Line":1}},{"line":160,"address":[1566339,1566326],"length":1,"stats":{"Line":2}},{"line":161,"address":[1566335],"length":1,"stats":{"Line":1}},{"line":163,"address":[1566341],"length":1,"stats":{"Line":1}},{"line":169,"address":[2035450,2035615,2035566,2035408],"length":1,"stats":{"Line":1}},{"line":171,"address":[1566597,1566391,1566430],"length":1,"stats":{"Line":3}},{"line":172,"address":[1566589],"length":1,"stats":{"Line":1}},{"line":174,"address":[1566572],"length":1,"stats":{"Line":1}},{"line":189,"address":[1566608,1566675],"length":1,"stats":{"Line":1}},{"line":197,"address":[1566740,1566685,1566660],"length":1,"stats":{"Line":3}},{"line":201,"address":[1566715,1566742],"length":1,"stats":{"Line":1}}],"covered":52,"coverable":59},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","geometry.rs"],"content":"//! C FFI for geometry types - MuPDF compatible\n//!\n//! # Safety Note\n//! This module provides C FFI exports which require `unsafe` annotations\n//! in Rust 2024 edition. The internal implementation is 100% safe Rust.\n//! The `#[unsafe(no_mangle)]` attribute is required for C symbol visibility.\n\nuse std::ffi::c_float;\n\n/// fz_point - 2D point\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_point {\n    pub x: c_float,\n    pub y: c_float,\n}\n\n/// fz_rect - Rectangle\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_rect {\n    pub x0: c_float,\n    pub y0: c_float,\n    pub x1: c_float,\n    pub y1: c_float,\n}\n\n/// fz_irect - Integer rectangle\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub struct fz_irect {\n    pub x0: i32,\n    pub y0: i32,\n    pub x1: i32,\n    pub y1: i32,\n}\n\n/// fz_matrix - Transformation matrix\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct fz_matrix {\n    pub a: c_float,\n    pub b: c_float,\n    pub c: c_float,\n    pub d: c_float,\n    pub e: c_float,\n    pub f: c_float,\n}\n\nimpl Default for fz_matrix {\n    fn default() -\u003e Self {\n        Self::identity()\n    }\n}\n\nimpl fz_matrix {\n    pub const fn identity() -\u003e Self {\n        Self { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 }\n    }\n}\n\n/// fz_quad - Quadrilateral\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_quad {\n    pub ul: fz_point,\n    pub ur: fz_point,\n    pub ll: fz_point,\n    pub lr: fz_point,\n}\n\n// Constants\npub const FZ_MIN_INF_RECT: i32 = i32::MIN;\npub const FZ_MAX_INF_RECT: i32 = 0x7fffff80;\n\n// Static constants exposed to C\n// SAFETY: These are constant data with no mutable access, safe for FFI export\n#[unsafe(no_mangle)]\npub static fz_identity: fz_matrix = fz_matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 };\n\n#[unsafe(no_mangle)]\npub static fz_empty_rect: fz_rect = fz_rect {\n    x0: f32::INFINITY, y0: f32::INFINITY,\n    x1: f32::NEG_INFINITY, y1: f32::NEG_INFINITY,\n};\n\n#[unsafe(no_mangle)]\npub static fz_infinite_rect: fz_rect = fz_rect {\n    x0: FZ_MIN_INF_RECT as f32, y0: FZ_MIN_INF_RECT as f32,\n    x1: FZ_MAX_INF_RECT as f32, y1: FZ_MAX_INF_RECT as f32,\n};\n\n#[unsafe(no_mangle)]\npub static fz_unit_rect: fz_rect = fz_rect { x0: 0.0, y0: 0.0, x1: 1.0, y1: 1.0 };\n\n#[unsafe(no_mangle)]\npub static fz_empty_irect: fz_irect = fz_irect { x0: 0, y0: 0, x1: 0, y1: 0 };\n\n#[unsafe(no_mangle)]\npub static fz_infinite_irect: fz_irect = fz_irect {\n    x0: FZ_MIN_INF_RECT, y0: FZ_MIN_INF_RECT,\n    x1: FZ_MAX_INF_RECT, y1: FZ_MAX_INF_RECT,\n};\n\n// ============================================================================\n// Matrix functions - Pure safe Rust implementations with FFI export\n// ============================================================================\n\n/// Concatenate two matrices\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_concat(left: fz_matrix, right: fz_matrix) -\u003e fz_matrix {\n    fz_matrix {\n        a: left.a * right.a + left.b * right.c,\n        b: left.a * right.b + left.b * right.d,\n        c: left.c * right.a + left.d * right.c,\n        d: left.c * right.b + left.d * right.d,\n        e: left.e * right.a + left.f * right.c + right.e,\n        f: left.e * right.b + left.f * right.d + right.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_scale(sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_matrix { a: sx, b: 0.0, c: 0.0, d: sy, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_scale(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(fz_scale(sx, sy), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_post_scale(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(m, fz_scale(sx, sy))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_shear(sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_matrix { a: 1.0, b: sy, c: sx, d: 1.0, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_shear(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(fz_shear(sx, sy), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rotate(degrees: c_float) -\u003e fz_matrix {\n    let rad = degrees * std::f32::consts::PI / 180.0;\n    let (s, c) = rad.sin_cos();\n    fz_matrix { a: c, b: s, c: -s, d: c, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_rotate(m: fz_matrix, degrees: c_float) -\u003e fz_matrix {\n    fz_concat(fz_rotate(degrees), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate(tx: c_float, ty: c_float) -\u003e fz_matrix {\n    fz_matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: tx, f: ty }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_translate(m: fz_matrix, tx: c_float, ty: c_float) -\u003e fz_matrix {\n    fz_concat(fz_translate(tx, ty), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_invert_matrix(m: fz_matrix) -\u003e fz_matrix {\n    let det = m.a * m.d - m.b * m.c;\n    if det.abs() \u003c 1e-6 {\n        return m; // Singular matrix, return original\n    }\n    let rdet = 1.0 / det;\n    fz_matrix {\n        a: m.d * rdet,\n        b: -m.b * rdet,\n        c: -m.c * rdet,\n        d: m.a * rdet,\n        e: (m.c * m.f - m.d * m.e) * rdet,\n        f: (m.b * m.e - m.a * m.f) * rdet,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_matrix_expansion(m: fz_matrix) -\u003e c_float {\n    (m.a.abs() * m.d.abs() - m.b.abs() * m.c.abs()).abs().sqrt()\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_matrix_max_expansion(m: fz_matrix) -\u003e c_float {\n    m.a.abs().max(m.b.abs()).max(m.c.abs()).max(m.d.abs())\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_rectilinear(m: fz_matrix) -\u003e i32 {\n    if (m.b.abs() \u003c 1e-6 \u0026\u0026 m.c.abs() \u003c 1e-6) || (m.a.abs() \u003c 1e-6 \u0026\u0026 m.d.abs() \u003c 1e-6) {\n        1\n    } else {\n        0\n    }\n}\n\n// ============================================================================\n// Rect functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_intersect_rect(a: fz_rect, b: fz_rect) -\u003e fz_rect {\n    fz_rect {\n        x0: a.x0.max(b.x0),\n        y0: a.y0.max(b.y0),\n        x1: a.x1.min(b.x1),\n        y1: a.y1.min(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_intersect_irect(a: fz_irect, b: fz_irect) -\u003e fz_irect {\n    fz_irect {\n        x0: a.x0.max(b.x0),\n        y0: a.y0.max(b.y0),\n        x1: a.x1.min(b.x1),\n        y1: a.y1.min(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_union_rect(a: fz_rect, b: fz_rect) -\u003e fz_rect {\n    fz_rect {\n        x0: a.x0.min(b.x0),\n        y0: a.y0.min(b.y0),\n        x1: a.x1.max(b.x1),\n        y1: a.y1.max(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_irect_from_rect(rect: fz_rect) -\u003e fz_irect {\n    fz_irect {\n        x0: rect.x0.floor() as i32,\n        y0: rect.y0.floor() as i32,\n        x1: rect.x1.ceil() as i32,\n        y1: rect.y1.ceil() as i32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_round_rect(rect: fz_rect) -\u003e fz_irect {\n    fz_irect {\n        x0: (rect.x0 + 0.001).floor() as i32,\n        y0: (rect.y0 + 0.001).floor() as i32,\n        x1: (rect.x1 - 0.001).ceil() as i32,\n        y1: (rect.y1 - 0.001).ceil() as i32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rect_from_irect(bbox: fz_irect) -\u003e fz_rect {\n    fz_rect {\n        x0: bbox.x0 as f32,\n        y0: bbox.y0 as f32,\n        x1: bbox.x1 as f32,\n        y1: bbox.y1 as f32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_expand_rect(r: fz_rect, expand: c_float) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0 - expand,\n        y0: r.y0 - expand,\n        x1: r.x1 + expand,\n        y1: r.y1 + expand,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_expand_irect(r: fz_irect, expand: i32) -\u003e fz_irect {\n    fz_irect {\n        x0: r.x0.saturating_sub(expand),\n        y0: r.y0.saturating_sub(expand),\n        x1: r.x1.saturating_add(expand),\n        y1: r.y1.saturating_add(expand),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_include_point_in_rect(r: fz_rect, p: fz_point) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0.min(p.x),\n        y0: r.y0.min(p.y),\n        x1: r.x1.max(p.x),\n        y1: r.y1.max(p.y),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate_rect(r: fz_rect, xoff: c_float, yoff: c_float) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0 + xoff,\n        y0: r.y0 + yoff,\n        x1: r.x1 + xoff,\n        y1: r.y1 + yoff,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate_irect(r: fz_irect, xoff: i32, yoff: i32) -\u003e fz_irect {\n    fz_irect {\n        x0: r.x0.saturating_add(xoff),\n        y0: r.y0.saturating_add(yoff),\n        x1: r.x1.saturating_add(xoff),\n        y1: r.y1.saturating_add(yoff),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_contains_rect(a: fz_rect, b: fz_rect) -\u003e i32 {\n    i32::from(a.x0 \u003c= b.x0 \u0026\u0026 a.y0 \u003c= b.y0 \u0026\u0026 a.x1 \u003e= b.x1 \u0026\u0026 a.y1 \u003e= b.y1)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_overlaps_rect(a: fz_rect, b: fz_rect) -\u003e i32 {\n    i32::from(a.x0 \u003c b.x1 \u0026\u0026 b.x0 \u003c a.x1 \u0026\u0026 a.y0 \u003c b.y1 \u0026\u0026 b.y0 \u003c a.y1)\n}\n\n// ============================================================================\n// Point/Transform functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_point(p: fz_point, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: p.x * m.a + p.y * m.c + m.e,\n        y: p.x * m.b + p.y * m.d + m.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_point_xy(x: c_float, y: c_float, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: x * m.a + y * m.c + m.e,\n        y: x * m.b + y * m.d + m.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_vector(v: fz_point, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: v.x * m.a + v.y * m.c,\n        y: v.x * m.b + v.y * m.d,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_rect(r: fz_rect, m: fz_matrix) -\u003e fz_rect {\n    if fz_is_rectilinear(m) != 0 {\n        let p1 = fz_transform_point(fz_point { x: r.x0, y: r.y0 }, m);\n        let p2 = fz_transform_point(fz_point { x: r.x1, y: r.y1 }, m);\n        fz_rect {\n            x0: p1.x.min(p2.x),\n            y0: p1.y.min(p2.y),\n            x1: p1.x.max(p2.x),\n            y1: p1.y.max(p2.y),\n        }\n    } else {\n        let p1 = fz_transform_point(fz_point { x: r.x0, y: r.y0 }, m);\n        let p2 = fz_transform_point(fz_point { x: r.x1, y: r.y0 }, m);\n        let p3 = fz_transform_point(fz_point { x: r.x0, y: r.y1 }, m);\n        let p4 = fz_transform_point(fz_point { x: r.x1, y: r.y1 }, m);\n        fz_rect {\n            x0: p1.x.min(p2.x).min(p3.x).min(p4.x),\n            y0: p1.y.min(p2.y).min(p3.y).min(p4.y),\n            x1: p1.x.max(p2.x).max(p3.x).max(p4.x),\n            y1: p1.y.max(p2.y).max(p3.y).max(p4.y),\n        }\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_normalize_vector(p: fz_point) -\u003e fz_point {\n    let len = (p.x * p.x + p.y * p.y).sqrt();\n    if len \u003c 1e-6 {\n        return fz_point { x: 0.0, y: 0.0 };\n    }\n    fz_point { x: p.x / len, y: p.y / len }\n}\n\n// ============================================================================\n// Quad functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_quad_from_rect(r: fz_rect) -\u003e fz_quad {\n    fz_quad {\n        ul: fz_point { x: r.x0, y: r.y0 },\n        ur: fz_point { x: r.x1, y: r.y0 },\n        ll: fz_point { x: r.x0, y: r.y1 },\n        lr: fz_point { x: r.x1, y: r.y1 },\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rect_from_quad(q: fz_quad) -\u003e fz_rect {\n    fz_rect {\n        x0: q.ul.x.min(q.ur.x).min(q.ll.x).min(q.lr.x),\n        y0: q.ul.y.min(q.ur.y).min(q.ll.y).min(q.lr.y),\n        x1: q.ul.x.max(q.ur.x).max(q.ll.x).max(q.lr.x),\n        y1: q.ul.y.max(q.ur.y).max(q.ll.y).max(q.lr.y),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_quad(q: fz_quad, m: fz_matrix) -\u003e fz_quad {\n    fz_quad {\n        ul: fz_transform_point(q.ul, m),\n        ur: fz_transform_point(q.ur, m),\n        ll: fz_transform_point(q.ll, m),\n        lr: fz_transform_point(q.lr, m),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_point_inside_rect(p: fz_point, r: fz_rect) -\u003e i32 {\n    i32::from(p.x \u003e= r.x0 \u0026\u0026 p.x \u003c r.x1 \u0026\u0026 p.y \u003e= r.y0 \u0026\u0026 p.y \u003c r.y1)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_point_inside_irect(x: i32, y: i32, r: fz_irect) -\u003e i32 {\n    i32::from(x \u003e= r.x0 \u0026\u0026 x \u003c r.x1 \u0026\u0026 y \u003e= r.y0 \u0026\u0026 y \u003c r.y1)\n}\n\n// ============================================================================\n// Version\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_version() -\u003e *const std::ffi::c_char {\n    c\"0.1.0\".as_ptr()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Struct tests\n    #[test]\n    fn test_point_struct() {\n        let p = fz_point { x: 3.5, y: 4.5 };\n        assert_eq!(p.x, 3.5);\n        assert_eq!(p.y, 4.5);\n    }\n\n    #[test]\n    fn test_rect_struct() {\n        let r = fz_rect { x0: 1.0, y0: 2.0, x1: 10.0, y1: 20.0 };\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_irect_struct() {\n        let r = fz_irect { x0: 1, y0: 2, x1: 10, y1: 20 };\n        assert_eq!(r.x0, 1);\n        assert_eq!(r.y0, 2);\n        assert_eq!(r.x1, 10);\n        assert_eq!(r.y1, 20);\n    }\n\n    #[test]\n    fn test_irect_from_rect() {\n        let r = fz_rect { x0: 0.5, y0: 1.5, x1: 9.5, y1: 19.5 };\n        let ir = fz_irect_from_rect(r);\n        assert_eq!(ir.x0, 0);\n        assert_eq!(ir.y0, 1);\n        assert_eq!(ir.x1, 10);\n        assert_eq!(ir.y1, 20);\n    }\n\n    #[test]\n    fn test_round_rect() {\n        let r = fz_rect { x0: 0.2, y0: 1.8, x1: 9.3, y1: 19.7 };\n        let ir = fz_round_rect(r);\n        // round_rect should round correctly\n        assert!(ir.x0 \u003e= 0);\n        assert!(ir.x1 \u003e= 9);\n    }\n\n    #[test]\n    fn test_rect_from_irect() {\n        let ir = fz_irect { x0: 1, y0: 2, x1: 10, y1: 20 };\n        let r = fz_rect_from_irect(ir);\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    // Matrix tests\n    #[test]\n    fn test_matrix_identity() {\n        let m = fz_matrix::identity();\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.b, 0.0);\n        assert_eq!(m.c, 0.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_matrix_struct() {\n        let m = fz_matrix { a: 1.0, b: 2.0, c: 3.0, d: 4.0, e: 5.0, f: 6.0 };\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 2.0);\n        assert_eq!(m.c, 3.0);\n        assert_eq!(m.d, 4.0);\n        assert_eq!(m.e, 5.0);\n        assert_eq!(m.f, 6.0);\n    }\n\n    #[test]\n    fn test_translate() {\n        let m = fz_translate(10.0, 20.0);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.e, 10.0);\n        assert_eq!(m.f, 20.0);\n    }\n\n    #[test]\n    fn test_scale() {\n        let m = fz_scale(2.0, 3.0);\n        assert_eq!(m.a, 2.0);\n        assert_eq!(m.d, 3.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_rotate() {\n        let m = fz_rotate(90.0);\n        assert!((m.a - 0.0).abs() \u003c 0.001);\n        assert!((m.b - 1.0).abs() \u003c 0.001);\n        assert!((m.c - (-1.0)).abs() \u003c 0.001);\n        assert!((m.d - 0.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_shear() {\n        let m = fz_shear(0.5, 0.5);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 0.5);\n        assert_eq!(m.c, 0.5);\n        assert_eq!(m.d, 1.0);\n    }\n\n    #[test]\n    fn test_pre_translate() {\n        let m = fz_scale(2.0, 2.0);\n        let result = fz_pre_translate(m, 10.0, 10.0);\n        // Pre-translate: scale first, then translate\n        assert_eq!(result.e, 20.0);\n        assert_eq!(result.f, 20.0);\n    }\n\n    #[test]\n    fn test_pre_scale() {\n        let m = fz_translate(10.0, 10.0);\n        let result = fz_pre_scale(m, 2.0, 2.0);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 2.0);\n    }\n\n    #[test]\n    fn test_post_scale() {\n        let m = fz_translate(10.0, 10.0);\n        let result = fz_post_scale(m, 2.0, 2.0);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 2.0);\n    }\n\n    #[test]\n    fn test_pre_rotate() {\n        let m = fz_matrix::identity();\n        let result = fz_pre_rotate(m, 90.0);\n        assert!((result.b - 1.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_pre_shear() {\n        let m = fz_matrix::identity();\n        let result = fz_pre_shear(m, 0.5, 0.5);\n        assert_eq!(result.b, 0.5);\n        assert_eq!(result.c, 0.5);\n    }\n\n    #[test]\n    fn test_matrix_concat() {\n        let m1 = fz_translate(10.0, 20.0);\n        let m2 = fz_scale(2.0, 2.0);\n        let m3 = fz_concat(m1, m2);\n\n        let p = fz_point { x: 0.0, y: 0.0 };\n        let result = fz_transform_point(p, m3);\n        assert_eq!(result.x, 20.0);\n        assert_eq!(result.y, 40.0);\n    }\n\n    #[test]\n    fn test_invert_matrix() {\n        let m = fz_scale(2.0, 2.0);\n        let inv = fz_invert_matrix(m);\n        // Inverse of scale(2,2) should be scale(0.5, 0.5)\n        assert!((inv.a - 0.5).abs() \u003c 0.001);\n        assert!((inv.d - 0.5).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_matrix_expansion() {\n        let m = fz_scale(2.0, 3.0);\n        let exp = fz_matrix_expansion(m);\n        // Geometric mean of scale factors\n        assert!(exp \u003e 2.0);\n        assert!(exp \u003c 3.0);\n    }\n\n    #[test]\n    fn test_matrix_max_expansion() {\n        let m = fz_scale(2.0, 3.0);\n        let max_exp = fz_matrix_max_expansion(m);\n        assert_eq!(max_exp, 3.0);\n    }\n\n    #[test]\n    fn test_is_rectilinear() {\n        let identity = fz_matrix::identity();\n        let rotated = fz_rotate(45.0);\n        assert_eq!(fz_is_rectilinear(identity), 1);\n        assert_eq!(fz_is_rectilinear(rotated), 0);\n    }\n\n    // Transform tests\n    #[test]\n    fn test_transform_point() {\n        let m = fz_translate(10.0, 20.0);\n        let p = fz_point { x: 5.0, y: 5.0 };\n        let result = fz_transform_point(p, m);\n        assert_eq!(result.x, 15.0);\n        assert_eq!(result.y, 25.0);\n    }\n\n    #[test]\n    fn test_transform_point_xy() {\n        let m = fz_translate(10.0, 20.0);\n        let result = fz_transform_point_xy(5.0, 5.0, m);\n        assert_eq!(result.x, 15.0);\n        assert_eq!(result.y, 25.0);\n    }\n\n    #[test]\n    fn test_transform_vector() {\n        let m = fz_translate(10.0, 20.0);\n        let v = fz_point { x: 5.0, y: 5.0 };\n        // Vector transform ignores translation\n        let result = fz_transform_vector(v, m);\n        assert_eq!(result.x, 5.0);\n        assert_eq!(result.y, 5.0);\n    }\n\n    #[test]\n    fn test_transform_rect() {\n        let m = fz_scale(2.0, 2.0);\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let result = fz_transform_rect(r, m);\n        assert_eq!(result.x0, 0.0);\n        assert_eq!(result.y0, 0.0);\n        assert_eq!(result.x1, 20.0);\n        assert_eq!(result.y1, 20.0);\n    }\n\n    #[test]\n    fn test_normalize_vector() {\n        let p = fz_point { x: 3.0, y: 4.0 };\n        let result = fz_normalize_vector(p);\n        // Length should be 1\n        let len = (result.x * result.x + result.y * result.y).sqrt();\n        assert!((len - 1.0).abs() \u003c 0.001);\n    }\n\n    // Rect operations tests\n    #[test]\n    fn test_rect_operations() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let r2 = fz_rect { x0: 50.0, y0: 50.0, x1: 150.0, y1: 150.0 };\n\n        let intersection = fz_intersect_rect(r1, r2);\n        assert_eq!(intersection.x0, 50.0);\n        assert_eq!(intersection.y0, 50.0);\n        assert_eq!(intersection.x1, 100.0);\n        assert_eq!(intersection.y1, 100.0);\n\n        let union = fz_union_rect(r1, r2);\n        assert_eq!(union.x0, 0.0);\n        assert_eq!(union.y0, 0.0);\n        assert_eq!(union.x1, 150.0);\n        assert_eq!(union.y1, 150.0);\n    }\n\n    #[test]\n    fn test_intersect_irect() {\n        let r1 = fz_irect { x0: 0, y0: 0, x1: 100, y1: 100 };\n        let r2 = fz_irect { x0: 50, y0: 50, x1: 150, y1: 150 };\n        let result = fz_intersect_irect(r1, r2);\n        assert_eq!(result.x0, 50);\n        assert_eq!(result.y0, 50);\n        assert_eq!(result.x1, 100);\n        assert_eq!(result.y1, 100);\n    }\n\n    #[test]\n    fn test_expand_rect() {\n        let r = fz_rect { x0: 10.0, y0: 10.0, x1: 20.0, y1: 20.0 };\n        let expanded = fz_expand_rect(r, 5.0);\n        assert_eq!(expanded.x0, 5.0);\n        assert_eq!(expanded.y0, 5.0);\n        assert_eq!(expanded.x1, 25.0);\n        assert_eq!(expanded.y1, 25.0);\n    }\n\n    #[test]\n    fn test_expand_irect() {\n        let r = fz_irect { x0: 10, y0: 10, x1: 20, y1: 20 };\n        let expanded = fz_expand_irect(r, 5);\n        assert_eq!(expanded.x0, 5);\n        assert_eq!(expanded.y0, 5);\n        assert_eq!(expanded.x1, 25);\n        assert_eq!(expanded.y1, 25);\n    }\n\n    #[test]\n    fn test_include_point_in_rect() {\n        let r = fz_rect { x0: 10.0, y0: 10.0, x1: 20.0, y1: 20.0 };\n        let p = fz_point { x: 0.0, y: 30.0 };\n        let result = fz_include_point_in_rect(r, p);\n        assert_eq!(result.x0, 0.0);\n        assert_eq!(result.y0, 10.0);\n        assert_eq!(result.x1, 20.0);\n        assert_eq!(result.y1, 30.0);\n    }\n\n    #[test]\n    fn test_translate_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let result = fz_translate_rect(r, 5.0, 5.0);\n        assert_eq!(result.x0, 5.0);\n        assert_eq!(result.y0, 5.0);\n        assert_eq!(result.x1, 15.0);\n        assert_eq!(result.y1, 15.0);\n    }\n\n    #[test]\n    fn test_translate_irect() {\n        let r = fz_irect { x0: 0, y0: 0, x1: 10, y1: 10 };\n        let result = fz_translate_irect(r, 5, 5);\n        assert_eq!(result.x0, 5);\n        assert_eq!(result.y0, 5);\n        assert_eq!(result.x1, 15);\n        assert_eq!(result.y1, 15);\n    }\n\n    #[test]\n    fn test_contains_rect() {\n        let outer = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let inner = fz_rect { x0: 10.0, y0: 10.0, x1: 50.0, y1: 50.0 };\n        let outside = fz_rect { x0: 200.0, y0: 200.0, x1: 300.0, y1: 300.0 };\n\n        assert_eq!(fz_contains_rect(outer, inner), 1);\n        assert_eq!(fz_contains_rect(outer, outside), 0);\n    }\n\n    #[test]\n    fn test_overlaps_rect() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 50.0, y1: 50.0 };\n        let r2 = fz_rect { x0: 25.0, y0: 25.0, x1: 75.0, y1: 75.0 };\n        let r3 = fz_rect { x0: 100.0, y0: 100.0, x1: 150.0, y1: 150.0 };\n\n        assert_eq!(fz_overlaps_rect(r1, r2), 1);\n        assert_eq!(fz_overlaps_rect(r1, r3), 0);\n    }\n\n    // Quad tests\n    #[test]\n    fn test_quad_from_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 20.0 };\n        let q = fz_quad_from_rect(r);\n        assert_eq!(q.ul.x, 0.0);\n        assert_eq!(q.ul.y, 0.0);\n        assert_eq!(q.ur.x, 10.0);\n        assert_eq!(q.ur.y, 0.0);\n        assert_eq!(q.ll.x, 0.0);\n        assert_eq!(q.ll.y, 20.0);\n        assert_eq!(q.lr.x, 10.0);\n        assert_eq!(q.lr.y, 20.0);\n    }\n\n    #[test]\n    fn test_rect_from_quad() {\n        let q = fz_quad {\n            ul: fz_point { x: 0.0, y: 0.0 },\n            ur: fz_point { x: 10.0, y: 0.0 },\n            ll: fz_point { x: 0.0, y: 20.0 },\n            lr: fz_point { x: 10.0, y: 20.0 },\n        };\n        let r = fz_rect_from_quad(q);\n        assert_eq!(r.x0, 0.0);\n        assert_eq!(r.y0, 0.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_transform_quad() {\n        let q = fz_quad {\n            ul: fz_point { x: 0.0, y: 0.0 },\n            ur: fz_point { x: 10.0, y: 0.0 },\n            ll: fz_point { x: 0.0, y: 10.0 },\n            lr: fz_point { x: 10.0, y: 10.0 },\n        };\n        let m = fz_translate(5.0, 5.0);\n        let result = fz_transform_quad(q, m);\n        assert_eq!(result.ul.x, 5.0);\n        assert_eq!(result.ul.y, 5.0);\n        assert_eq!(result.lr.x, 15.0);\n        assert_eq!(result.lr.y, 15.0);\n    }\n\n    // Point inside tests\n    #[test]\n    fn test_is_point_inside_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let inside = fz_point { x: 5.0, y: 5.0 };\n        let outside = fz_point { x: 15.0, y: 15.0 };\n        assert_eq!(fz_is_point_inside_rect(inside, r), 1);\n        assert_eq!(fz_is_point_inside_rect(outside, r), 0);\n    }\n\n    #[test]\n    fn test_is_point_inside_irect() {\n        let r = fz_irect { x0: 0, y0: 0, x1: 10, y1: 10 };\n        assert_eq!(fz_is_point_inside_irect(5, 5, r), 1);\n        assert_eq!(fz_is_point_inside_irect(15, 15, r), 0);\n    }\n\n    // Static values tests\n    #[test]\n    fn test_static_values() {\n        assert_eq!(fz_identity.a, 1.0);\n        assert_eq!(fz_identity.d, 1.0);\n\n        // Empty rect uses infinity\n        assert!(fz_empty_rect.x0.is_infinite());\n        assert_eq!(fz_unit_rect.x1, 1.0);\n    }\n\n    // Version test\n    #[test]\n    fn test_version() {\n        let version = fz_version();\n        assert!(!version.is_null());\n    }\n}\n","traces":[{"line":51,"address":[1471472],"length":1,"stats":{"Line":0}},{"line":52,"address":[2452536],"length":1,"stats":{"Line":0}},{"line":57,"address":[1471504],"length":1,"stats":{"Line":3}},{"line":111,"address":[1471568],"length":1,"stats":{"Line":1}},{"line":113,"address":[1471581],"length":1,"stats":{"Line":1}},{"line":114,"address":[1471603],"length":1,"stats":{"Line":2}},{"line":115,"address":[1471626],"length":1,"stats":{"Line":2}},{"line":116,"address":[2452705],"length":1,"stats":{"Line":2}},{"line":117,"address":[1471673],"length":1,"stats":{"Line":3}},{"line":118,"address":[1471701],"length":1,"stats":{"Line":6}},{"line":123,"address":[1471760],"length":1,"stats":{"Line":2}},{"line":128,"address":[1471824],"length":1,"stats":{"Line":1}},{"line":129,"address":[1471866],"length":1,"stats":{"Line":1}},{"line":133,"address":[1472000],"length":1,"stats":{"Line":1}},{"line":134,"address":[1472042],"length":1,"stats":{"Line":1}},{"line":138,"address":[1472176],"length":1,"stats":{"Line":1}},{"line":143,"address":[1472256],"length":1,"stats":{"Line":1}},{"line":144,"address":[1472298],"length":1,"stats":{"Line":1}},{"line":148,"address":[1472500,1472432],"length":1,"stats":{"Line":1}},{"line":149,"address":[1472459],"length":1,"stats":{"Line":1}},{"line":150,"address":[1472481,1472527],"length":1,"stats":{"Line":2}},{"line":151,"address":[2453595],"length":1,"stats":{"Line":2}},{"line":155,"address":[1472608],"length":1,"stats":{"Line":1}},{"line":156,"address":[1472644],"length":1,"stats":{"Line":1}},{"line":160,"address":[1472784],"length":1,"stats":{"Line":2}},{"line":165,"address":[1472864],"length":1,"stats":{"Line":1}},{"line":166,"address":[1472906],"length":1,"stats":{"Line":1}},{"line":170,"address":[2454176,2454096],"length":1,"stats":{"Line":1}},{"line":171,"address":[1473064],"length":1,"stats":{"Line":1}},{"line":172,"address":[1473107,1473132],"length":1,"stats":{"Line":2}},{"line":173,"address":[1473346],"length":1,"stats":{"Line":0}},{"line":175,"address":[1473165],"length":1,"stats":{"Line":1}},{"line":177,"address":[1473189],"length":1,"stats":{"Line":1}},{"line":178,"address":[2454253],"length":1,"stats":{"Line":1}},{"line":179,"address":[1473220],"length":1,"stats":{"Line":1}},{"line":180,"address":[2454299],"length":1,"stats":{"Line":1}},{"line":181,"address":[1473250],"length":1,"stats":{"Line":1}},{"line":182,"address":[1473278],"length":1,"stats":{"Line":1}},{"line":187,"address":[1473392,1473423],"length":1,"stats":{"Line":1}},{"line":188,"address":[1473434,1473406],"length":1,"stats":{"Line":2}},{"line":192,"address":[1473600,1473631],"length":1,"stats":{"Line":1}},{"line":193,"address":[1473642,1473614],"length":1,"stats":{"Line":2}},{"line":197,"address":[1473792,1473824],"length":1,"stats":{"Line":1}},{"line":198,"address":[1473921,1473836,1473806,1473950],"length":1,"stats":{"Line":4}},{"line":199,"address":[2454969],"length":1,"stats":{"Line":1}},{"line":201,"address":[1473942],"length":1,"stats":{"Line":1}},{"line":210,"address":[1474089,1474016],"length":1,"stats":{"Line":2}},{"line":212,"address":[1474064],"length":1,"stats":{"Line":2}},{"line":213,"address":[2455151],"length":1,"stats":{"Line":2}},{"line":214,"address":[1474120],"length":1,"stats":{"Line":2}},{"line":215,"address":[1474145],"length":1,"stats":{"Line":2}},{"line":220,"address":[1474307,1474240],"length":1,"stats":{"Line":1}},{"line":222,"address":[1474284],"length":1,"stats":{"Line":1}},{"line":223,"address":[1474313],"length":1,"stats":{"Line":1}},{"line":224,"address":[1474336],"length":1,"stats":{"Line":1}},{"line":225,"address":[1474359],"length":1,"stats":{"Line":1}},{"line":230,"address":[1474505,1474432],"length":1,"stats":{"Line":2}},{"line":232,"address":[1474480],"length":1,"stats":{"Line":2}},{"line":233,"address":[1474511],"length":1,"stats":{"Line":2}},{"line":234,"address":[1474536],"length":1,"stats":{"Line":2}},{"line":235,"address":[1474561],"length":1,"stats":{"Line":2}},{"line":240,"address":[2455757,2455712],"length":1,"stats":{"Line":1}},{"line":242,"address":[1474682,1474713],"length":1,"stats":{"Line":2}},{"line":243,"address":[1474748],"length":1,"stats":{"Line":1}},{"line":244,"address":[1474808],"length":1,"stats":{"Line":1}},{"line":245,"address":[1474868],"length":1,"stats":{"Line":1}},{"line":250,"address":[1474976,1475033],"length":1,"stats":{"Line":1}},{"line":252,"address":[1475002,1475045],"length":1,"stats":{"Line":2}},{"line":253,"address":[1475080],"length":1,"stats":{"Line":1}},{"line":254,"address":[2456208],"length":1,"stats":{"Line":1}},{"line":255,"address":[1475224],"length":1,"stats":{"Line":1}},{"line":260,"address":[1475344],"length":1,"stats":{"Line":1}},{"line":262,"address":[1475364],"length":1,"stats":{"Line":1}},{"line":263,"address":[1475370],"length":1,"stats":{"Line":1}},{"line":264,"address":[1475376],"length":1,"stats":{"Line":1}},{"line":265,"address":[1475382],"length":1,"stats":{"Line":1}},{"line":270,"address":[1475440],"length":1,"stats":{"Line":1}},{"line":272,"address":[1475471,1475483],"length":1,"stats":{"Line":2}},{"line":273,"address":[1475477,1475487],"length":1,"stats":{"Line":2}},{"line":274,"address":[1475491],"length":1,"stats":{"Line":1}},{"line":275,"address":[1475501],"length":1,"stats":{"Line":1}},{"line":280,"address":[1475552,1475606],"length":1,"stats":{"Line":1}},{"line":282,"address":[2456647],"length":1,"stats":{"Line":1}},{"line":283,"address":[1475616],"length":1,"stats":{"Line":1}},{"line":284,"address":[1475635],"length":1,"stats":{"Line":1}},{"line":285,"address":[2456710],"length":1,"stats":{"Line":1}},{"line":290,"address":[2456851,2456784],"length":1,"stats":{"Line":1}},{"line":292,"address":[1475770],"length":1,"stats":{"Line":1}},{"line":293,"address":[2456857],"length":1,"stats":{"Line":1}},{"line":294,"address":[1475826],"length":1,"stats":{"Line":1}},{"line":295,"address":[2456907],"length":1,"stats":{"Line":1}},{"line":300,"address":[1475952],"length":1,"stats":{"Line":1}},{"line":302,"address":[1476004,1476016],"length":1,"stats":{"Line":2}},{"line":303,"address":[2457076,2457066],"length":1,"stats":{"Line":2}},{"line":304,"address":[2457080],"length":1,"stats":{"Line":1}},{"line":305,"address":[1476034],"length":1,"stats":{"Line":1}},{"line":310,"address":[1476096,1476158],"length":1,"stats":{"Line":1}},{"line":312,"address":[1476143],"length":1,"stats":{"Line":1}},{"line":313,"address":[1476168],"length":1,"stats":{"Line":1}},{"line":314,"address":[2457243],"length":1,"stats":{"Line":1}},{"line":315,"address":[2457262],"length":1,"stats":{"Line":1}},{"line":320,"address":[1476420,1476272],"length":1,"stats":{"Line":2}},{"line":321,"address":[1476330],"length":1,"stats":{"Line":2}},{"line":325,"address":[1476448,1476604],"length":1,"stats":{"Line":1}},{"line":326,"address":[1476506],"length":1,"stats":{"Line":1}},{"line":334,"address":[1476624],"length":1,"stats":{"Line":2}},{"line":336,"address":[1476645],"length":1,"stats":{"Line":2}},{"line":337,"address":[2457731],"length":1,"stats":{"Line":2}},{"line":342,"address":[2457792],"length":1,"stats":{"Line":1}},{"line":344,"address":[2457812],"length":1,"stats":{"Line":1}},{"line":345,"address":[1476780],"length":1,"stats":{"Line":1}},{"line":350,"address":[1476832],"length":1,"stats":{"Line":1}},{"line":352,"address":[2457909],"length":1,"stats":{"Line":1}},{"line":353,"address":[2457934],"length":1,"stats":{"Line":1}},{"line":358,"address":[2457984,2459386],"length":1,"stats":{"Line":1}},{"line":359,"address":[2459906,2458057],"length":1,"stats":{"Line":2}},{"line":360,"address":[2458977],"length":1,"stats":{"Line":1}},{"line":361,"address":[2459173],"length":1,"stats":{"Line":1}},{"line":363,"address":[2459370],"length":1,"stats":{"Line":1}},{"line":364,"address":[2459783],"length":1,"stats":{"Line":1}},{"line":365,"address":[1478806],"length":1,"stats":{"Line":1}},{"line":366,"address":[1478831],"length":1,"stats":{"Line":1}},{"line":369,"address":[2458147],"length":1,"stats":{"Line":0}},{"line":370,"address":[2458346],"length":1,"stats":{"Line":0}},{"line":371,"address":[2458542],"length":1,"stats":{"Line":0}},{"line":372,"address":[1477710],"length":1,"stats":{"Line":0}},{"line":374,"address":[2459407,2458950],"length":1,"stats":{"Line":0}},{"line":375,"address":[1478446],"length":1,"stats":{"Line":0}},{"line":376,"address":[2459541],"length":1,"stats":{"Line":0}},{"line":377,"address":[1478614],"length":1,"stats":{"Line":0}},{"line":383,"address":[2459977,2459920],"length":1,"stats":{"Line":1}},{"line":384,"address":[2459940,2459989],"length":1,"stats":{"Line":2}},{"line":385,"address":[1478987],"length":1,"stats":{"Line":1}},{"line":386,"address":[2460048],"length":1,"stats":{"Line":0}},{"line":388,"address":[1479006],"length":1,"stats":{"Line":1}},{"line":396,"address":[1479072],"length":1,"stats":{"Line":2}},{"line":398,"address":[1479107],"length":1,"stats":{"Line":2}},{"line":399,"address":[1479119],"length":1,"stats":{"Line":2}},{"line":400,"address":[2460139],"length":1,"stats":{"Line":2}},{"line":401,"address":[1479143],"length":1,"stats":{"Line":2}},{"line":406,"address":[1479200,1479236],"length":1,"stats":{"Line":2}},{"line":408,"address":[1479214,1479253],"length":1,"stats":{"Line":4}},{"line":409,"address":[1479305],"length":1,"stats":{"Line":2}},{"line":410,"address":[1479391],"length":1,"stats":{"Line":2}},{"line":411,"address":[1479476],"length":1,"stats":{"Line":2}},{"line":416,"address":[1479632],"length":1,"stats":{"Line":1}},{"line":418,"address":[1479675],"length":1,"stats":{"Line":1}},{"line":419,"address":[1479839],"length":1,"stats":{"Line":1}},{"line":420,"address":[2461037],"length":1,"stats":{"Line":1}},{"line":421,"address":[1480223],"length":1,"stats":{"Line":1}},{"line":426,"address":[1480638,1480496],"length":1,"stats":{"Line":1}},{"line":427,"address":[1480548],"length":1,"stats":{"Line":1}},{"line":431,"address":[1480656,1480772],"length":1,"stats":{"Line":1}},{"line":432,"address":[1480706],"length":1,"stats":{"Line":1}},{"line":440,"address":[1480824,1480800],"length":1,"stats":{"Line":1}},{"line":441,"address":[1480801],"length":1,"stats":{"Line":1}}],"covered":144,"coverable":156},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","mod.rs"],"content":"//! C FFI Module - MuPDF API Compatible Exports\n//!\n//! This module provides C-compatible exports that match MuPDF's API.\n//! Uses safe Rust patterns with handle-based resource management.\n\npub mod geometry;\npub mod context;\npub mod buffer;\npub mod stream;\npub mod colorspace;\npub mod pixmap;\npub mod document;\npub mod pdf_object;\n\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex, atomic::{AtomicU64, Ordering}};\n\n/// Global handle manager for safe FFI resource management\nstatic HANDLE_COUNTER: AtomicU64 = AtomicU64::new(1);\n\n/// Type alias for handles\npub type Handle = u64;\n\n/// Generate a new unique handle\npub fn new_handle() -\u003e Handle {\n    HANDLE_COUNTER.fetch_add(1, Ordering::SeqCst)\n}\n\n/// Thread-safe handle storage for a specific type\npub struct HandleStore\u003cT\u003e {\n    store: Mutex\u003cHashMap\u003cHandle, Arc\u003cMutex\u003cT\u003e\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e HandleStore\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self {\n            store: Mutex::new(HashMap::new()),\n        }\n    }\n\n    pub fn insert(\u0026self, value: T) -\u003e Handle {\n        let handle = new_handle();\n        let mut store = self.store.lock().unwrap();\n        store.insert(handle, Arc::new(Mutex::new(value)));\n        handle\n    }\n\n    pub fn get(\u0026self, handle: Handle) -\u003e Option\u003cArc\u003cMutex\u003cT\u003e\u003e\u003e {\n        let store = self.store.lock().unwrap();\n        store.get(\u0026handle).cloned()\n    }\n\n    pub fn remove(\u0026self, handle: Handle) -\u003e Option\u003cArc\u003cMutex\u003cT\u003e\u003e\u003e {\n        let mut store = self.store.lock().unwrap();\n        store.remove(\u0026handle)\n    }\n\n    pub fn keep(\u0026self, handle: Handle) -\u003e Handle {\n        // For reference counting, we just return the same handle\n        // The Arc inside handles ref counting automatically\n        handle\n    }\n}\n\nimpl\u003cT\u003e Default for HandleStore\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// Lazy initialization for handle stores\nuse std::sync::LazyLock;\n\npub static CONTEXTS: LazyLock\u003cHandleStore\u003ccontext::Context\u003e\u003e = LazyLock::new(HandleStore::new);\npub static BUFFERS: LazyLock\u003cHandleStore\u003cbuffer::Buffer\u003e\u003e = LazyLock::new(HandleStore::new);\npub static STREAMS: LazyLock\u003cHandleStore\u003cstream::Stream\u003e\u003e = LazyLock::new(HandleStore::new);\npub static PIXMAPS: LazyLock\u003cHandleStore\u003cpixmap::Pixmap\u003e\u003e = LazyLock::new(HandleStore::new);\npub static DOCUMENTS: LazyLock\u003cHandleStore\u003cdocument::Document\u003e\u003e = LazyLock::new(HandleStore::new);\n","traces":[{"line":25,"address":[2043280],"length":1,"stats":{"Line":6}},{"line":26,"address":[1671953],"length":1,"stats":{"Line":8}},{"line":35,"address":[1672848,1672688,1672768,1672928,1673088,1673008],"length":1,"stats":{"Line":10}},{"line":37,"address":[1673101,1672701,1673021,1672781,1672861,1672941],"length":1,"stats":{"Line":10}},{"line":41,"address":[1673605,1674096,1674560,1675008,1673168,1674973,1674059,1674521,1675472,1675895,1673648,1675433],"length":1,"stats":{"Line":32}},{"line":42,"address":[1673193,1675580,1674585,1674204,1673756,1674668,1675033,1673673,1674121,1675116,1673276,1675497],"length":1,"stats":{"Line":81}},{"line":43,"address":[1673284,1675124,1675588,1674212,1674676,1673764],"length":1,"stats":{"Line":40}},{"line":44,"address":[1673419,1674744,1674280,1673899,1674347,1674811,1675656,1675259,1673352,1675723,1675192,1673832],"length":1,"stats":{"Line":20}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[1676959,1676965,1676757,1676768,1677173,1676352,1676976,1676335,1676144,1675936,1676341,1677167,1676549,1676133,1676751,1676127,1676543,1676560],"length":1,"stats":{"Line":17}},{"line":49,"address":[1676580,1676996,1676372,1675956,1676164,1676788],"length":1,"stats":{"Line":18}},{"line":50,"address":[1676274,1677106,1676216,1676066,1676008,1676424,1677048,1676632,1676840,1676898,1676482,1676690],"length":1,"stats":{"Line":18}},{"line":53,"address":[1677746,1678322,1677568,1677938,1677356,1678124,1678130,1677554,1677760,1677362,1677932,1677376,1677952,1677184,1677740,1678144,1678316,1677548],"length":1,"stats":{"Line":27}},{"line":54,"address":[1677780,1677588,1677204,1677396,1678164,1677972],"length":1,"stats":{"Line":34}},{"line":55,"address":[1677506,1677832,1678274,1678082,1677890,1677314,1677698,1678024,1678216,1677256,1677640,1677448],"length":1,"stats":{"Line":20}},{"line":58,"address":[1678352,1678336,1678384,1678368],"length":1,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[1678400],"length":1,"stats":{"Line":1}},{"line":67,"address":[1678408],"length":1,"stats":{"Line":1}},{"line":74,"address":[11599984],"length":1,"stats":{"Line":0}},{"line":75,"address":[11600002],"length":1,"stats":{"Line":0}},{"line":76,"address":[11600032],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":22},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","pdf_object.rs"],"content":"//! PDF Object FFI - MuPDF API Compatible Exports\n//!\n//! This module provides C-compatible exports for PDF object manipulation.\n\nuse std::ffi::{c_char, CStr, CString};\nuse std::sync::{LazyLock, Mutex};\n\nuse super::{Handle, HandleStore};\n\n// ============================================================================\n// PDF Object Types\n// ============================================================================\n\n/// PDF Object type enumeration\n#[derive(Debug, Clone)]\npub enum PdfObjType {\n    Null,\n    Bool(bool),\n    Int(i64),\n    Real(f64),\n    Name(String),\n    String(Vec\u003cu8\u003e),\n    Array(Vec\u003cPdfObj\u003e),\n    Dict(Vec\u003c(String, PdfObj)\u003e),\n    Indirect { num: i32, generation: i32 },\n    Stream { dict: Box\u003cPdfObj\u003e, data: Vec\u003cu8\u003e },\n}\n\nimpl PdfObjType {\n    /// Compare two object types for equality (shallow comparison)\n    pub fn shallow_eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (PdfObjType::Null, PdfObjType::Null) =\u003e true,\n            (PdfObjType::Bool(a), PdfObjType::Bool(b)) =\u003e a == b,\n            (PdfObjType::Int(a), PdfObjType::Int(b)) =\u003e a == b,\n            (PdfObjType::Real(a), PdfObjType::Real(b)) =\u003e (a - b).abs() \u003c f64::EPSILON,\n            (PdfObjType::Name(a), PdfObjType::Name(b)) =\u003e a == b,\n            (PdfObjType::String(a), PdfObjType::String(b)) =\u003e a == b,\n            (PdfObjType::Array(a), PdfObjType::Array(b)) =\u003e a.len() == b.len(),\n            (PdfObjType::Dict(a), PdfObjType::Dict(b)) =\u003e a.len() == b.len(),\n            (PdfObjType::Indirect { num: n1, generation: g1 }, PdfObjType::Indirect { num: n2, generation: g2 }) =\u003e {\n                n1 == n2 \u0026\u0026 g1 == g2\n            }\n            (PdfObjType::Stream { .. }, PdfObjType::Stream { .. }) =\u003e false, // Streams never match\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Internal PDF object representation\n#[derive(Debug, Clone)]\npub struct PdfObj {\n    pub obj_type: PdfObjType,\n    pub marked: bool,\n    pub dirty: bool,\n    pub parent_num: i32,\n    pub refs: i32,\n}\n\nimpl PdfObj {\n    pub fn new_null() -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Null,\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_bool(b: bool) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Bool(b),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_int(i: i64) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Int(i),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_real(f: f64) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Real(f),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_name(s: \u0026str) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Name(s.to_string()),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_string(data: \u0026[u8]) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::String(data.to_vec()),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_array(cap: usize) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Array(Vec::with_capacity(cap)),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_dict(cap: usize) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Dict(Vec::with_capacity(cap)),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_indirect(num: i32, generation: i32) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Indirect { num, generation },\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n}\n\n/// Handle type for PDF objects\npub type PdfObjHandle = Handle;\n\n/// Global PDF object storage\npub static PDF_OBJECTS: LazyLock\u003cHandleStore\u003cPdfObj\u003e\u003e = LazyLock::new(HandleStore::default);\n\n// ============================================================================\n// PDF Object Creation Functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_null(_ctx: Handle) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_null())\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_bool(_ctx: Handle, b: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_bool(b != 0))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_int(_ctx: Handle, i: i64) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_int(i))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_real(_ctx: Handle, f: f32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_real(f as f64))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_name(_ctx: Handle, str: *const c_char) -\u003e PdfObjHandle {\n    if str.is_null() {\n        return PDF_OBJECTS.insert(PdfObj::new_name(\"\"));\n    }\n    #[allow(unsafe_code)]\n    let name = unsafe { CStr::from_ptr(str) }\n        .to_str()\n        .unwrap_or(\"\");\n    PDF_OBJECTS.insert(PdfObj::new_name(name))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_string(_ctx: Handle, str: *const c_char, len: usize) -\u003e PdfObjHandle {\n    if str.is_null() || len == 0 {\n        return PDF_OBJECTS.insert(PdfObj::new_string(\u0026[]));\n    }\n    #[allow(unsafe_code)]\n    let data = unsafe { std::slice::from_raw_parts(str as *const u8, len) };\n    PDF_OBJECTS.insert(PdfObj::new_string(data))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_text_string(_ctx: Handle, s: *const c_char) -\u003e PdfObjHandle {\n    if s.is_null() {\n        return PDF_OBJECTS.insert(PdfObj::new_string(\u0026[]));\n    }\n    #[allow(unsafe_code)]\n    let text = unsafe { CStr::from_ptr(s) }\n        .to_str()\n        .unwrap_or(\"\");\n    PDF_OBJECTS.insert(PdfObj::new_string(text.as_bytes()))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_indirect(_ctx: Handle, _doc: Handle, num: i32, generation: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_indirect(num, generation))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_array(_ctx: Handle, _doc: Handle, initialcap: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_array(initialcap.max(0) as usize))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_dict(_ctx: Handle, _doc: Handle, initialcap: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_dict(initialcap.max(0) as usize))\n}\n\n// ============================================================================\n// PDF Object Reference Counting\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_keep_obj(_ctx: Handle, obj: PdfObjHandle) -\u003e PdfObjHandle {\n    if let Some(arc) = PDF_OBJECTS.get(obj) {\n        if let Ok(mut guard) = arc.lock() {\n            guard.refs += 1;\n        }\n    }\n    obj\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_drop_obj(_ctx: Handle, obj: PdfObjHandle) {\n    if let Some(arc) = PDF_OBJECTS.get(obj) {\n        let should_remove = {\n            if let Ok(mut guard) = arc.lock() {\n                guard.refs -= 1;\n                guard.refs \u003c= 0\n            } else {\n                false\n            }\n        };\n        if should_remove {\n            PDF_OBJECTS.remove(obj);\n        }\n    }\n}\n\n// ============================================================================\n// Helper function to extract object properties\n// ============================================================================\n\nfn with_obj\u003cT, F: FnOnce(\u0026PdfObj) -\u003e T\u003e(obj: PdfObjHandle, default: T, f: F) -\u003e T {\n    PDF_OBJECTS\n        .get(obj)\n        .and_then(|arc| arc.lock().ok().map(|guard| f(\u0026guard)))\n        .unwrap_or(default)\n}\n\nfn with_obj_mut\u003cT, F: FnOnce(\u0026mut PdfObj) -\u003e T\u003e(obj: PdfObjHandle, default: T, f: F) -\u003e T {\n    PDF_OBJECTS\n        .get(obj)\n        .and_then(|arc| arc.lock().ok().map(|mut guard| f(\u0026mut guard)))\n        .unwrap_or(default)\n}\n\n// ============================================================================\n// PDF Object Type Checking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_null(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 1, |o| i32::from(matches!(o.obj_type, PdfObjType::Null)))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_bool(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Bool(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_int(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Int(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_real(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Real(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_number(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| {\n        i32::from(matches!(o.obj_type, PdfObjType::Int(_) | PdfObjType::Real(_)))\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_name(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Name(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_string(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::String(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_array(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Array(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_dict(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Dict(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_indirect(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Indirect { .. })))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_stream(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Stream { .. })))\n}\n\n// ============================================================================\n// PDF Object Value Extraction\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_bool(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Bool(b) =\u003e i32::from(*b),\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i as i32,\n        PdfObjType::Real(f) =\u003e *f as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int64(_ctx: Handle, obj: PdfObjHandle) -\u003e i64 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i,\n        PdfObjType::Real(f) =\u003e *f as i64,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_real(_ctx: Handle, obj: PdfObjHandle) -\u003e f32 {\n    with_obj(obj, 0.0, |o| match \u0026o.obj_type {\n        PdfObjType::Real(f) =\u003e *f as f32,\n        PdfObjType::Int(i) =\u003e *i as f32,\n        _ =\u003e 0.0,\n    })\n}\n\n// Static storage for returned name strings\nstatic NAME_STORAGE: LazyLock\u003cMutex\u003cVec\u003cCString\u003e\u003e\u003e = LazyLock::new(|| Mutex::new(Vec::new()));\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_name(_ctx: Handle, obj: PdfObjHandle) -\u003e *const c_char {\n    static EMPTY: \u0026[u8] = b\"\\0\";\n\n    let name = with_obj(obj, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    match name {\n        Some(s) =\u003e {\n            if let Ok(cstring) = CString::new(s) {\n                let ptr = cstring.as_ptr();\n                if let Ok(mut storage) = NAME_STORAGE.lock() {\n                    storage.push(cstring);\n                }\n                ptr\n            } else {\n                EMPTY.as_ptr() as *const c_char\n            }\n        }\n        None =\u003e EMPTY.as_ptr() as *const c_char,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_num(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Indirect { num, .. } =\u003e *num,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_gen(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Indirect { generation, .. } =\u003e *generation,\n        _ =\u003e 0,\n    })\n}\n\n// ============================================================================\n// PDF Object Value Extraction with Defaults\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_bool_default(_ctx: Handle, obj: PdfObjHandle, def: i32) -\u003e i32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Bool(b) =\u003e i32::from(*b),\n        _ =\u003e def,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int_default(_ctx: Handle, obj: PdfObjHandle, def: i32) -\u003e i32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i as i32,\n        PdfObjType::Real(f) =\u003e *f as i32,\n        _ =\u003e def,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_real_default(_ctx: Handle, obj: PdfObjHandle, def: f32) -\u003e f32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Real(f) =\u003e *f as f32,\n        PdfObjType::Int(i) =\u003e *i as f32,\n        _ =\u003e def,\n    })\n}\n\n// ============================================================================\n// PDF Array Operations\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_len(_ctx: Handle, array: PdfObjHandle) -\u003e i32 {\n    with_obj(array, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Array(arr) =\u003e arr.len() as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push(_ctx: Handle, array: PdfObjHandle, obj: PdfObjHandle) {\n    let obj_to_push = with_obj(obj, None, |o| Some(o.clone()));\n\n    if let Some(obj_clone) = obj_to_push {\n        with_obj_mut(array, (), |arr| {\n            if let PdfObjType::Array(ref mut a) = arr.obj_type {\n                a.push(obj_clone);\n                arr.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_int(_ctx: Handle, array: PdfObjHandle, x: i64) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_int(x));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_real(_ctx: Handle, array: PdfObjHandle, x: f64) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_real(x));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_bool(_ctx: Handle, array: PdfObjHandle, x: i32) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_bool(x != 0));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_delete(_ctx: Handle, array: PdfObjHandle, index: i32) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            let idx = index as usize;\n            if idx \u003c a.len() {\n                a.remove(idx);\n                arr.dirty = true;\n            }\n        }\n    });\n}\n\n// ============================================================================\n// PDF Dictionary Operations\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_len(_ctx: Handle, dict: PdfObjHandle) -\u003e i32 {\n    with_obj(dict, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Dict(d) =\u003e d.len() as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_puts(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: *const c_char,\n    val: PdfObjHandle,\n) {\n    if key.is_null() {\n        return;\n    }\n\n    #[allow(unsafe_code)]\n    let key_str = unsafe { CStr::from_ptr(key) }\n        .to_str()\n        .unwrap_or(\"\")\n        .to_string();\n\n    let val_obj = with_obj(val, None, |o| Some(o.clone()));\n\n    if let Some(val_clone) = val_obj {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val_clone;\n                } else {\n                    dict_entries.push((key_str.clone(), val_clone));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_dels(_ctx: Handle, dict: PdfObjHandle, key: *const c_char) {\n    if key.is_null() {\n        return;\n    }\n\n    #[allow(unsafe_code)]\n    let key_str = unsafe { CStr::from_ptr(key) }\n        .to_str()\n        .unwrap_or(\"\")\n        .to_string();\n\n    with_obj_mut(dict, (), |d| {\n        if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n            dict_entries.retain(|(k, _)| k != \u0026key_str);\n            d.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_int(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: i64,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_int(x);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_real(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: f64,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_real(x);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_bool(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: i32,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_bool(x != 0);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n// ============================================================================\n// PDF Object Marking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_marked(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(o.marked))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_mark_obj(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj_mut(obj, 0, |o| {\n        let was_marked = o.marked;\n        o.marked = true;\n        i32::from(was_marked)\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_unmark_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.marked = false;\n    });\n}\n\n// ============================================================================\n// PDF Object Dirty Tracking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_is_dirty(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(o.dirty))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dirty_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.dirty = true;\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_clean_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.dirty = false;\n    });\n}\n\n// ============================================================================\n// PDF Object Parent\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_set_obj_parent(_ctx: Handle, obj: PdfObjHandle, num: i32) {\n    with_obj_mut(obj, (), |o| {\n        o.parent_num = num;\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_parent_num(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| o.parent_num)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_refs(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| o.refs)\n}\n\n// ============================================================================\n// PDF Object Comparison\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_objcmp(_ctx: Handle, a: PdfObjHandle, b: PdfObjHandle) -\u003e i32 {\n    let obj_a = with_obj(a, None, |o| Some(o.obj_type.clone()));\n    let obj_b = with_obj(b, None, |o| Some(o.obj_type.clone()));\n\n    match (obj_a, obj_b) {\n        (Some(a_type), Some(b_type)) =\u003e i32::from(!a_type.shallow_eq(\u0026b_type)),\n        _ =\u003e 1,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_name_eq(_ctx: Handle, a: PdfObjHandle, b: PdfObjHandle) -\u003e i32 {\n    let name_a = with_obj(a, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    let name_b = with_obj(b, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    match (name_a, name_b) {\n        (Some(a_name), Some(b_name)) =\u003e i32::from(a_name == b_name),\n        _ =\u003e 0,\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // Object Creation Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_new_null() {\n        let null = pdf_new_null(0);\n        assert_eq!(pdf_is_null(0, null), 1);\n        assert_eq!(pdf_is_bool(0, null), 0);\n        assert_eq!(pdf_is_int(0, null), 0);\n    }\n\n    #[test]\n    fn test_pdf_new_bool() {\n        let bool_true = pdf_new_bool(0, 1);\n        assert_eq!(pdf_is_bool(0, bool_true), 1);\n        assert_eq!(pdf_to_bool(0, bool_true), 1);\n\n        let bool_false = pdf_new_bool(0, 0);\n        assert_eq!(pdf_is_bool(0, bool_false), 1);\n        assert_eq!(pdf_to_bool(0, bool_false), 0);\n\n        // Non-zero should also be true\n        let bool_nonzero = pdf_new_bool(0, 42);\n        assert_eq!(pdf_to_bool(0, bool_nonzero), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_int() {\n        let int_val = pdf_new_int(0, 42);\n        assert_eq!(pdf_is_int(0, int_val), 1);\n        assert_eq!(pdf_to_int(0, int_val), 42);\n        assert_eq!(pdf_to_int64(0, int_val), 42);\n\n        // Negative value\n        let neg_val = pdf_new_int(0, -100);\n        assert_eq!(pdf_to_int(0, neg_val), -100);\n        assert_eq!(pdf_to_int64(0, neg_val), -100);\n\n        // Large value\n        let large_val = pdf_new_int(0, i64::MAX);\n        assert_eq!(pdf_to_int64(0, large_val), i64::MAX);\n    }\n\n    #[test]\n    fn test_pdf_new_real() {\n        let real_val = pdf_new_real(0, 3.14);\n        assert_eq!(pdf_is_real(0, real_val), 1);\n        assert!((pdf_to_real(0, real_val) - 3.14).abs() \u003c 0.01);\n\n        // Negative value\n        let neg_real = pdf_new_real(0, -2.5);\n        assert!((pdf_to_real(0, neg_real) + 2.5).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_pdf_is_number() {\n        let int_val = pdf_new_int(0, 42);\n        let real_val = pdf_new_real(0, 3.14);\n        let null_val = pdf_new_null(0);\n\n        assert_eq!(pdf_is_number(0, int_val), 1);\n        assert_eq!(pdf_is_number(0, real_val), 1);\n        assert_eq!(pdf_is_number(0, null_val), 0);\n    }\n\n    #[test]\n    fn test_pdf_new_name() {\n        let name = pdf_new_name(0, b\"Type\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_is_name(0, name), 1);\n\n        // Empty name\n        let empty_name = pdf_new_name(0, std::ptr::null());\n        assert_eq!(pdf_is_name(0, empty_name), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_string() {\n        let data = b\"Hello, PDF!\";\n        let str_obj = pdf_new_string(0, data.as_ptr() as *const c_char, data.len());\n        assert_eq!(pdf_is_string(0, str_obj), 1);\n\n        // Empty string\n        let empty_str = pdf_new_string(0, std::ptr::null(), 0);\n        assert_eq!(pdf_is_string(0, empty_str), 1);\n\n        // Null pointer with non-zero length\n        let null_str = pdf_new_string(0, std::ptr::null(), 10);\n        assert_eq!(pdf_is_string(0, null_str), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_text_string() {\n        let text_obj = pdf_new_text_string(0, b\"Hello World\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_is_string(0, text_obj), 1);\n\n        // Null text\n        let null_text = pdf_new_text_string(0, std::ptr::null());\n        assert_eq!(pdf_is_string(0, null_text), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_indirect() {\n        let indirect = pdf_new_indirect(0, 0, 10, 2);\n        assert_eq!(pdf_is_indirect(0, indirect), 1);\n        assert_eq!(pdf_to_num(0, indirect), 10);\n        assert_eq!(pdf_to_gen(0, indirect), 2);\n    }\n\n    // ============================================================================\n    // Reference Counting Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_keep_drop_obj() {\n        let obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_obj_refs(0, obj), 1);\n\n        pdf_keep_obj(0, obj);\n        assert_eq!(pdf_obj_refs(0, obj), 2);\n\n        pdf_drop_obj(0, obj);\n        assert_eq!(pdf_obj_refs(0, obj), 1);\n\n        pdf_drop_obj(0, obj);\n        // Object should be removed, so refs should be 0 (default)\n        assert_eq!(pdf_obj_refs(0, obj), 0);\n    }\n\n    #[test]\n    fn test_pdf_keep_invalid_handle() {\n        let invalid = pdf_keep_obj(0, 99999);\n        assert_eq!(invalid, 99999); // Should return same handle\n    }\n\n    // ============================================================================\n    // Value Extraction with Defaults Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_to_bool_default() {\n        let bool_obj = pdf_new_bool(0, 1);\n        let null_obj = pdf_new_null(0);\n\n        assert_eq!(pdf_to_bool_default(0, bool_obj, 0), 1);\n        assert_eq!(pdf_to_bool_default(0, null_obj, 99), 99);\n    }\n\n    #[test]\n    fn test_pdf_to_int_default() {\n        let int_obj = pdf_new_int(0, 42);\n        let null_obj = pdf_new_null(0);\n        let real_obj = pdf_new_real(0, 3.7);\n\n        assert_eq!(pdf_to_int_default(0, int_obj, 0), 42);\n        assert_eq!(pdf_to_int_default(0, null_obj, 99), 99);\n        assert_eq!(pdf_to_int_default(0, real_obj, 0), 3); // Truncated\n    }\n\n    #[test]\n    fn test_pdf_to_real_default() {\n        let real_obj = pdf_new_real(0, 3.14);\n        let null_obj = pdf_new_null(0);\n        let int_obj = pdf_new_int(0, 5);\n\n        assert!((pdf_to_real_default(0, real_obj, 0.0) - 3.14).abs() \u003c 0.01);\n        assert!((pdf_to_real_default(0, null_obj, 99.0) - 99.0).abs() \u003c 0.01);\n        assert!((pdf_to_real_default(0, int_obj, 0.0) - 5.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_pdf_to_name() {\n        let name = pdf_new_name(0, b\"TestName\\0\".as_ptr() as *const c_char);\n        let ptr = pdf_to_name(0, name);\n        assert!(!ptr.is_null());\n\n        // Test non-name object returns empty\n        let int_obj = pdf_new_int(0, 42);\n        let ptr2 = pdf_to_name(0, int_obj);\n        assert!(!ptr2.is_null());\n    }\n\n    // ============================================================================\n    // Array Operations Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_array_operations() {\n        let arr = pdf_new_array(0, 0, 10);\n        assert_eq!(pdf_is_array(0, arr), 1);\n        assert_eq!(pdf_array_len(0, arr), 0);\n\n        // Push int\n        pdf_array_push_int(0, arr, 100);\n        assert_eq!(pdf_array_len(0, arr), 1);\n\n        // Push real\n        pdf_array_push_real(0, arr, 2.5);\n        assert_eq!(pdf_array_len(0, arr), 2);\n\n        // Push bool\n        pdf_array_push_bool(0, arr, 1);\n        assert_eq!(pdf_array_len(0, arr), 3);\n\n        // Push object\n        let obj = pdf_new_int(0, 42);\n        pdf_array_push(0, arr, obj);\n        assert_eq!(pdf_array_len(0, arr), 4);\n\n        // Delete\n        pdf_array_delete(0, arr, 0);\n        assert_eq!(pdf_array_len(0, arr), 3);\n\n        // Delete out of bounds (should not crash)\n        pdf_array_delete(0, arr, 100);\n        assert_eq!(pdf_array_len(0, arr), 3);\n    }\n\n    #[test]\n    fn test_pdf_array_len_non_array() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_array_len(0, dict), 0);\n\n        let null = pdf_new_null(0);\n        assert_eq!(pdf_array_len(0, null), 0);\n    }\n\n    #[test]\n    fn test_pdf_array_push_to_non_array() {\n        let dict = pdf_new_dict(0, 0, 10);\n        pdf_array_push_int(0, dict, 42); // Should not crash\n        assert_eq!(pdf_dict_len(0, dict), 0); // Dict unchanged\n    }\n\n    // ============================================================================\n    // Dictionary Operations Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_dict_operations() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_is_dict(0, dict), 1);\n        assert_eq!(pdf_dict_len(0, dict), 0);\n\n        // Put int with name key\n        let key1 = pdf_new_name(0, b\"Type\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_int(0, dict, key1, 42);\n        assert_eq!(pdf_dict_len(0, dict), 1);\n\n        // Put real\n        let key2 = pdf_new_name(0, b\"Width\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_real(0, dict, key2, 100.5);\n        assert_eq!(pdf_dict_len(0, dict), 2);\n\n        // Put bool\n        let key3 = pdf_new_name(0, b\"Enabled\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_bool(0, dict, key3, 1);\n        assert_eq!(pdf_dict_len(0, dict), 3);\n\n        // Update existing key\n        pdf_dict_put_int(0, dict, key1, 99);\n        assert_eq!(pdf_dict_len(0, dict), 3); // Length unchanged\n\n        // Delete by string key\n        pdf_dict_dels(0, dict, b\"Width\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_dict_len(0, dict), 2);\n    }\n\n    #[test]\n    fn test_pdf_dict_puts() {\n        let dict = pdf_new_dict(0, 0, 10);\n        let val = pdf_new_int(0, 42);\n\n        pdf_dict_puts(0, dict, b\"Key\\0\".as_ptr() as *const c_char, val);\n        assert_eq!(pdf_dict_len(0, dict), 1);\n\n        // Null key\n        pdf_dict_puts(0, dict, std::ptr::null(), val);\n        assert_eq!(pdf_dict_len(0, dict), 1); // Unchanged\n    }\n\n    #[test]\n    fn test_pdf_dict_dels_null_key() {\n        let dict = pdf_new_dict(0, 0, 10);\n        pdf_dict_dels(0, dict, std::ptr::null()); // Should not crash\n    }\n\n    #[test]\n    fn test_pdf_dict_put_with_non_name_key() {\n        let dict = pdf_new_dict(0, 0, 10);\n        let int_key = pdf_new_int(0, 42); // Not a name\n\n        pdf_dict_put_int(0, dict, int_key, 100);\n        assert_eq!(pdf_dict_len(0, dict), 0); // Should be unchanged\n    }\n\n    #[test]\n    fn test_pdf_dict_len_non_dict() {\n        let arr = pdf_new_array(0, 0, 10);\n        assert_eq!(pdf_dict_len(0, arr), 0);\n    }\n\n    // ============================================================================\n    // Object Marking Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_object_marking() {\n        let obj = pdf_new_int(0, 1);\n        assert_eq!(pdf_obj_marked(0, obj), 0);\n\n        let was_marked = pdf_mark_obj(0, obj);\n        assert_eq!(was_marked, 0); // Was not marked before\n        assert_eq!(pdf_obj_marked(0, obj), 1);\n\n        let was_marked2 = pdf_mark_obj(0, obj);\n        assert_eq!(was_marked2, 1); // Was marked before\n\n        pdf_unmark_obj(0, obj);\n        assert_eq!(pdf_obj_marked(0, obj), 0);\n    }\n\n    // ============================================================================\n    // Object Dirty Tracking Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_object_dirty() {\n        let obj = pdf_new_int(0, 1);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 0);\n\n        pdf_dirty_obj(0, obj);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 1);\n\n        pdf_clean_obj(0, obj);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 0);\n    }\n\n    // ============================================================================\n    // Parent Number Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_obj_parent_num() {\n        let obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_obj_parent_num(0, obj), 0);\n\n        pdf_set_obj_parent(0, obj, 100);\n        assert_eq!(pdf_obj_parent_num(0, obj), 100);\n    }\n\n    // ============================================================================\n    // Object Comparison Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_objcmp() {\n        // Same type, same value\n        let int1 = pdf_new_int(0, 42);\n        let int2 = pdf_new_int(0, 42);\n        assert_eq!(pdf_objcmp(0, int1, int2), 0);\n\n        // Same type, different value\n        let int3 = pdf_new_int(0, 100);\n        assert_eq!(pdf_objcmp(0, int1, int3), 1);\n\n        // Different types\n        let real = pdf_new_real(0, 42.0);\n        assert_eq!(pdf_objcmp(0, int1, real), 1);\n\n        // Null objects\n        let null1 = pdf_new_null(0);\n        let null2 = pdf_new_null(0);\n        assert_eq!(pdf_objcmp(0, null1, null2), 0);\n\n        // Bool comparison\n        let bool1 = pdf_new_bool(0, 1);\n        let bool2 = pdf_new_bool(0, 1);\n        let bool3 = pdf_new_bool(0, 0);\n        assert_eq!(pdf_objcmp(0, bool1, bool2), 0);\n        assert_eq!(pdf_objcmp(0, bool1, bool3), 1);\n\n        // Invalid handles\n        assert_eq!(pdf_objcmp(0, 99999, 99998), 1);\n    }\n\n    #[test]\n    fn test_pdf_name_eq() {\n        let name1 = pdf_new_name(0, b\"Test\\0\".as_ptr() as *const c_char);\n        let name2 = pdf_new_name(0, b\"Test\\0\".as_ptr() as *const c_char);\n        let name3 = pdf_new_name(0, b\"Other\\0\".as_ptr() as *const c_char);\n\n        assert_eq!(pdf_name_eq(0, name1, name2), 1);\n        assert_eq!(pdf_name_eq(0, name1, name3), 0);\n\n        // Non-name objects\n        let int_obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_name_eq(0, name1, int_obj), 0);\n        assert_eq!(pdf_name_eq(0, int_obj, int_obj), 0);\n    }\n\n    // ============================================================================\n    // Type Checking Edge Cases\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_is_stream() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_is_stream(0, dict), 0);\n\n        // Note: We don't have pdf_new_stream, so we can't test positive case easily\n    }\n\n    #[test]\n    fn test_type_checks_invalid_handle() {\n        let invalid: PdfObjHandle = 99999;\n        assert_eq!(pdf_is_null(0, invalid), 1); // Default is 1 for null check\n        assert_eq!(pdf_is_bool(0, invalid), 0);\n        assert_eq!(pdf_is_int(0, invalid), 0);\n        assert_eq!(pdf_is_real(0, invalid), 0);\n        assert_eq!(pdf_is_number(0, invalid), 0);\n        assert_eq!(pdf_is_name(0, invalid), 0);\n        assert_eq!(pdf_is_string(0, invalid), 0);\n        assert_eq!(pdf_is_array(0, invalid), 0);\n        assert_eq!(pdf_is_dict(0, invalid), 0);\n        assert_eq!(pdf_is_indirect(0, invalid), 0);\n        assert_eq!(pdf_is_stream(0, invalid), 0);\n    }\n\n    #[test]\n    fn test_value_extraction_wrong_type() {\n        let str_obj = pdf_new_string(0, b\"test\".as_ptr() as *const c_char, 4);\n\n        assert_eq!(pdf_to_bool(0, str_obj), 0);\n        assert_eq!(pdf_to_int(0, str_obj), 0);\n        assert_eq!(pdf_to_int64(0, str_obj), 0);\n        assert!((pdf_to_real(0, str_obj) - 0.0).abs() \u003c 0.01);\n        assert_eq!(pdf_to_num(0, str_obj), 0);\n        assert_eq!(pdf_to_gen(0, str_obj), 0);\n    }\n\n    // ============================================================================\n    // PdfObjType Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_obj_type_shallow_eq() {\n        // Same string values\n        let s1 = PdfObjType::String(b\"hello\".to_vec());\n        let s2 = PdfObjType::String(b\"hello\".to_vec());\n        assert!(s1.shallow_eq(\u0026s2));\n\n        // Different string values\n        let s3 = PdfObjType::String(b\"world\".to_vec());\n        assert!(!s1.shallow_eq(\u0026s3));\n\n        // Arrays with same length\n        let a1 = PdfObjType::Array(vec![PdfObj::new_int(1)]);\n        let a2 = PdfObjType::Array(vec![PdfObj::new_int(2)]);\n        assert!(a1.shallow_eq(\u0026a2)); // Only checks length\n\n        // Dicts with same length\n        let d1 = PdfObjType::Dict(vec![(\"key\".to_string(), PdfObj::new_int(1))]);\n        let d2 = PdfObjType::Dict(vec![(\"other\".to_string(), PdfObj::new_int(2))]);\n        assert!(d1.shallow_eq(\u0026d2)); // Only checks length\n\n        // Indirect refs\n        let i1 = PdfObjType::Indirect { num: 1, generation: 0 };\n        let i2 = PdfObjType::Indirect { num: 1, generation: 0 };\n        let i3 = PdfObjType::Indirect { num: 2, generation: 0 };\n        assert!(i1.shallow_eq(\u0026i2));\n        assert!(!i1.shallow_eq(\u0026i3));\n\n        // Streams never match\n        let st1 = PdfObjType::Stream { dict: Box::new(PdfObj::new_dict(0)), data: vec![] };\n        let st2 = PdfObjType::Stream { dict: Box::new(PdfObj::new_dict(0)), data: vec![] };\n        assert!(!st1.shallow_eq(\u0026st2));\n\n        // Different types\n        let null = PdfObjType::Null;\n        let int = PdfObjType::Int(42);\n        assert!(!null.shallow_eq(\u0026int));\n    }\n\n    #[test]\n    fn test_pdf_obj_new_functions() {\n        let null = PdfObj::new_null();\n        assert!(matches!(null.obj_type, PdfObjType::Null));\n        assert!(!null.marked);\n        assert!(!null.dirty);\n        assert_eq!(null.refs, 1);\n\n        let arr = PdfObj::new_array(5);\n        if let PdfObjType::Array(a) = \u0026arr.obj_type {\n            assert!(a.capacity() \u003e= 5);\n        } else {\n            panic!(\"Expected array\");\n        }\n\n        let dict = PdfObj::new_dict(3);\n        if let PdfObjType::Dict(d) = \u0026dict.obj_type {\n            assert!(d.capacity() \u003e= 3);\n        } else {\n            panic!(\"Expected dict\");\n        }\n\n        let indirect = PdfObj::new_indirect(10, 2);\n        if let PdfObjType::Indirect { num, generation } = \u0026indirect.obj_type {\n            assert_eq!(*num, 10);\n            assert_eq!(*generation, 2);\n        } else {\n            panic!(\"Expected indirect\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[1442464,1442560],"length":1,"stats":{"Line":1}},{"line":32,"address":[1549122,1549047],"length":1,"stats":{"Line":2}},{"line":34,"address":[1443019],"length":1,"stats":{"Line":1}},{"line":35,"address":[1549637],"length":1,"stats":{"Line":1}},{"line":36,"address":[1549689],"length":1,"stats":{"Line":0}},{"line":37,"address":[1443210],"length":1,"stats":{"Line":0}},{"line":38,"address":[1443265],"length":1,"stats":{"Line":1}},{"line":39,"address":[1443326],"length":1,"stats":{"Line":1}},{"line":40,"address":[1443412],"length":1,"stats":{"Line":1}},{"line":41,"address":[1443498],"length":1,"stats":{"Line":1}},{"line":42,"address":[1550121],"length":1,"stats":{"Line":1}},{"line":45,"address":[1443071],"length":1,"stats":{"Line":1}},{"line":61,"address":[1550192],"length":1,"stats":{"Line":2}},{"line":71,"address":[1443728],"length":1,"stats":{"Line":1}},{"line":73,"address":[1443743],"length":1,"stats":{"Line":1}},{"line":81,"address":[1443824],"length":1,"stats":{"Line":2}},{"line":83,"address":[1550376],"length":1,"stats":{"Line":2}},{"line":91,"address":[1550464],"length":1,"stats":{"Line":1}},{"line":93,"address":[1443929],"length":1,"stats":{"Line":1}},{"line":101,"address":[1550560],"length":1,"stats":{"Line":1}},{"line":103,"address":[1444039],"length":1,"stats":{"Line":1}},{"line":111,"address":[1444176],"length":1,"stats":{"Line":1}},{"line":113,"address":[1444199],"length":1,"stats":{"Line":2}},{"line":121,"address":[1444336],"length":1,"stats":{"Line":1}},{"line":123,"address":[1444355],"length":1,"stats":{"Line":2}},{"line":131,"address":[1444496],"length":1,"stats":{"Line":1}},{"line":133,"address":[1444515],"length":1,"stats":{"Line":2}},{"line":141,"address":[1444656],"length":1,"stats":{"Line":1}},{"line":143,"address":[1444667],"length":1,"stats":{"Line":1}},{"line":163,"address":[1444752,1444784,1444831],"length":1,"stats":{"Line":1}},{"line":164,"address":[1444790,1444761],"length":1,"stats":{"Line":3}},{"line":168,"address":[1444904,1444963,1444864],"length":1,"stats":{"Line":1}},{"line":169,"address":[1551425,1551454],"length":1,"stats":{"Line":2}},{"line":173,"address":[1445050,1445102,1445008],"length":1,"stats":{"Line":1}},{"line":174,"address":[1445027,1445061],"length":1,"stats":{"Line":3}},{"line":178,"address":[1445136,1445180,1445237],"length":1,"stats":{"Line":1}},{"line":179,"address":[1445157,1445192],"length":1,"stats":{"Line":2}},{"line":183,"address":[1445590,1445336,1445280],"length":1,"stats":{"Line":1}},{"line":184,"address":[1445321,1445346],"length":1,"stats":{"Line":2}},{"line":185,"address":[1445374,1445641],"length":1,"stats":{"Line":2}},{"line":188,"address":[1445410,1445357],"length":1,"stats":{"Line":2}},{"line":191,"address":[1445509,1445623],"length":1,"stats":{"Line":2}},{"line":195,"address":[1445712,1445781,1445988],"length":1,"stats":{"Line":1}},{"line":196,"address":[1445766,1445791],"length":1,"stats":{"Line":2}},{"line":197,"address":[1445808,1446039],"length":1,"stats":{"Line":2}},{"line":200,"address":[1445844],"length":1,"stats":{"Line":1}},{"line":201,"address":[1552481,1552379],"length":1,"stats":{"Line":2}},{"line":205,"address":[1552873,1552560,1552612],"length":1,"stats":{"Line":1}},{"line":206,"address":[1446153,1446178],"length":1,"stats":{"Line":2}},{"line":207,"address":[1552650,1552941],"length":1,"stats":{"Line":2}},{"line":210,"address":[1446189,1446242],"length":1,"stats":{"Line":2}},{"line":213,"address":[1446341,1446482],"length":1,"stats":{"Line":2}},{"line":217,"address":[1553089,1553041,1552992],"length":1,"stats":{"Line":1}},{"line":218,"address":[1446643,1446606],"length":1,"stats":{"Line":2}},{"line":222,"address":[1553245,1553136,1553177],"length":1,"stats":{"Line":1}},{"line":223,"address":[1553187,1553158],"length":1,"stats":{"Line":2}},{"line":227,"address":[1553389,1553280,1553321],"length":1,"stats":{"Line":1}},{"line":228,"address":[1446902,1446935],"length":1,"stats":{"Line":2}},{"line":236,"address":[1447085,1447040,1447511,1447536],"length":1,"stats":{"Line":1}},{"line":237,"address":[1447101,1447062],"length":1,"stats":{"Line":2}},{"line":238,"address":[1447248,1447294,1447165],"length":1,"stats":{"Line":3}},{"line":239,"address":[1553673,1553721,1553759],"length":1,"stats":{"Line":2}},{"line":246,"address":[1553967,1554405,1553920,1554514],"length":1,"stats":{"Line":1}},{"line":247,"address":[1447651,1447612],"length":1,"stats":{"Line":2}},{"line":249,"address":[1554431,1554048,1554122,1554155],"length":1,"stats":{"Line":3}},{"line":250,"address":[1554187,1554287,1554241],"length":1,"stats":{"Line":2}},{"line":251,"address":[1554275,1554312],"length":1,"stats":{"Line":2}},{"line":253,"address":[1554426],"length":1,"stats":{"Line":0}},{"line":256,"address":[1554396],"length":1,"stats":{"Line":1}},{"line":257,"address":[1448168],"length":1,"stats":{"Line":1}},{"line":266,"address":[1402116,1408165,1408720,1408434,1409037,1403600,1404048,1407968,1402549,1409477,1404725,1401781,1406656,1409701,1401344,1401808,1408192,1404501,1409280,1403824,1405717,1409925,1404021,1405060,1402818,1403583,1403088,1403285,1403797,1405296,1405744,1406416,1406927,1409008,1402128,1409056,1403554,1406632,1402325,1409253,1401104,1407186,1407727,1405031,1402576,1405072,1407941,1402087,1404752,1408480,1409728,1405952,1402847,1407456,1404528,1405269,1401559,1402864,1403312,1406192,1406944,1407744,1402352,1404278,1405968,1407429,1406389,1407698,1408463,1407232,1407215,1409504,1406898,1401584,1404304,1401320,1405520,1408768,1408749,1405493,1406165,1403061],"length":1,"stats":{"Line":38}},{"line":267,"address":[1402699,1401949,1402039,1409156,1405768,1402374,1403461,1406805,1409630,1406853,1405620,1408224,1402773,1407067,1408512,1406561,1401285,1408315,1409666,1407141,1402725,1405990,1406094,1406130,1403344,1409604,1408341,1402886,1404920,1405172,1407906,1404404,1402990,1403986,1404197,1402452,1404326,1405396,1401520,1406530,1407653,1402608,1401136,1405234,1401478,1403700,1408800,1409828,1404550,1407358,1403726,1403026,1404239,1406448,1406214,1401606,1408675,1404893,1406597,1402254,1405850,1408130,1402514,1403435,1409302,1404466,1405542,1407332,1409406,1409854,1405198,1409890,1403924,1404983,1401710,1407990,1407605,1404787,1401746,1408389,1405422,1403846,1408963,1405458,1407579,1404430,1408603,1405094,1406688,1405646,1407093,1403509,1404628,1404166,1405682,1405318,1407254,1406354,1402150,1401218,1402228,1404654,1406779,1404690,1406068,1409218,1408094,1403110,1406976,1401684,1407394,1407488,1409078,1408068,1406318,1408627,1401370,1401843,1403188,1401452,1405917,1402964,1408915,1401976,1409182,1408891,1404084,1409380,1403214,1402290,1407844,1403762,1407870,1403950,1403250,1401249,1407766,1402478,1409442,1409526,1406292,1409750,1405876,1403622],"length":1,"stats":{"Line":151}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[1416189,1416521,1419858,1420850,1412729,1411472,1417264,1424874,1420160,1420218,1418025,1404192,1414985,1415744,1418272,1410958,1416265,1410637,1419073,1420336,1422689,1411968,1422818,1410457,1416256,1420992,1424640,1421842,1422978,1411721,1420832,1418542,1420018,1422033,1424843,1410448,1413251,1412208,1415165,1402985,1409971,1414915,1418784,1419042,1419520,1413968,1421168,1423338,1414157,1424480,1409177,1418016,1413649,1413721,1412720,1414976,1415241,1423169,1419840,1416000,1423505,1414413,1422464,1420187,1416445,1402249,1424155,1405871,1403456,1414729,1418727,1416777,1423009,1423456,1411901,1411405,1414657,1424529,1413491,1424186,1424667,1412976,1418803,1417201,1423616,1411216,1418961,1411712,1415753,1417959,1422162,1411649,1415933,1417693,1407353,1404912,1410201,1424017,1416706,1413165,1420683,1424816,1419242,1410381,1410881,1419409,1410704,1410192,1413977,1422658,1414224,1415677,1422144,1421019,1424128,1422304,1419538,1403721,1412985,1417043,1421226,1424304,1419698,1423307,1409625,1404649,1413472,1404425,1412217,1412653,1401473,1413232,1418528,1419184,1418281,1419211,1416957,1422193,1422640,1414480,1403945,1417441,1421195,1412145,1417513,1423474,1421984,1402473,1421393,1423986,1406089,1421664,1421713,1407088,1419024,1419569,1422353,1422322,1405417,1420881,1402720,1419889,1421873,1412397,1416512,1401705,1415421,1417024,1412909,1421050,1423120,1415497,1423138,1408622,1416768,1421504,1421522,1420545,1424498,1415488,1409952,1423280,1416009,1417760,1403209,1414499,1420354,1421344,1414233,1422800,1417283,1423792,1401244,1405193,1417774,1408089,1420000,1419360,1419378,1421824,1413409,1423968,1418461,1418205,1422960,1421362,1423643,1401968,1410129,1420385,1421682,1408910,1405641,1412464,1406800,1411225,1412473,1411491,1410944,1413901,1424331,1406313,1423819,1421553,1420656,1411149,1419680,1415232,1413712,1423850,1414720,1420496,1407600,1420514,1420714,1422491,1422522,1422849,1424362,1409401,1424698,1417504,1419729,1422002,1409849,1420049,1407865,1408336,1410723,1411987,1423674,1406556],"length":1,"stats":{"Line":193}},{"line":270,"address":[2179553,2183795,2184954,2185841,2182864,2185361,2179761,2186480,2186683,2180801,2186049,2182595,2180177,2183569,2184478,2181473,2180593,2183361,2184257,2185153,2179969,2181907,2184721,2182161,2180385,2179299,2181681,2182376,2185587,2184049,2181230,2183094,2186257,2181009,2186918,2179027],"length":1,"stats":{"Line":39}},{"line":273,"address":[2202272,2200784,2201614,2201230,2203806,2203421,2201423,2203007,2203213,2203232,2202654,2202672,2202848,2200973,2203614,2201264,2201888,2202080,2202062,2202453,2203024,2203440,2202480,2201632,2202254,2202831,2200992,2201858,2203632,2201440],"length":1,"stats":{"Line":15}},{"line":274,"address":[2200944,2203184,2201394,2203464,2203757,2201654,2201278,2202958,2203392,2202104,2201374,2201912,2202686,2202205,2201738,2202368,2202294,2203058,2200818,2201816,2203730,2201101,2202225,2202625,2201796,2203132,2201585,2203538,2200892,2200924,2202504,2203777,2202422,2201986,2203164,2202802,2202936,2202178,2203340,2201565,2202390,2202862,2201188,2201168,2201352,2203585,2202013,2202033,2201464,2201014,2202760,2202782,2202605,2202978,2203372,2203656,2203266,2203565,2202578,2201538],"length":1,"stats":{"Line":60}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[2201369,2205648,2207969,2209136,2202600,2205891,2209280,2207382,2203976,2205232,2205810,2206472,2204512,2204945,2207168,2206034,2207328,2203838,2203367,2205449,2206115,2206528,2206258,2207112,2207506,2207846,2208144,2208464,2208509,2208687,2208864,2207533,2207632,2209181,2209317,2209520,2207686,2204521,2201760,2206974,2207195,2208304,2208331,2208608,2204862,2208800,2209344,2207659,2204729,2205657,2208022,2208625,2207222,2206904,2202200,2206320,2202385,2206690,2207488,2202777,2207819,2208482,2201560,2205246,2206096,2204456,2207355,2209493,2204318,2205440,2203159,2208171,2204928,2206960,2200919,2201123,2204032,2204049,2209021,2202008,2205384,2204654,2208358,2203752,2204720,2203560,2206334,2206752,2209154,2209456,2203824,2206766,2202953,2206547,2208837,2207792,2208198,2204304,2208976,2208994,2205872,2205582,2207952],"length":1,"stats":{"Line":75}},{"line":277,"address":[2201389,2202620,2202797,2203772,2202973,2201811,2202417,2202028,2203387,2203580,2202220,2200939,2201580,2203179,2201183],"length":1,"stats":{"Line":15}},{"line":285,"address":[1554560,1554603],"length":1,"stats":{"Line":1}},{"line":286,"address":[2209632,2209641],"length":1,"stats":{"Line":3}},{"line":290,"address":[1554624,1554664],"length":1,"stats":{"Line":1}},{"line":291,"address":[1448381],"length":1,"stats":{"Line":3}},{"line":295,"address":[1448416,1448456],"length":1,"stats":{"Line":1}},{"line":296,"address":[1434640,1434649],"length":1,"stats":{"Line":3}},{"line":300,"address":[1448520,1448480],"length":1,"stats":{"Line":1}},{"line":301,"address":[2209833,2209824],"length":1,"stats":{"Line":3}},{"line":305,"address":[1448544,1448584],"length":1,"stats":{"Line":1}},{"line":306,"address":[1448573],"length":1,"stats":{"Line":2}},{"line":307,"address":[1434777],"length":1,"stats":{"Line":1}},{"line":312,"address":[1554920,1554880],"length":1,"stats":{"Line":1}},{"line":313,"address":[1434873,1434864],"length":1,"stats":{"Line":3}},{"line":317,"address":[1448672,1448712],"length":1,"stats":{"Line":2}},{"line":318,"address":[2210057,2210048],"length":1,"stats":{"Line":6}},{"line":322,"address":[1555048,1555008],"length":1,"stats":{"Line":1}},{"line":323,"address":[1448765],"length":1,"stats":{"Line":3}},{"line":327,"address":[1555072,1555112],"length":1,"stats":{"Line":1}},{"line":328,"address":[1555101],"length":1,"stats":{"Line":3}},{"line":332,"address":[1448864,1448904],"length":1,"stats":{"Line":1}},{"line":333,"address":[1555165],"length":1,"stats":{"Line":3}},{"line":337,"address":[1448928,1448968],"length":1,"stats":{"Line":1}},{"line":338,"address":[1555229],"length":1,"stats":{"Line":3}},{"line":346,"address":[1555264,1555304],"length":1,"stats":{"Line":1}},{"line":347,"address":[1555293],"length":1,"stats":{"Line":5}},{"line":348,"address":[1435302],"length":1,"stats":{"Line":1}},{"line":349,"address":[1435333],"length":1,"stats":{"Line":1}},{"line":354,"address":[1555328,1555368],"length":1,"stats":{"Line":1}},{"line":355,"address":[1449085],"length":1,"stats":{"Line":5}},{"line":356,"address":[1435443],"length":1,"stats":{"Line":1}},{"line":357,"address":[1435470],"length":1,"stats":{"Line":0}},{"line":358,"address":[1435428],"length":1,"stats":{"Line":1}},{"line":363,"address":[1449120,1449163],"length":1,"stats":{"Line":2}},{"line":364,"address":[1555423],"length":1,"stats":{"Line":5}},{"line":365,"address":[1435620],"length":1,"stats":{"Line":1}},{"line":366,"address":[1435648],"length":1,"stats":{"Line":0}},{"line":367,"address":[1435604],"length":1,"stats":{"Line":1}},{"line":372,"address":[1449227,1449184],"length":1,"stats":{"Line":1}},{"line":373,"address":[1555486],"length":1,"stats":{"Line":3}},{"line":374,"address":[2210963],"length":1,"stats":{"Line":1}},{"line":375,"address":[1435812],"length":1,"stats":{"Line":0}},{"line":376,"address":[1435796],"length":1,"stats":{"Line":1}},{"line":381,"address":[1435907,1435888],"length":1,"stats":{"Line":2}},{"line":384,"address":[1555583,1555520,1556247],"length":1,"stats":{"Line":1}},{"line":387,"address":[1449271],"length":1,"stats":{"Line":3}},{"line":388,"address":[2211134],"length":1,"stats":{"Line":1}},{"line":389,"address":[1436072],"length":1,"stats":{"Line":1}},{"line":392,"address":[1449339],"length":1,"stats":{"Line":1}},{"line":393,"address":[1449373],"length":1,"stats":{"Line":1}},{"line":394,"address":[1555800,1556496,1555668,1555745],"length":1,"stats":{"Line":3}},{"line":395,"address":[1449648,1449580],"length":1,"stats":{"Line":2}},{"line":396,"address":[1449756,1449673],"length":1,"stats":{"Line":2}},{"line":397,"address":[1449856,1449786],"length":1,"stats":{"Line":2}},{"line":399,"address":[1556230],"length":1,"stats":{"Line":1}},{"line":401,"address":[1450234],"length":1,"stats":{"Line":0}},{"line":404,"address":[1555692],"length":1,"stats":{"Line":1}},{"line":409,"address":[1450328,1450288],"length":1,"stats":{"Line":1}},{"line":410,"address":[1450317],"length":1,"stats":{"Line":3}},{"line":411,"address":[1436146],"length":1,"stats":{"Line":1}},{"line":412,"address":[1436167],"length":1,"stats":{"Line":1}},{"line":417,"address":[1450352,1450392],"length":1,"stats":{"Line":1}},{"line":418,"address":[1450381],"length":1,"stats":{"Line":4}},{"line":419,"address":[2211362],"length":1,"stats":{"Line":1}},{"line":420,"address":[1436263],"length":1,"stats":{"Line":1}},{"line":429,"address":[1556691,1556640],"length":1,"stats":{"Line":1}},{"line":430,"address":[1436306,1436288],"length":1,"stats":{"Line":3}},{"line":431,"address":[2211465],"length":1,"stats":{"Line":1}},{"line":432,"address":[2211496],"length":1,"stats":{"Line":1}},{"line":437,"address":[1556771,1556720],"length":1,"stats":{"Line":1}},{"line":438,"address":[1450527],"length":1,"stats":{"Line":3}},{"line":439,"address":[2211611],"length":1,"stats":{"Line":1}},{"line":440,"address":[2211638],"length":1,"stats":{"Line":1}},{"line":441,"address":[1436473],"length":1,"stats":{"Line":1}},{"line":446,"address":[1556857,1556800],"length":1,"stats":{"Line":1}},{"line":447,"address":[1450609],"length":1,"stats":{"Line":3}},{"line":448,"address":[1436718],"length":1,"stats":{"Line":1}},{"line":449,"address":[1436687],"length":1,"stats":{"Line":1}},{"line":450,"address":[1436665],"length":1,"stats":{"Line":1}},{"line":459,"address":[1556880,1556920],"length":1,"stats":{"Line":1}},{"line":460,"address":[2211886,2211872],"length":1,"stats":{"Line":3}},{"line":461,"address":[2211926],"length":1,"stats":{"Line":1}},{"line":462,"address":[2211946],"length":1,"stats":{"Line":1}},{"line":467,"address":[1450720,1450807],"length":1,"stats":{"Line":1}},{"line":468,"address":[2211968,2211987],"length":1,"stats":{"Line":4}},{"line":470,"address":[1450843],"length":1,"stats":{"Line":1}},{"line":471,"address":[1450926,1451022],"length":1,"stats":{"Line":3}},{"line":472,"address":[1436931],"length":1,"stats":{"Line":1}},{"line":473,"address":[1437000],"length":1,"stats":{"Line":1}},{"line":474,"address":[2212167],"length":1,"stats":{"Line":1}},{"line":481,"address":[1557296,1557340],"length":1,"stats":{"Line":1}},{"line":482,"address":[1437088],"length":1,"stats":{"Line":2}},{"line":483,"address":[1437107],"length":1,"stats":{"Line":1}},{"line":484,"address":[1437160],"length":1,"stats":{"Line":1}},{"line":485,"address":[2212324],"length":1,"stats":{"Line":1}},{"line":491,"address":[1557405,1557360],"length":1,"stats":{"Line":1}},{"line":492,"address":[1557398],"length":1,"stats":{"Line":2}},{"line":493,"address":[1437235],"length":1,"stats":{"Line":1}},{"line":494,"address":[1437288],"length":1,"stats":{"Line":1}},{"line":495,"address":[1437335],"length":1,"stats":{"Line":1}},{"line":501,"address":[1557467,1557424],"length":1,"stats":{"Line":1}},{"line":502,"address":[1437344],"length":1,"stats":{"Line":2}},{"line":503,"address":[1437363],"length":1,"stats":{"Line":1}},{"line":504,"address":[1437416],"length":1,"stats":{"Line":1}},{"line":505,"address":[2212589],"length":1,"stats":{"Line":1}},{"line":511,"address":[1557488,1557531],"length":1,"stats":{"Line":1}},{"line":512,"address":[1451300],"length":1,"stats":{"Line":2}},{"line":513,"address":[2212627],"length":1,"stats":{"Line":1}},{"line":514,"address":[1437560],"length":1,"stats":{"Line":1}},{"line":515,"address":[2212766,2212698],"length":1,"stats":{"Line":2}},{"line":516,"address":[1437611],"length":1,"stats":{"Line":1}},{"line":517,"address":[2212762],"length":1,"stats":{"Line":1}},{"line":528,"address":[1451328,1451368],"length":1,"stats":{"Line":1}},{"line":529,"address":[1451357],"length":1,"stats":{"Line":3}},{"line":530,"address":[1437718],"length":1,"stats":{"Line":1}},{"line":531,"address":[1437739],"length":1,"stats":{"Line":1}},{"line":536,"address":[1557616,1558197,1558225,1557702],"length":1,"stats":{"Line":1}},{"line":542,"address":[1451459,1451492],"length":1,"stats":{"Line":2}},{"line":547,"address":[1451538,1451503],"length":1,"stats":{"Line":2}},{"line":552,"address":[2212883,2212864],"length":1,"stats":{"Line":4}},{"line":554,"address":[1557926],"length":1,"stats":{"Line":1}},{"line":555,"address":[2213584,2212928,2213559],"length":1,"stats":{"Line":3}},{"line":556,"address":[1438306,1437849],"length":1,"stats":{"Line":2}},{"line":557,"address":[1437922,1438544,1438558,1438013],"length":1,"stats":{"Line":2}},{"line":558,"address":[1438228,1438144],"length":1,"stats":{"Line":0}},{"line":560,"address":[1438321,1438201],"length":1,"stats":{"Line":2}},{"line":562,"address":[1438302],"length":1,"stats":{"Line":1}},{"line":569,"address":[1452095,1452032,1452300,1452328],"length":1,"stats":{"Line":1}},{"line":570,"address":[1452105,1452080],"length":1,"stats":{"Line":2}},{"line":575,"address":[1558355,1558320],"length":1,"stats":{"Line":2}},{"line":580,"address":[1558436],"length":1,"stats":{"Line":2}},{"line":581,"address":[1438627],"length":1,"stats":{"Line":1}},{"line":582,"address":[2213776,2213748,2213790],"length":1,"stats":{"Line":3}},{"line":583,"address":[1438692],"length":1,"stats":{"Line":1}},{"line":589,"address":[1558836,1558544,1558629],"length":1,"stats":{"Line":1}},{"line":595,"address":[2213863,2213840],"length":1,"stats":{"Line":3}},{"line":596,"address":[2213902],"length":1,"stats":{"Line":1}},{"line":597,"address":[2213960],"length":1,"stats":{"Line":1}},{"line":600,"address":[1558662],"length":1,"stats":{"Line":1}},{"line":601,"address":[2214663,2214688,2213984],"length":1,"stats":{"Line":2}},{"line":602,"address":[2214499,2214014],"length":1,"stats":{"Line":2}},{"line":603,"address":[2214079],"length":1,"stats":{"Line":1}},{"line":604,"address":[2214704,2214718,2214110,2214186],"length":1,"stats":{"Line":4}},{"line":605,"address":[1439354,1439263],"length":1,"stats":{"Line":1}},{"line":607,"address":[1439325,1439457],"length":1,"stats":{"Line":2}},{"line":609,"address":[1439435],"length":1,"stats":{"Line":1}},{"line":616,"address":[1452672,1452758,1452965],"length":1,"stats":{"Line":1}},{"line":622,"address":[2214791,2214768],"length":1,"stats":{"Line":3}},{"line":623,"address":[2214830],"length":1,"stats":{"Line":1}},{"line":624,"address":[2214888],"length":1,"stats":{"Line":0}},{"line":627,"address":[1452791],"length":1,"stats":{"Line":1}},{"line":628,"address":[1439872,1440576,1440605],"length":1,"stats":{"Line":2}},{"line":629,"address":[2214942,2215428],"length":1,"stats":{"Line":2}},{"line":630,"address":[1439967],"length":1,"stats":{"Line":1}},{"line":631,"address":[2215039,2215115,2215646,2215632],"length":1,"stats":{"Line":4}},{"line":632,"address":[1440315,1440224],"length":1,"stats":{"Line":0}},{"line":634,"address":[2215438,2215306],"length":1,"stats":{"Line":2}},{"line":636,"address":[1440396],"length":1,"stats":{"Line":1}},{"line":643,"address":[1559507,1559300,1559216],"length":1,"stats":{"Line":1}},{"line":649,"address":[1559263],"length":1,"stats":{"Line":3}},{"line":650,"address":[1440750],"length":1,"stats":{"Line":1}},{"line":651,"address":[2215816],"length":1,"stats":{"Line":0}},{"line":654,"address":[1453125],"length":1,"stats":{"Line":1}},{"line":655,"address":[1441571,1440832,1441542],"length":1,"stats":{"Line":2}},{"line":656,"address":[2215870,2216362],"length":1,"stats":{"Line":2}},{"line":657,"address":[1440927],"length":1,"stats":{"Line":1}},{"line":658,"address":[1440969,1441598,1441584,1441049],"length":1,"stats":{"Line":4}},{"line":659,"address":[2216182,2216269],"length":1,"stats":{"Line":0}},{"line":661,"address":[2216372,2216240],"length":1,"stats":{"Line":2}},{"line":663,"address":[2216350],"length":1,"stats":{"Line":1}},{"line":674,"address":[1453344,1453384],"length":1,"stats":{"Line":1}},{"line":675,"address":[1453373],"length":1,"stats":{"Line":3}},{"line":679,"address":[1453448,1453408],"length":1,"stats":{"Line":1}},{"line":680,"address":[1559645],"length":1,"stats":{"Line":2}},{"line":681,"address":[1441689],"length":1,"stats":{"Line":1}},{"line":682,"address":[1441701],"length":1,"stats":{"Line":1}},{"line":683,"address":[2216681],"length":1,"stats":{"Line":1}},{"line":688,"address":[1453504,1453472],"length":1,"stats":{"Line":1}},{"line":689,"address":[1559705],"length":1,"stats":{"Line":2}},{"line":690,"address":[2216709],"length":1,"stats":{"Line":1}},{"line":699,"address":[1559768,1559728],"length":1,"stats":{"Line":1}},{"line":700,"address":[1559757],"length":1,"stats":{"Line":3}},{"line":704,"address":[1559792,1559824],"length":1,"stats":{"Line":1}},{"line":705,"address":[1441776],"length":1,"stats":{"Line":2}},{"line":706,"address":[2216757],"length":1,"stats":{"Line":1}},{"line":711,"address":[1453632,1453664],"length":1,"stats":{"Line":1}},{"line":712,"address":[1441792],"length":1,"stats":{"Line":2}},{"line":713,"address":[1441797],"length":1,"stats":{"Line":1}},{"line":722,"address":[1559931,1559888],"length":1,"stats":{"Line":1}},{"line":723,"address":[1441808],"length":1,"stats":{"Line":2}},{"line":724,"address":[1441818],"length":1,"stats":{"Line":1}},{"line":729,"address":[1453744,1453784],"length":1,"stats":{"Line":1}},{"line":730,"address":[2216821,2216816],"length":1,"stats":{"Line":3}},{"line":734,"address":[1560056,1560016],"length":1,"stats":{"Line":1}},{"line":735,"address":[2216837,2216832],"length":1,"stats":{"Line":3}},{"line":743,"address":[1560080,1560852,1560172],"length":1,"stats":{"Line":1}},{"line":744,"address":[1560116,1560205],"length":1,"stats":{"Line":4}},{"line":745,"address":[2216947,2216928],"length":1,"stats":{"Line":3}},{"line":747,"address":[1560289],"length":1,"stats":{"Line":1}},{"line":748,"address":[1454360],"length":1,"stats":{"Line":1}},{"line":749,"address":[1454347],"length":1,"stats":{"Line":1}},{"line":754,"address":[1455020,1454928,1455652],"length":1,"stats":{"Line":1}},{"line":755,"address":[1561140],"length":1,"stats":{"Line":3}},{"line":756,"address":[2217070],"length":1,"stats":{"Line":1}},{"line":757,"address":[2217128],"length":1,"stats":{"Line":1}},{"line":760,"address":[1442199,1442176],"length":1,"stats":{"Line":3}},{"line":761,"address":[1442238],"length":1,"stats":{"Line":1}},{"line":762,"address":[1442296],"length":1,"stats":{"Line":1}},{"line":765,"address":[1455131],"length":1,"stats":{"Line":1}},{"line":766,"address":[1455362],"length":1,"stats":{"Line":1}},{"line":767,"address":[1455349],"length":1,"stats":{"Line":1}}],"covered":276,"coverable":290},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","pixmap.rs"],"content":"//! C FFI for pixmap - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, PIXMAPS};\nuse super::geometry::fz_irect;\nuse super::colorspace::{ColorspaceHandle, FZ_COLORSPACE_RGB};\n\n/// Internal pixmap state\npub struct Pixmap {\n    x: i32,\n    y: i32,\n    width: i32,\n    height: i32,\n    n: i32,        // Number of components\n    alpha: bool,\n    stride: i32,\n    samples: Vec\u003cu8\u003e,\n    colorspace: ColorspaceHandle,\n}\n\nimpl Pixmap {\n    pub fn new(cs: ColorspaceHandle, width: i32, height: i32, alpha: bool) -\u003e Self {\n        let n = super::colorspace::fz_colorspace_n(0, cs) + i32::from(alpha);\n        let stride = width * n;\n        let size = (stride * height) as usize;\n\n        Self {\n            x: 0,\n            y: 0,\n            width,\n            height,\n            n,\n            alpha,\n            stride,\n            samples: vec![0u8; size],\n            colorspace: cs,\n        }\n    }\n\n    pub fn with_bbox(cs: ColorspaceHandle, bbox: fz_irect, alpha: bool) -\u003e Self {\n        let width = bbox.x1 - bbox.x0;\n        let height = bbox.y1 - bbox.y0;\n        let n = super::colorspace::fz_colorspace_n(0, cs) + i32::from(alpha);\n        let stride = width * n;\n        let size = (stride * height).max(0) as usize;\n\n        Self {\n            x: bbox.x0,\n            y: bbox.y0,\n            width,\n            height,\n            n,\n            alpha,\n            stride,\n            samples: vec![0u8; size],\n            colorspace: cs,\n        }\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.samples.fill(0);\n    }\n\n    pub fn clear_with_value(\u0026mut self, value: u8) {\n        self.samples.fill(value);\n    }\n\n    pub fn get_sample(\u0026self, x: i32, y: i32, component: i32) -\u003e Option\u003cu8\u003e {\n        if x \u003c self.x || x \u003e= self.x + self.width ||\n           y \u003c self.y || y \u003e= self.y + self.height ||\n           component \u003c 0 || component \u003e= self.n {\n            return None;\n        }\n        let local_x = x - self.x;\n        let local_y = y - self.y;\n        let offset = (local_y * self.stride + local_x * self.n + component) as usize;\n        self.samples.get(offset).copied()\n    }\n\n    pub fn set_sample(\u0026mut self, x: i32, y: i32, component: i32, value: u8) {\n        if x \u003c self.x || x \u003e= self.x + self.width ||\n           y \u003c self.y || y \u003e= self.y + self.height ||\n           component \u003c 0 || component \u003e= self.n {\n            return;\n        }\n        let local_x = x - self.x;\n        let local_y = y - self.y;\n        let offset = (local_y * self.stride + local_x * self.n + component) as usize;\n        if let Some(sample) = self.samples.get_mut(offset) {\n            *sample = value;\n        }\n    }\n}\n\n/// Create a new pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_pixmap(\n    _ctx: Handle,\n    cs: ColorspaceHandle,\n    w: i32,\n    h: i32,\n    _seps: Handle, // Separations not implemented yet\n    alpha: i32,\n) -\u003e Handle {\n    let cs = if cs == 0 { FZ_COLORSPACE_RGB } else { cs };\n    PIXMAPS.insert(Pixmap::new(cs, w, h, alpha != 0))\n}\n\n/// Create a new pixmap with bounding box\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_pixmap_with_bbox(\n    _ctx: Handle,\n    cs: ColorspaceHandle,\n    bbox: fz_irect,\n    _seps: Handle,\n    alpha: i32,\n) -\u003e Handle {\n    let cs = if cs == 0 { FZ_COLORSPACE_RGB } else { cs };\n    PIXMAPS.insert(Pixmap::with_bbox(cs, bbox, alpha != 0))\n}\n\n/// Keep (increment ref) pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_pixmap(_ctx: Handle, pix: Handle) -\u003e Handle {\n    PIXMAPS.keep(pix)\n}\n\n/// Drop pixmap reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_pixmap(_ctx: Handle, pix: Handle) {\n    let _ = PIXMAPS.remove(pix);\n}\n\n/// Get pixmap X origin\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_x(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.x;\n        }\n    }\n    0\n}\n\n/// Get pixmap Y origin\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_y(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.y;\n        }\n    }\n    0\n}\n\n/// Get pixmap width\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_width(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.width;\n        }\n    }\n    0\n}\n\n/// Get pixmap height\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_height(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.height;\n        }\n    }\n    0\n}\n\n/// Get number of components (including alpha)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_components(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.n;\n        }\n    }\n    0\n}\n\n/// Get number of colorants (excluding alpha)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_colorants(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.n - i32::from(guard.alpha);\n        }\n    }\n    0\n}\n\n/// Check if pixmap has alpha\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_alpha(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return i32::from(guard.alpha);\n        }\n    }\n    0\n}\n\n/// Get pixmap stride (bytes per row)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_stride(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.stride;\n        }\n    }\n    0\n}\n\n/// Get pixmap bounding box\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_bbox(_ctx: Handle, pix: Handle) -\u003e fz_irect {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return fz_irect {\n                x0: guard.x,\n                y0: guard.y,\n                x1: guard.x + guard.width,\n                y1: guard.y + guard.height,\n            };\n        }\n    }\n    fz_irect { x0: 0, y0: 0, x1: 0, y1: 0 }\n}\n\n/// Get pixmap colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_colorspace(_ctx: Handle, pix: Handle) -\u003e ColorspaceHandle {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.colorspace;\n        }\n    }\n    0\n}\n\n/// Clear pixmap to transparent black\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_pixmap(_ctx: Handle, pix: Handle) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.clear();\n        }\n    }\n}\n\n/// Clear pixmap to specific value\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_pixmap_with_value(_ctx: Handle, pix: Handle, value: i32) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.clear_with_value(value as u8);\n        }\n    }\n}\n\n/// Invert pixmap colors\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_invert_pixmap(_ctx: Handle, pix: Handle) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            let colorants = (p.n - i32::from(p.alpha)) as usize;\n            for y in 0..p.height {\n                for x in 0..p.width {\n                    let offset = (y * p.stride + x * p.n) as usize;\n                    for c in 0..colorants {\n                        if let Some(sample) = p.samples.get_mut(offset + c) {\n                            *sample = 255 - *sample;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Apply gamma correction to pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_gamma_pixmap(_ctx: Handle, pix: Handle, gamma: f32) {\n    if gamma \u003c= 0.0 {\n        return;\n    }\n\n    // Pre-compute gamma lookup table\n    let mut gamma_table = [0u8; 256];\n    for (i, entry) in gamma_table.iter_mut().enumerate() {\n        let normalized = (i as f32) / 255.0;\n        let corrected = normalized.powf(1.0 / gamma);\n        *entry = (corrected * 255.0).round().clamp(0.0, 255.0) as u8;\n    }\n\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            let colorants = (p.n - i32::from(p.alpha)) as usize;\n            for y in 0..p.height {\n                for x in 0..p.width {\n                    let offset = (y * p.stride + x * p.n) as usize;\n                    for c in 0..colorants {\n                        if let Some(sample) = p.samples.get_mut(offset + c) {\n                            *sample = gamma_table[*sample as usize];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Get sample at specific position\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_get_pixmap_sample(_ctx: Handle, pix: Handle, x: i32, y: i32, n: i32) -\u003e u8 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            if let Some(sample) = guard.get_sample(x, y, n) {\n                return sample;\n            }\n        }\n    }\n    0\n}\n\n/// Set sample at specific position\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_set_pixmap_sample(_ctx: Handle, pix: Handle, x: i32, y: i32, n: i32, v: u8) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.set_sample(x, y, n, v);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use super::super::colorspace::FZ_COLORSPACE_GRAY;\n\n    #[test]\n    fn test_pixmap_create() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 100, 100, 0, 1);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_pixmap_width(0, handle), 100);\n        assert_eq!(fz_pixmap_height(0, handle), 100);\n        assert_eq!(fz_pixmap_components(0, handle), 4); // RGB + alpha\n        assert_eq!(fz_pixmap_alpha(0, handle), 1);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_create_gray() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 50, 50, 0, 0);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_pixmap_components(0, handle), 1); // Gray only\n        assert_eq!(fz_pixmap_colorants(0, handle), 1);\n        assert_eq!(fz_pixmap_alpha(0, handle), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_clear() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        fz_clear_pixmap_with_value(0, handle, 128);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 128);\n\n        fz_clear_pixmap(0, handle);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_set_get_sample() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        fz_set_pixmap_sample(0, handle, 5, 5, 0, 255);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 5, 5, 0), 255);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 5, 5, 1), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_keep() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let kept = fz_keep_pixmap(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_x_y() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        // Default origin is 0,0\n        assert_eq!(fz_pixmap_x(0, handle), 0);\n        assert_eq!(fz_pixmap_y(0, handle), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_stride() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let stride = fz_pixmap_stride(0, handle);\n        // RGB = 3 components, width = 10, so stride = 30\n        assert_eq!(stride, 30);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_stride_with_alpha() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 1);\n        let stride = fz_pixmap_stride(0, handle);\n        // RGBA = 4 components, width = 10, so stride = 40\n        assert_eq!(stride, 40);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_bbox() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 100, 50, 0, 0);\n        let bbox = fz_pixmap_bbox(0, handle);\n        assert_eq!(bbox.x0, 0);\n        assert_eq!(bbox.y0, 0);\n        assert_eq!(bbox.x1, 100);\n        assert_eq!(bbox.y1, 50);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_colorspace() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let cs = fz_pixmap_colorspace(0, handle);\n        assert_eq!(cs, FZ_COLORSPACE_RGB);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_invalid_handle() {\n        assert_eq!(fz_pixmap_width(0, 0), 0);\n        assert_eq!(fz_pixmap_height(0, 0), 0);\n        assert_eq!(fz_pixmap_components(0, 0), 0);\n        assert_eq!(fz_pixmap_x(0, 0), 0);\n        assert_eq!(fz_pixmap_y(0, 0), 0);\n        assert_eq!(fz_pixmap_alpha(0, 0), 0);\n        assert_eq!(fz_pixmap_stride(0, 0), 0);\n        assert_eq!(fz_pixmap_colorants(0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, 0, 0, 0, 0), 0);\n    }\n\n    #[test]\n    fn test_pixmap_invert() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 2, 2, 0, 0);\n\n        // Set to known values\n        fz_set_pixmap_sample(0, handle, 0, 0, 0, 100);\n        fz_set_pixmap_sample(0, handle, 1, 0, 0, 200);\n\n        fz_invert_pixmap(0, handle);\n\n        // Values should be inverted (255 - x)\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 155);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 1, 0, 0), 55);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_gamma() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 2, 2, 0, 0);\n\n        // Set to mid-gray\n        fz_clear_pixmap_with_value(0, handle, 128);\n\n        // Apply gamma (1.0 should not change values significantly)\n        fz_gamma_pixmap(0, handle, 1.0);\n\n        // Value should be roughly the same\n        let sample = fz_get_pixmap_sample(0, handle, 0, 0, 0);\n        assert!(sample \u003e= 125 \u0026\u0026 sample \u003c= 131);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_sample_bounds() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        // Out of bounds access should return 0\n        assert_eq!(fz_get_pixmap_sample(0, handle, -1, 0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, -1, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 10, 0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 10, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 3), 0); // Component out of bounds\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_internal_new() {\n        let pixmap = Pixmap::new(FZ_COLORSPACE_RGB, 100, 50, true);\n        assert_eq!(pixmap.width, 100);\n        assert_eq!(pixmap.height, 50);\n        assert_eq!(pixmap.n, 4); // RGB + alpha\n        assert!(pixmap.alpha);\n        assert_eq!(pixmap.stride, 400); // width * n\n        assert_eq!(pixmap.samples.len(), 400 * 50);\n    }\n\n    #[test]\n    fn test_pixmap_internal_get_set_sample() {\n        let mut pixmap = Pixmap::new(FZ_COLORSPACE_RGB, 10, 10, false);\n\n        pixmap.set_sample(5, 5, 0, 123);\n        assert_eq!(pixmap.get_sample(5, 5, 0), Some(123));\n\n        // Out of bounds\n        assert_eq!(pixmap.get_sample(-1, 0, 0), None);\n        assert_eq!(pixmap.get_sample(100, 0, 0), None);\n    }\n\n    #[test]\n    fn test_pixmap_internal_clear() {\n        let mut pixmap = Pixmap::new(FZ_COLORSPACE_GRAY, 5, 5, false);\n        pixmap.clear_with_value(255);\n\n        assert_eq!(pixmap.get_sample(0, 0, 0), Some(255));\n        assert_eq!(pixmap.get_sample(4, 4, 0), Some(255));\n    }\n}\n","traces":[{"line":22,"address":[1246320],"length":1,"stats":{"Line":3}},{"line":23,"address":[1370869,1370943],"length":1,"stats":{"Line":4}},{"line":24,"address":[1370985,1370929,1370964],"length":1,"stats":{"Line":8}},{"line":25,"address":[1371140,1371001,1370968],"length":1,"stats":{"Line":8}},{"line":35,"address":[1371009],"length":1,"stats":{"Line":11}},{"line":40,"address":[1371168],"length":1,"stats":{"Line":1}},{"line":41,"address":[1371213,1371257],"length":1,"stats":{"Line":1}},{"line":42,"address":[1371240,1371279,1371333],"length":1,"stats":{"Line":2}},{"line":43,"address":[1371283,1371375,1371354],"length":1,"stats":{"Line":2}},{"line":44,"address":[1371421,1371396,1371361],"length":1,"stats":{"Line":2}},{"line":45,"address":[1371403,1371438,1371606],"length":1,"stats":{"Line":2}},{"line":48,"address":[1371464],"length":1,"stats":{"Line":1}},{"line":49,"address":[1246970],"length":1,"stats":{"Line":1}},{"line":55,"address":[1371473],"length":1,"stats":{"Line":1}},{"line":60,"address":[1371632],"length":1,"stats":{"Line":1}},{"line":61,"address":[1371637],"length":1,"stats":{"Line":1}},{"line":64,"address":[1371664],"length":1,"stats":{"Line":2}},{"line":65,"address":[1371684],"length":1,"stats":{"Line":2}},{"line":68,"address":[1247232],"length":1,"stats":{"Line":2}},{"line":69,"address":[1371811,1371766],"length":1,"stats":{"Line":4}},{"line":70,"address":[1371839],"length":1,"stats":{"Line":2}},{"line":71,"address":[1371895],"length":1,"stats":{"Line":2}},{"line":72,"address":[1371793],"length":1,"stats":{"Line":1}},{"line":74,"address":[1371923,1371966],"length":1,"stats":{"Line":2}},{"line":75,"address":[1247492,1247511,1247456],"length":1,"stats":{"Line":4}},{"line":76,"address":[1372188,1372029,1371992],"length":1,"stats":{"Line":4}},{"line":77,"address":[1372145],"length":1,"stats":{"Line":2}},{"line":80,"address":[1372224],"length":1,"stats":{"Line":2}},{"line":81,"address":[1372319,1372276],"length":1,"stats":{"Line":4}},{"line":82,"address":[1372347],"length":1,"stats":{"Line":2}},{"line":83,"address":[1247907],"length":1,"stats":{"Line":2}},{"line":86,"address":[1372431,1372474],"length":1,"stats":{"Line":2}},{"line":87,"address":[1248000,1248019,1247964],"length":1,"stats":{"Line":4}},{"line":88,"address":[1372537,1372500,1372715],"length":1,"stats":{"Line":4}},{"line":89,"address":[1372732,1372747,1372654],"length":1,"stats":{"Line":8}},{"line":90,"address":[1372745],"length":1,"stats":{"Line":2}},{"line":97,"address":[1372752,1372867,1372940],"length":1,"stats":{"Line":7}},{"line":105,"address":[1372817],"length":1,"stats":{"Line":7}},{"line":106,"address":[1248348,1248385],"length":1,"stats":{"Line":15}},{"line":111,"address":[1373121,1372992,1373207],"length":1,"stats":{"Line":1}},{"line":118,"address":[1248559],"length":1,"stats":{"Line":1}},{"line":119,"address":[1373098,1373131],"length":1,"stats":{"Line":2}},{"line":124,"address":[1373290,1373248],"length":1,"stats":{"Line":1}},{"line":125,"address":[1373267,1373306],"length":1,"stats":{"Line":2}},{"line":130,"address":[1373344,1373444,1373386],"length":1,"stats":{"Line":2}},{"line":131,"address":[1373402,1373363],"length":1,"stats":{"Line":4}},{"line":136,"address":[1373902,1373939,1373472,1373517],"length":1,"stats":{"Line":2}},{"line":137,"address":[1373494,1373533],"length":1,"stats":{"Line":4}},{"line":138,"address":[1373680,1373726,1373597],"length":1,"stats":{"Line":6}},{"line":139,"address":[1373744,1373803],"length":1,"stats":{"Line":4}},{"line":142,"address":[1373980],"length":1,"stats":{"Line":1}},{"line":147,"address":[1374430,1374045,1374000,1374467],"length":1,"stats":{"Line":2}},{"line":148,"address":[1374061,1374022],"length":1,"stats":{"Line":4}},{"line":149,"address":[1374125,1374208,1374254],"length":1,"stats":{"Line":6}},{"line":150,"address":[1374272,1374331],"length":1,"stats":{"Line":4}},{"line":153,"address":[1374508],"length":1,"stats":{"Line":1}},{"line":158,"address":[1374995,1374528,1374573,1374958],"length":1,"stats":{"Line":2}},{"line":159,"address":[1374550,1374589],"length":1,"stats":{"Line":4}},{"line":160,"address":[1374736,1374653,1374782],"length":1,"stats":{"Line":6}},{"line":161,"address":[1374800,1374859],"length":1,"stats":{"Line":4}},{"line":164,"address":[1375036],"length":1,"stats":{"Line":1}},{"line":169,"address":[1375523,1375056,1375101,1375486],"length":1,"stats":{"Line":2}},{"line":170,"address":[1375078,1375117],"length":1,"stats":{"Line":4}},{"line":171,"address":[1375181,1375264,1375310],"length":1,"stats":{"Line":6}},{"line":172,"address":[1375328,1375387],"length":1,"stats":{"Line":4}},{"line":175,"address":[1375564],"length":1,"stats":{"Line":1}},{"line":180,"address":[1250800,1250841,1251219,1251182],"length":1,"stats":{"Line":2}},{"line":181,"address":[1375645,1375606],"length":1,"stats":{"Line":5}},{"line":182,"address":[1375792,1375709,1375838],"length":1,"stats":{"Line":6}},{"line":183,"address":[1375915,1375856],"length":1,"stats":{"Line":4}},{"line":186,"address":[1376092],"length":1,"stats":{"Line":1}},{"line":191,"address":[1376163,1376693,1376653,1376112],"length":1,"stats":{"Line":1}},{"line":192,"address":[1376140,1376179],"length":1,"stats":{"Line":2}},{"line":193,"address":[1376243,1376329,1376375],"length":1,"stats":{"Line":3}},{"line":194,"address":[1251662,1251579,1251525],"length":1,"stats":{"Line":2}},{"line":197,"address":[1376734],"length":1,"stats":{"Line":1}},{"line":202,"address":[1252252,1251840,1252292,1251884],"length":1,"stats":{"Line":2}},{"line":203,"address":[1376777,1376816],"length":1,"stats":{"Line":4}},{"line":204,"address":[1252072,1251965,1252039],"length":1,"stats":{"Line":6}},{"line":205,"address":[1377094,1377030],"length":1,"stats":{"Line":4}},{"line":208,"address":[1252325],"length":1,"stats":{"Line":1}},{"line":213,"address":[1377779,1377312,1377357,1377742],"length":1,"stats":{"Line":2}},{"line":214,"address":[1252358,1252393],"length":1,"stats":{"Line":4}},{"line":215,"address":[1377566,1377437,1377520],"length":1,"stats":{"Line":6}},{"line":216,"address":[1252631,1252585],"length":1,"stats":{"Line":4}},{"line":219,"address":[1252788],"length":1,"stats":{"Line":1}},{"line":224,"address":[1377840,1378665,1377891,1378619],"length":1,"stats":{"Line":1}},{"line":225,"address":[1252828,1252863],"length":1,"stats":{"Line":2}},{"line":226,"address":[1378078,1378133,1377983],"length":1,"stats":{"Line":3}},{"line":227,"address":[1378475],"length":1,"stats":{"Line":1}},{"line":228,"address":[1378163,1378236],"length":1,"stats":{"Line":2}},{"line":229,"address":[1378243],"length":1,"stats":{"Line":1}},{"line":230,"address":[1378384,1378279],"length":1,"stats":{"Line":1}},{"line":231,"address":[1253317,1253280,1253410],"length":1,"stats":{"Line":2}},{"line":240,"address":[1253632,1254016,1253673,1254054],"length":1,"stats":{"Line":1}},{"line":241,"address":[1378813,1378774],"length":1,"stats":{"Line":2}},{"line":242,"address":[1253754,1253825,1253858],"length":1,"stats":{"Line":3}},{"line":243,"address":[1253881,1253927],"length":1,"stats":{"Line":2}},{"line":246,"address":[1254087],"length":1,"stats":{"Line":0}},{"line":251,"address":[1379325,1379716,1379280,1379741],"length":1,"stats":{"Line":1}},{"line":252,"address":[1254134,1254169],"length":1,"stats":{"Line":2}},{"line":253,"address":[1254338,1254234,1254305],"length":1,"stats":{"Line":3}},{"line":254,"address":[1379552,1379613],"length":1,"stats":{"Line":2}},{"line":261,"address":[1380236,1379776,1380261,1379832],"length":1,"stats":{"Line":3}},{"line":262,"address":[1254593,1254628],"length":1,"stats":{"Line":6}},{"line":263,"address":[1254693,1254800,1254767],"length":1,"stats":{"Line":9}},{"line":264,"address":[1380062,1380130],"length":1,"stats":{"Line":6}},{"line":271,"address":[1382007,1380361,1380304,1381979],"length":1,"stats":{"Line":1}},{"line":272,"address":[1255115,1255071],"length":1,"stats":{"Line":2}},{"line":273,"address":[1255290,1255329,1255201],"length":1,"stats":{"Line":3}},{"line":274,"address":[1255430,1255565,1255367],"length":1,"stats":{"Line":2}},{"line":275,"address":[1255593,1255550],"length":1,"stats":{"Line":2}},{"line":276,"address":[1381207,1381056],"length":1,"stats":{"Line":2}},{"line":277,"address":[1381366,1381591],"length":1,"stats":{"Line":1}},{"line":278,"address":[1256234,1256290],"length":1,"stats":{"Line":2}},{"line":279,"address":[1256408,1256617],"length":1,"stats":{"Line":2}},{"line":280,"address":[1381926,1381958],"length":1,"stats":{"Line":1}},{"line":291,"address":[1382048,1384352,1384380,1384408,1382299],"length":1,"stats":{"Line":1}},{"line":292,"address":[1382100],"length":1,"stats":{"Line":1}},{"line":297,"address":[1382112],"length":1,"stats":{"Line":1}},{"line":298,"address":[1384524,1382321,1382251],"length":1,"stats":{"Line":3}},{"line":299,"address":[1382557,1382652],"length":1,"stats":{"Line":2}},{"line":300,"address":[1257329,1259003],"length":1,"stats":{"Line":2}},{"line":301,"address":[1384440],"length":1,"stats":{"Line":1}},{"line":304,"address":[1257352],"length":1,"stats":{"Line":1}},{"line":305,"address":[1382976,1382921,1382820],"length":1,"stats":{"Line":3}},{"line":306,"address":[1383006,1383085,1383228],"length":1,"stats":{"Line":2}},{"line":307,"address":[1383201,1383256],"length":1,"stats":{"Line":2}},{"line":308,"address":[1258158,1258031],"length":1,"stats":{"Line":2}},{"line":309,"address":[1383721,1383946],"length":1,"stats":{"Line":1}},{"line":310,"address":[1383977,1383921],"length":1,"stats":{"Line":2}},{"line":311,"address":[1384087,1384316],"length":1,"stats":{"Line":2}},{"line":312,"address":[1384326,1384281],"length":1,"stats":{"Line":1}},{"line":323,"address":[1385221,1384544,1384630,1385138],"length":1,"stats":{"Line":2}},{"line":324,"address":[1259218,1259183],"length":1,"stats":{"Line":4}},{"line":325,"address":[1384710,1384796,1384842],"length":1,"stats":{"Line":6}},{"line":326,"address":[1259416,1259482],"length":1,"stats":{"Line":4}},{"line":327,"address":[1385020],"length":1,"stats":{"Line":2}},{"line":331,"address":[1385246],"length":1,"stats":{"Line":1}},{"line":336,"address":[1385361,1385779,1385804,1385264],"length":1,"stats":{"Line":3}},{"line":337,"address":[1385377,1385338],"length":1,"stats":{"Line":6}},{"line":338,"address":[1385573,1385527,1385441],"length":1,"stats":{"Line":9}},{"line":339,"address":[1385669,1385591],"length":1,"stats":{"Line":6}}],"covered":142,"coverable":143},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","stream.rs"],"content":"//! C FFI for stream - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, STREAMS, BUFFERS};\nuse std::ffi::c_char;\n\n/// Internal stream state\npub struct Stream {\n    pub(crate) data: Vec\u003cu8\u003e,\n    position: usize,\n    eof: bool,\n}\n\nimpl Stream {\n    pub fn new() -\u003e Self {\n        Self {\n            data: Vec::new(),\n            position: 0,\n            eof: true,\n        }\n    }\n\n    pub fn from_memory(data: Vec\u003cu8\u003e) -\u003e Self {\n        let eof = data.is_empty();\n        Self {\n            data,\n            position: 0,\n            eof,\n        }\n    }\n\n    pub fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e usize {\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n            return 0;\n        }\n\n        let available = self.data.len() - self.position;\n        let to_read = buf.len().min(available);\n        buf[..to_read].copy_from_slice(\u0026self.data[self.position..self.position + to_read]);\n        self.position += to_read;\n\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n        }\n\n        to_read\n    }\n\n    pub fn read_byte(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n            return None;\n        }\n        let byte = self.data[self.position];\n        self.position += 1;\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n        }\n        Some(byte)\n    }\n\n    pub fn peek_byte(\u0026self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003e= self.data.len() {\n            return None;\n        }\n        Some(self.data[self.position])\n    }\n\n    pub fn seek(\u0026mut self, offset: i64, whence: i32) {\n        let new_pos = match whence {\n            0 =\u003e offset as usize, // SEEK_SET\n            1 =\u003e (self.position as i64 + offset) as usize, // SEEK_CUR\n            2 =\u003e (self.data.len() as i64 + offset) as usize, // SEEK_END\n            _ =\u003e self.position,\n        };\n        self.position = new_pos.min(self.data.len());\n        self.eof = self.position \u003e= self.data.len();\n    }\n\n    pub fn tell(\u0026self) -\u003e i64 {\n        self.position as i64\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.eof\n    }\n}\n\nimpl Default for Stream {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Keep (increment ref) a stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_stream(_ctx: Handle, stm: Handle) -\u003e Handle {\n    STREAMS.keep(stm)\n}\n\n/// Drop a stream reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_stream(_ctx: Handle, stm: Handle) {\n    let _ = STREAMS.remove(stm);\n}\n\n/// Open a file for reading\n///\n/// # Safety\n/// Caller must ensure `filename` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_file(_ctx: Handle, filename: *const c_char) -\u003e Handle {\n    if filename.is_null() {\n        return 0;\n    }\n\n    // SAFETY: Caller guarantees filename is a valid null-terminated C string\n    #[allow(unsafe_code)]\n    let c_str = unsafe { std::ffi::CStr::from_ptr(filename) };\n    let path = match c_str.to_str() {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return 0,\n    };\n\n    match std::fs::read(path) {\n        Ok(data) =\u003e STREAMS.insert(Stream::from_memory(data)),\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Open a stream from memory\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_memory(\n    _ctx: Handle,\n    data: *const u8,\n    len: usize,\n) -\u003e Handle {\n    if data.is_null() || len == 0 {\n        return STREAMS.insert(Stream::new());\n    }\n\n    // SAFETY: Caller guarantees data points to valid memory of `len` bytes\n    #[allow(unsafe_code)]\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    STREAMS.insert(Stream::from_memory(slice.to_vec()))\n}\n\n/// Open a stream from a buffer handle\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return STREAMS.insert(Stream::from_memory(guard.data().to_vec()));\n        }\n    }\n    0\n}\n\n/// Read from stream into buffer\n///\n/// # Safety\n/// Caller must ensure `data` points to writable memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read(\n    _ctx: Handle,\n    stm: Handle,\n    data: *mut u8,\n    len: usize,\n) -\u003e usize {\n    if data.is_null() || len == 0 {\n        return 0;\n    }\n\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            // SAFETY: Caller guarantees data points to writable memory of `len` bytes\n            #[allow(unsafe_code)]\n            let buf = unsafe { std::slice::from_raw_parts_mut(data, len) };\n            return guard.read(buf);\n        }\n    }\n    0\n}\n\n/// Read a single byte from stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_byte(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            if let Some(byte) = guard.read_byte() {\n                return byte as i32;\n            }\n        }\n    }\n    -1 // EOF\n}\n\n/// Peek at next byte without consuming\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_peek_byte(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            if let Some(byte) = guard.peek_byte() {\n                return byte as i32;\n            }\n        }\n    }\n    -1\n}\n\n/// Check if stream is at EOF\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_eof(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return i32::from(guard.is_eof());\n        }\n    }\n    1\n}\n\n/// Seek in stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_seek(_ctx: Handle, stm: Handle, offset: i64, whence: i32) {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            guard.seek(offset, whence);\n        }\n    }\n}\n\n/// Get current position in stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_tell(_ctx: Handle, stm: Handle) -\u003e i64 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return guard.tell();\n        }\n    }\n    0\n}\n\n// Integer reading functions\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint16(_ctx: Handle, stm: Handle) -\u003e u16 {\n    let mut buf = [0u8; 2];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 2) == 2 {\n        u16::from_be_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint32(_ctx: Handle, stm: Handle) -\u003e u32 {\n    let mut buf = [0u8; 4];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 4) == 4 {\n        u32::from_be_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint16_le(_ctx: Handle, stm: Handle) -\u003e u16 {\n    let mut buf = [0u8; 2];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 2) == 2 {\n        u16::from_le_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint32_le(_ctx: Handle, stm: Handle) -\u003e u32 {\n    let mut buf = [0u8; 4];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 4) == 4 {\n        u32::from_le_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stream_from_memory() {\n        let data = vec![1, 2, 3, 4, 5];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        assert_eq!(fz_read_byte(0, handle), 1);\n        assert_eq!(fz_read_byte(0, handle), 2);\n        assert_eq!(fz_tell(0, handle), 2);\n\n        fz_seek(0, handle, 0, 0); // SEEK_SET\n        assert_eq!(fz_read_byte(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_eof() {\n        let data = vec![1];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        assert_eq!(fz_is_eof(0, handle), 0);\n        fz_read_byte(0, handle);\n        assert_eq!(fz_is_eof(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_keep() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let kept = fz_keep_stream(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_peek_byte() {\n        let data = vec![42, 43, 44];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        // Peek should return byte without advancing\n        let peeked = fz_peek_byte(0, handle);\n        assert_eq!(peeked, 42);\n        assert_eq!(fz_tell(0, handle), 0); // Position unchanged\n\n        // Read should advance\n        let read = fz_read_byte(0, handle);\n        assert_eq!(read, 42);\n        assert_eq!(fz_tell(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_multiple() {\n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let mut buf = [0u8; 4];\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 4);\n        assert_eq!(n, 4);\n        assert_eq!(buf, [1, 2, 3, 4]);\n\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 4);\n        assert_eq!(n, 4);\n        assert_eq!(buf, [5, 6, 7, 8]);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_seek_modes() {\n        let data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        // SEEK_SET (0)\n        fz_seek(0, handle, 5, 0);\n        assert_eq!(fz_tell(0, handle), 5);\n\n        // SEEK_CUR (1)\n        fz_seek(0, handle, 2, 1);\n        assert_eq!(fz_tell(0, handle), 7);\n\n        // SEEK_END (2)\n        fz_seek(0, handle, -3, 2);\n        assert_eq!(fz_tell(0, handle), 7);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint16() {\n        let data = vec![0x12, 0x34, 0x56, 0x78];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint16(0, handle);\n        assert_eq!(val, 0x1234);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint32() {\n        let data = vec![0x12, 0x34, 0x56, 0x78];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint32(0, handle);\n        assert_eq!(val, 0x12345678);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint16_le() {\n        let data = vec![0x34, 0x12, 0x78, 0x56];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint16_le(0, handle);\n        assert_eq!(val, 0x1234);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint32_le() {\n        let data = vec![0x78, 0x56, 0x34, 0x12];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint32_le(0, handle);\n        assert_eq!(val, 0x12345678);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_invalid_handle() {\n        assert_eq!(fz_read_byte(0, 0), -1);\n        assert_eq!(fz_peek_byte(0, 0), -1);\n        assert_eq!(fz_is_eof(0, 0), 1);\n        assert_eq!(fz_tell(0, 0), 0);\n    }\n\n    #[test]\n    fn test_stream_internal_new() {\n        let stream = Stream::new();\n        assert!(stream.data.is_empty());\n        assert_eq!(stream.position, 0);\n    }\n\n    #[test]\n    fn test_stream_internal_from_memory() {\n        let stream = Stream::from_memory(vec![1, 2, 3]);\n        assert_eq!(stream.data.len(), 3);\n        assert_eq!(stream.position, 0);\n    }\n\n    #[test]\n    fn test_stream_internal_read_byte() {\n        let mut stream = Stream::from_memory(vec![10, 20, 30]);\n        assert_eq!(stream.read_byte(), Some(10));\n        assert_eq!(stream.read_byte(), Some(20));\n        assert_eq!(stream.read_byte(), Some(30));\n        assert_eq!(stream.read_byte(), None);\n    }\n\n    #[test]\n    fn test_stream_internal_peek_byte() {\n        let mut stream = Stream::from_memory(vec![99]);\n        assert_eq!(stream.peek_byte(), Some(99));\n        assert_eq!(stream.peek_byte(), Some(99)); // Should not advance\n        assert_eq!(stream.read_byte(), Some(99));\n        assert_eq!(stream.peek_byte(), None);\n    }\n\n    #[test]\n    fn test_stream_internal_is_eof() {\n        let mut stream = Stream::from_memory(vec![1]);\n        assert!(!stream.is_eof());\n        stream.read_byte();\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_stream_internal_seek_set() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(3, 0);\n        assert_eq!(stream.tell(), 3);\n        assert_eq!(stream.read_byte(), Some(3));\n    }\n\n    #[test]\n    fn test_stream_internal_seek_cur() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(2, 0); // Start at 2\n        stream.seek(2, 1); // Move forward 2\n        assert_eq!(stream.tell(), 4);\n    }\n\n    #[test]\n    fn test_stream_internal_seek_end() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(-2, 2); // 2 from end\n        assert_eq!(stream.tell(), 3);\n    }\n\n    #[test]\n    fn test_stream_internal_seek_invalid_whence() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(2, 0); // Start at 2\n        stream.seek(99, 99); // Invalid whence\n        assert_eq!(stream.tell(), 2); // Should remain unchanged\n    }\n\n    #[test]\n    fn test_stream_internal_read() {\n        let mut stream = Stream::from_memory(vec![1, 2, 3, 4, 5]);\n        let mut buf = [0u8; 3];\n        let n = stream.read(\u0026mut buf);\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_stream_internal_read_empty() {\n        let mut stream = Stream::from_memory(vec![1]);\n        stream.read_byte();\n        let mut buf = [0u8; 10];\n        let n = stream.read(\u0026mut buf);\n        assert_eq!(n, 0);\n    }\n\n    #[test]\n    fn test_stream_default() {\n        let stream: Stream = Default::default();\n        assert!(stream.data.is_empty());\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_fz_open_memory_empty() {\n        let handle = fz_open_memory(0, std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_is_eof(0, handle), 1);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_open_file_null() {\n        let handle = fz_open_file(0, std::ptr::null());\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_open_buffer_invalid() {\n        let handle = fz_open_buffer(0, 99999);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_read_null_data() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let n = fz_read(0, handle, std::ptr::null_mut(), 10);\n        assert_eq!(n, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_zero_len() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let mut buf = [0u8; 10];\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 0);\n        assert_eq!(n, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_seek_invalid_handle() {\n        fz_seek(0, 99999, 10, 0); // Should not panic\n    }\n\n    #[test]\n    fn test_fz_read_uint_incomplete() {\n        let data = vec![0x12]; // Only 1 byte\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint16(0, handle);\n        assert_eq!(val, 0); // Incomplete read returns 0\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint32_incomplete() {\n        let data = vec![0x12, 0x34]; // Only 2 bytes\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint32(0, handle);\n        assert_eq!(val, 0); // Incomplete read returns 0\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint_le_incomplete() {\n        let data = vec![0x12]; // Only 1 byte\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint16_le(0, handle);\n        assert_eq!(val, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint32_le_incomplete() {\n        let data = vec![0x12, 0x34]; // Only 2 bytes\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint32_le(0, handle);\n        assert_eq!(val, 0);\n        fz_drop_stream(0, handle);\n    }\n}\n","traces":[{"line":15,"address":[1385840],"length":1,"stats":{"Line":1}},{"line":17,"address":[2537245],"length":1,"stats":{"Line":1}},{"line":23,"address":[1385920,1386096],"length":1,"stats":{"Line":2}},{"line":24,"address":[1385947,1386013],"length":1,"stats":{"Line":4}},{"line":32,"address":[1386112],"length":1,"stats":{"Line":4}},{"line":33,"address":[2537544],"length":1,"stats":{"Line":5}},{"line":34,"address":[1386227],"length":1,"stats":{"Line":1}},{"line":35,"address":[1386231],"length":1,"stats":{"Line":1}},{"line":38,"address":[1386356,1386185,1386255],"length":1,"stats":{"Line":6}},{"line":39,"address":[1386263],"length":1,"stats":{"Line":5}},{"line":40,"address":[1386459,1386295,1386384],"length":1,"stats":{"Line":10}},{"line":41,"address":[1386443,1386482,1386514],"length":1,"stats":{"Line":11}},{"line":43,"address":[1386548,1386486],"length":1,"stats":{"Line":5}},{"line":44,"address":[1386544],"length":1,"stats":{"Line":6}},{"line":47,"address":[1386532],"length":1,"stats":{"Line":4}},{"line":50,"address":[1386576],"length":1,"stats":{"Line":4}},{"line":51,"address":[1386590],"length":1,"stats":{"Line":3}},{"line":52,"address":[2538075],"length":1,"stats":{"Line":1}},{"line":53,"address":[1386687],"length":1,"stats":{"Line":1}},{"line":55,"address":[1386623],"length":1,"stats":{"Line":4}},{"line":56,"address":[1386658,1386738,1386704],"length":1,"stats":{"Line":10}},{"line":57,"address":[2538100,2538167],"length":1,"stats":{"Line":9}},{"line":58,"address":[1386771],"length":1,"stats":{"Line":3}},{"line":60,"address":[2538147],"length":1,"stats":{"Line":2}},{"line":63,"address":[1386800],"length":1,"stats":{"Line":1}},{"line":64,"address":[1386814],"length":1,"stats":{"Line":1}},{"line":65,"address":[1386877],"length":1,"stats":{"Line":1}},{"line":67,"address":[2538239],"length":1,"stats":{"Line":1}},{"line":70,"address":[1386896],"length":1,"stats":{"Line":2}},{"line":71,"address":[1386928],"length":1,"stats":{"Line":3}},{"line":72,"address":[1386977],"length":1,"stats":{"Line":2}},{"line":73,"address":[1387137,1386994],"length":1,"stats":{"Line":2}},{"line":74,"address":[1387019,1387162],"length":1,"stats":{"Line":4}},{"line":75,"address":[1386961],"length":1,"stats":{"Line":1}},{"line":77,"address":[2538442],"length":1,"stats":{"Line":2}},{"line":78,"address":[1387087],"length":1,"stats":{"Line":4}},{"line":81,"address":[2538576],"length":1,"stats":{"Line":2}},{"line":82,"address":[1387189],"length":1,"stats":{"Line":4}},{"line":85,"address":[1387200],"length":1,"stats":{"Line":2}},{"line":86,"address":[1387205],"length":1,"stats":{"Line":2}},{"line":91,"address":[1387216],"length":1,"stats":{"Line":1}},{"line":92,"address":[1387224],"length":1,"stats":{"Line":1}},{"line":98,"address":[1387290,1387248],"length":1,"stats":{"Line":1}},{"line":99,"address":[1387306,1387267],"length":1,"stats":{"Line":2}},{"line":104,"address":[1387444,1387344,1387386],"length":1,"stats":{"Line":2}},{"line":105,"address":[2538739,2538774],"length":1,"stats":{"Line":6}},{"line":113,"address":[1388041,1387472,1387536,1388035],"length":1,"stats":{"Line":1}},{"line":114,"address":[2538889,2538918],"length":1,"stats":{"Line":2}},{"line":115,"address":[1387574],"length":1,"stats":{"Line":1}},{"line":120,"address":[1387557,1387598],"length":1,"stats":{"Line":0}},{"line":121,"address":[1387614],"length":1,"stats":{"Line":0}},{"line":122,"address":[2539027],"length":1,"stats":{"Line":0}},{"line":123,"address":[1387641],"length":1,"stats":{"Line":0}},{"line":126,"address":[1387681],"length":1,"stats":{"Line":0}},{"line":127,"address":[1387799,1388019,1387745],"length":1,"stats":{"Line":0}},{"line":128,"address":[2539099],"length":1,"stats":{"Line":0}},{"line":137,"address":[2539734,2539472,2539541],"length":1,"stats":{"Line":2}},{"line":142,"address":[2539551,2539526],"length":1,"stats":{"Line":4}},{"line":143,"address":[2539815,2539568],"length":1,"stats":{"Line":2}},{"line":148,"address":[2539600],"length":1,"stats":{"Line":1}},{"line":149,"address":[2539775,2539663],"length":1,"stats":{"Line":2}},{"line":154,"address":[1389127,1388544,1389168,1388595],"length":1,"stats":{"Line":1}},{"line":155,"address":[2539884,2539919],"length":1,"stats":{"Line":2}},{"line":156,"address":[1388807,1388761,1388675],"length":1,"stats":{"Line":0}},{"line":157,"address":[2540173,2540112],"length":1,"stats":{"Line":0}},{"line":160,"address":[1389209],"length":1,"stats":{"Line":1}},{"line":168,"address":[2541157,2540464,2540546,2541116],"length":1,"stats":{"Line":1}},{"line":174,"address":[2540531,2540556],"length":1,"stats":{"Line":2}},{"line":175,"address":[2540573],"length":1,"stats":{"Line":1}},{"line":178,"address":[1389355],"length":1,"stats":{"Line":1}},{"line":179,"address":[1389559,1389624,1389464],"length":1,"stats":{"Line":8}},{"line":182,"address":[1389654,1389729],"length":1,"stats":{"Line":8}},{"line":183,"address":[1389761],"length":1,"stats":{"Line":4}},{"line":186,"address":[1390024],"length":1,"stats":{"Line":0}},{"line":191,"address":[2541216,2541692,2541767,2541263],"length":1,"stats":{"Line":2}},{"line":192,"address":[1390076,1390115],"length":1,"stats":{"Line":4}},{"line":193,"address":[1390265,1390179,1390311],"length":1,"stats":{"Line":9}},{"line":194,"address":[1390396,1390329],"length":1,"stats":{"Line":6}},{"line":195,"address":[2541590],"length":1,"stats":{"Line":3}},{"line":199,"address":[1390691],"length":1,"stats":{"Line":1}},{"line":204,"address":[1390704,1390755,1391239,1391322],"length":1,"stats":{"Line":1}},{"line":205,"address":[2541836,2541871],"length":1,"stats":{"Line":4}},{"line":206,"address":[2542043,2542010,2541936],"length":1,"stats":{"Line":3}},{"line":207,"address":[2542117,2542066],"length":1,"stats":{"Line":2}},{"line":208,"address":[1391121],"length":1,"stats":{"Line":1}},{"line":212,"address":[1391347],"length":1,"stats":{"Line":1}},{"line":217,"address":[2542400,2542869,2542829,2542444],"length":1,"stats":{"Line":2}},{"line":218,"address":[2542425,2542460],"length":1,"stats":{"Line":4}},{"line":219,"address":[2542632,2542525,2542599],"length":1,"stats":{"Line":9}},{"line":220,"address":[2542655,2542706],"length":1,"stats":{"Line":6}},{"line":223,"address":[1391922],"length":1,"stats":{"Line":1}},{"line":228,"address":[1391936,1392417,1392442,1392008],"length":1,"stats":{"Line":2}},{"line":229,"address":[2542996,2542961],"length":1,"stats":{"Line":4}},{"line":230,"address":[2543061,2543168,2543135],"length":1,"stats":{"Line":7}},{"line":231,"address":[2543191,2543251],"length":1,"stats":{"Line":5}},{"line":238,"address":[1392528,1392480,1392943,1392984],"length":1,"stats":{"Line":2}},{"line":239,"address":[2543433,2543468],"length":1,"stats":{"Line":4}},{"line":240,"address":[1392740,1392694,1392608],"length":1,"stats":{"Line":6}},{"line":241,"address":[1392822,1392758],"length":1,"stats":{"Line":6}},{"line":244,"address":[1393025],"length":1,"stats":{"Line":1}},{"line":249,"address":[1393097,1393040],"length":1,"stats":{"Line":1}},{"line":250,"address":[1393064],"length":1,"stats":{"Line":1}},{"line":251,"address":[1393118,1393071,1393179],"length":1,"stats":{"Line":3}},{"line":252,"address":[1393135,1393186],"length":1,"stats":{"Line":2}},{"line":254,"address":[2544035],"length":1,"stats":{"Line":1}},{"line":259,"address":[1393216,1393274],"length":1,"stats":{"Line":1}},{"line":260,"address":[2544088],"length":1,"stats":{"Line":1}},{"line":261,"address":[1393248,1393295,1393351],"length":1,"stats":{"Line":3}},{"line":262,"address":[2544204,2544159],"length":1,"stats":{"Line":2}},{"line":264,"address":[1393343],"length":1,"stats":{"Line":1}},{"line":269,"address":[2544281,2544224],"length":1,"stats":{"Line":1}},{"line":270,"address":[1393400],"length":1,"stats":{"Line":1}},{"line":271,"address":[1393454,1393515,1393407],"length":1,"stats":{"Line":3}},{"line":272,"address":[1393471,1393522],"length":1,"stats":{"Line":2}},{"line":274,"address":[1393508],"length":1,"stats":{"Line":1}},{"line":279,"address":[1393552,1393610],"length":1,"stats":{"Line":1}},{"line":280,"address":[1393576],"length":1,"stats":{"Line":1}},{"line":281,"address":[1393584,1393687,1393631],"length":1,"stats":{"Line":3}},{"line":282,"address":[1393648,1393693],"length":1,"stats":{"Line":2}},{"line":284,"address":[1393679],"length":1,"stats":{"Line":1}}],"covered":110,"coverable":120},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","async_io.rs"],"content":"//! Async I/O utilities using Tokio\n//!\n//! This module provides asynchronous I/O operations for PDF processing,\n//! enabling non-blocking file operations and concurrent processing.\n\nuse std::path::Path;\nuse tokio::fs::File;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader};\nuse bytes::{Bytes, BytesMut};\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::{Error, Result};\n\n/// Read a file asynchronously into a Buffer.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::read_file;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let buffer = read_file(\"document.pdf\").await.unwrap();\n///     println!(\"Read {} bytes\", buffer.len());\n/// }\n/// ```\npub async fn read_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cBuffer\u003e {\n    let mut file = File::open(path).await.map_err(Error::System)?;\n    let mut data = Vec::new();\n    file.read_to_end(\u0026mut data).await.map_err(Error::System)?;\n    Ok(Buffer::from_data(data))\n}\n\n/// Read a file asynchronously with a size limit.\npub async fn read_file_limited\u003cP: AsRef\u003cPath\u003e\u003e(path: P, max_size: usize) -\u003e Result\u003cBuffer\u003e {\n    let file = File::open(path).await.map_err(Error::System)?;\n    let mut reader = BufReader::new(file);\n    let mut data = Vec::with_capacity(max_size.min(8192));\n    let mut chunk = [0u8; 8192];\n\n    loop {\n        let n = reader.read(\u0026mut chunk).await.map_err(Error::System)?;\n        if n == 0 {\n            break;\n        }\n        if data.len() + n \u003e max_size {\n            return Err(Error::generic(\"File size exceeds limit\"));\n        }\n        data.extend_from_slice(\u0026chunk[..n]);\n    }\n\n    Ok(Buffer::from_data(data))\n}\n\n/// Write a buffer to a file asynchronously.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::write_file;\n/// use micropdf::fitz::buffer::Buffer;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let buffer = Buffer::from_slice(b\"Hello, PDF!\");\n///     write_file(\"output.txt\", \u0026buffer).await.unwrap();\n/// }\n/// ```\npub async fn write_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, buffer: \u0026Buffer) -\u003e Result\u003c()\u003e {\n    let mut file = File::create(path).await.map_err(Error::System)?;\n    file.write_all(\u0026buffer.to_vec()).await.map_err(Error::System)?;\n    file.flush().await.map_err(Error::System)?;\n    Ok(())\n}\n\n/// Copy a file asynchronously.\npub async fn copy_file\u003cP: AsRef\u003cPath\u003e, Q: AsRef\u003cPath\u003e\u003e(src: P, dst: Q) -\u003e Result\u003cu64\u003e {\n    tokio::fs::copy(src, dst).await.map_err(Error::System)\n}\n\n/// Check if a file exists asynchronously.\npub async fn file_exists\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e bool {\n    tokio::fs::metadata(path).await.is_ok()\n}\n\n/// Get file size asynchronously.\npub async fn file_size\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cu64\u003e {\n    let metadata = tokio::fs::metadata(path).await.map_err(Error::System)?;\n    Ok(metadata.len())\n}\n\n/// Read multiple files concurrently.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::read_files_concurrent;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let paths = vec![\"file1.pdf\", \"file2.pdf\", \"file3.pdf\"];\n///     let results = read_files_concurrent(\u0026paths).await;\n/// }\n/// ```\npub async fn read_files_concurrent\u003cP: AsRef\u003cPath\u003e + Send + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n    let futures: Vec\u003c_\u003e = paths\n        .iter()\n        .map(|path| {\n            let path = path.as_ref().to_path_buf();\n            async move { read_file(\u0026path).await }\n        })\n        .collect();\n\n    futures::future::join_all(futures).await\n}\n\n/// Write multiple buffers to files concurrently.\npub async fn write_files_concurrent\u003cP: AsRef\u003cPath\u003e + Send + Sync\u003e(\n    paths: \u0026[P],\n    buffers: \u0026[Buffer],\n) -\u003e Vec\u003cResult\u003c()\u003e\u003e {\n    if paths.len() != buffers.len() {\n        return vec![Err(Error::generic(\"Mismatched paths and buffers count\"))];\n    }\n\n    let futures: Vec\u003c_\u003e = paths\n        .iter()\n        .zip(buffers.iter())\n        .map(|(path, buffer)| {\n            let path = path.as_ref().to_path_buf();\n            let data = buffer.to_vec();\n            async move {\n                let mut file = File::create(\u0026path).await.map_err(Error::System)?;\n                file.write_all(\u0026data).await.map_err(Error::System)?;\n                file.flush().await.map_err(Error::System)?;\n                Ok(())\n            }\n        })\n        .collect();\n\n    futures::future::join_all(futures).await\n}\n\n/// Async buffer for streaming data.\npub struct AsyncBuffer {\n    inner: BytesMut,\n}\n\nimpl AsyncBuffer {\n    /// Create a new async buffer.\n    pub fn new() -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(8192),\n        }\n    }\n\n    /// Create with a specific capacity.\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(capacity),\n        }\n    }\n\n    /// Append data.\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\n        self.inner.extend_from_slice(data);\n    }\n\n    /// Get the length.\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Check if empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n\n    /// Clear the buffer.\n    pub fn clear(\u0026mut self) {\n        self.inner.clear();\n    }\n\n    /// Convert to Buffer.\n    pub fn into_buffer(self) -\u003e Buffer {\n        Buffer::from_bytes_mut(self.inner)\n    }\n\n    /// Convert to Bytes.\n    pub fn freeze(self) -\u003e Bytes {\n        self.inner.freeze()\n    }\n\n    /// Get as slice.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.inner\n    }\n}\n\nimpl Default for AsyncBuffer {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Run an async operation with a timeout.\npub async fn with_timeout\u003cF, T\u003e(duration: std::time::Duration, future: F) -\u003e Result\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    match tokio::time::timeout(duration, future).await {\n        Ok(result) =\u003e result,\n        Err(_) =\u003e Err(Error::generic(\"Operation timed out\")),\n    }\n}\n\n/// Spawn a task to run in the background.\npub fn spawn\u003cF\u003e(future: F) -\u003e tokio::task::JoinHandle\u003cF::Output\u003e\nwhere\n    F: std::future::Future + Send + 'static,\n    F::Output: Send + 'static,\n{\n    tokio::spawn(future)\n}\n\n/// Run multiple async operations concurrently and collect results.\npub async fn concurrent\u003cF, T\u003e(futures: Vec\u003cF\u003e) -\u003e Vec\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = T\u003e,\n    T: Send,\n{\n    futures::future::join_all(futures).await\n}\n\n/// Run multiple async operations concurrently with a limit on parallelism.\npub async fn concurrent_limited\u003cF, T\u003e(futures: Vec\u003cF\u003e, limit: usize) -\u003e Vec\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = T\u003e + Send,\n    T: Send,\n{\n    use futures::stream::{self, StreamExt};\n\n    stream::iter(futures)\n        .buffer_unordered(limit)\n        .collect()\n        .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn test_async_buffer() {\n        let mut buf = AsyncBuffer::new();\n        assert!(buf.is_empty());\n\n        buf.append(b\"Hello\");\n        assert_eq!(buf.len(), 5);\n\n        buf.append(b\" World\");\n        assert_eq!(buf.len(), 11);\n\n        let buffer = buf.into_buffer();\n        assert_eq!(buffer.as_slice(), b\"Hello World\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_with_capacity() {\n        let buf = AsyncBuffer::with_capacity(1024);\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_clear() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Hello\");\n        assert_eq!(buf.len(), 5);\n        buf.clear();\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_as_slice() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Test\");\n        assert_eq!(buf.as_slice(), b\"Test\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_freeze() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Freeze\");\n        let bytes = buf.freeze();\n        assert_eq!(\u0026bytes[..], b\"Freeze\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_default() {\n        let buf: AsyncBuffer = Default::default();\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_read_write_file() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        let buffer = Buffer::from_slice(b\"Hello, World!\");\n        write_file(\u0026path, \u0026buffer).await.unwrap();\n\n        let read_buffer = read_file(\u0026path).await.unwrap();\n        assert_eq!(read_buffer.as_slice(), b\"Hello, World!\");\n    }\n\n    #[tokio::test]\n    async fn test_file_exists() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        assert!(!file_exists(\u0026path).await);\n\n        write_file(\u0026path, \u0026Buffer::from_slice(b\"test\")).await.unwrap();\n\n        assert!(file_exists(\u0026path).await);\n    }\n\n    #[tokio::test]\n    async fn test_file_size() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        let data = b\"Hello, World!\";\n        write_file(\u0026path, \u0026Buffer::from_slice(data)).await.unwrap();\n\n        let size = file_size(\u0026path).await.unwrap();\n        assert_eq!(size, data.len() as u64);\n    }\n\n    #[tokio::test]\n    async fn test_copy_file() {\n        let dir = tempdir().unwrap();\n        let src = dir.path().join(\"src.txt\");\n        let dst = dir.path().join(\"dst.txt\");\n\n        let data = b\"Copy me!\";\n        write_file(\u0026src, \u0026Buffer::from_slice(data)).await.unwrap();\n\n        let copied = copy_file(\u0026src, \u0026dst).await.unwrap();\n        assert_eq!(copied, data.len() as u64);\n\n        let read_buffer = read_file(\u0026dst).await.unwrap();\n        assert_eq!(read_buffer.as_slice(), data);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent() {\n        async fn task_1() -\u003e i32 { 1 }\n        async fn task_2() -\u003e i32 { 2 }\n        async fn task_3() -\u003e i32 { 3 }\n\n        let futures: Vec\u003cstd::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = i32\u003e + Send\u003e\u003e\u003e = vec![\n            Box::pin(task_1()),\n            Box::pin(task_2()),\n            Box::pin(task_3()),\n        ];\n\n        let results = concurrent(futures).await;\n        assert_eq!(results, vec![1, 2, 3]);\n    }\n\n    #[tokio::test]\n    async fn test_with_timeout_success() {\n        let result = with_timeout(\n            std::time::Duration::from_secs(1),\n            async { Ok::\u003c_, Error\u003e(42) },\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_timeout_failure() {\n        let result = with_timeout(\n            std::time::Duration::from_millis(1),\n            async {\n                tokio::time::sleep(std::time::Duration::from_secs(10)).await;\n                Ok::\u003c_, Error\u003e(42)\n            },\n        ).await;\n\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_read_files_concurrent() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"file1.txt\");\n        let path2 = dir.path().join(\"file2.txt\");\n\n        write_file(\u0026path1, \u0026Buffer::from_slice(b\"File 1\")).await.unwrap();\n        write_file(\u0026path2, \u0026Buffer::from_slice(b\"File 2\")).await.unwrap();\n\n        let paths = vec![path1, path2];\n        let results = read_files_concurrent(\u0026paths).await;\n\n        assert_eq!(results.len(), 2);\n        assert!(results[0].is_ok());\n        assert!(results[1].is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_write_files_concurrent() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"write1.txt\");\n        let path2 = dir.path().join(\"write2.txt\");\n\n        let buf1 = Buffer::from_slice(b\"Content 1\");\n        let buf2 = Buffer::from_slice(b\"Content 2\");\n\n        let paths = vec![path1.clone(), path2.clone()];\n        let buffers = vec![buf1, buf2];\n        let results = write_files_concurrent(\u0026paths, \u0026buffers).await;\n\n        assert_eq!(results.len(), 2);\n        assert!(results[0].is_ok());\n        assert!(results[1].is_ok());\n\n        let read1 = read_file(\u0026path1).await.unwrap();\n        let read2 = read_file(\u0026path2).await.unwrap();\n        assert_eq!(read1.as_slice(), b\"Content 1\");\n        assert_eq!(read2.as_slice(), b\"Content 2\");\n    }\n\n    #[tokio::test]\n    async fn test_write_files_concurrent_mismatch() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"write1.txt\");\n\n        let buf1 = Buffer::from_slice(b\"Content 1\");\n        let buf2 = Buffer::from_slice(b\"Content 2\");\n\n        let paths = vec![path1];\n        let buffers = vec![buf1, buf2];\n        let results = write_files_concurrent(\u0026paths, \u0026buffers).await;\n\n        // Should return error because of mismatch\n        assert_eq!(results.len(), 1);\n        assert!(results[0].is_err());\n    }\n\n    #[tokio::test]\n    async fn test_read_file_limited() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"large.txt\");\n\n        let data = vec![b'X'; 1000];\n        write_file(\u0026path, \u0026Buffer::from_slice(\u0026data)).await.unwrap();\n\n        // Read with limit\n        let result = read_file_limited(\u0026path, 100).await;\n        assert!(result.is_err()); // Should exceed limit\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_limited() {\n        let futures: Vec\u003cstd::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = i32\u003e + Send\u003e\u003e\u003e = vec![\n            Box::pin(async { 1 }),\n            Box::pin(async { 2 }),\n            Box::pin(async { 3 }),\n            Box::pin(async { 4 }),\n        ];\n\n        let results = concurrent_limited(futures, 2).await;\n        assert_eq!(results.len(), 4);\n        // Note: order may not be preserved due to unordered buffering\n    }\n\n    #[tokio::test]\n    async fn test_spawn() {\n        let handle = spawn(async { 42 });\n        let result = handle.await.unwrap();\n        assert_eq!(result, 42);\n    }\n}\n\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[1850508],"length":1,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[1283868],"length":1,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[1852348],"length":1,"stats":{"Line":3}},{"line":36,"address":[1285100],"length":1,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[1285408],"length":1,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[1286177,1286267],"length":1,"stats":{"Line":0}},{"line":51,"address":[1285968,1285870],"length":1,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[1851057],"length":1,"stats":{"Line":10}},{"line":69,"address":[1851076],"length":1,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":7}},{"line":71,"address":[1288651],"length":1,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[1855617],"length":1,"stats":{"Line":3}},{"line":80,"address":[1289384,1289535,1289650,1289417,1289498,1289986,1289392,1289376],"length":1,"stats":{"Line":4}},{"line":81,"address":[1289676,1289525,1289595,1289491],"length":1,"stats":{"Line":3}},{"line":85,"address":[1290284,1290000,1290132,1290008,1290016,1290816,1290051,1290169],"length":1,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[1290703],"length":1,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[1290977,1291088],"length":1,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[1292208],"length":1,"stats":{"Line":1}},{"line":119,"address":[1292439],"length":1,"stats":{"Line":2}},{"line":120,"address":[1292523,1292821,1293173],"length":1,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[1293514],"length":1,"stats":{"Line":1}},{"line":128,"address":[1293546],"length":1,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[1295261,1293864,1294779,1294924,1294663],"length":1,"stats":{"Line":3}},{"line":132,"address":[1293882,1295294,1295798,1295173],"length":1,"stats":{"Line":2}},{"line":133,"address":[1295546],"length":1,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[1260784],"length":1,"stats":{"Line":4}},{"line":150,"address":[1260798],"length":1,"stats":{"Line":4}},{"line":155,"address":[1260864],"length":1,"stats":{"Line":1}},{"line":157,"address":[1260882],"length":1,"stats":{"Line":1}},{"line":162,"address":[1260944],"length":1,"stats":{"Line":3}},{"line":163,"address":[1260962],"length":1,"stats":{"Line":3}},{"line":167,"address":[1260976],"length":1,"stats":{"Line":2}},{"line":168,"address":[1260981],"length":1,"stats":{"Line":2}},{"line":172,"address":[1260992],"length":1,"stats":{"Line":3}},{"line":173,"address":[1260997],"length":1,"stats":{"Line":3}},{"line":177,"address":[1261008],"length":1,"stats":{"Line":1}},{"line":178,"address":[1261013],"length":1,"stats":{"Line":1}},{"line":182,"address":[1261024],"length":1,"stats":{"Line":1}},{"line":183,"address":[1261035],"length":1,"stats":{"Line":1}},{"line":187,"address":[1261104],"length":1,"stats":{"Line":1}},{"line":188,"address":[1261115],"length":1,"stats":{"Line":1}},{"line":192,"address":[1261184],"length":1,"stats":{"Line":1}},{"line":193,"address":[1261189],"length":1,"stats":{"Line":1}},{"line":198,"address":[1261200],"length":1,"stats":{"Line":1}},{"line":199,"address":[1261208],"length":1,"stats":{"Line":1}},{"line":204,"address":[1295984,1295904,1296120,1297080],"length":1,"stats":{"Line":4}},{"line":208,"address":[1863057,1863204],"length":1,"stats":{"Line":5}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[1297872],"length":1,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[1298037,1297920],"length":1,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[1298648,1298512],"length":1,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":3}}],"covered":77,"coverable":82},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","buffer.rs"],"content":"//! Buffer - Dynamic byte array wrapper using the `bytes` crate\n//!\n//! This module provides a high-performance buffer implementation backed by\n//! `bytes::Bytes` and `bytes::BytesMut` for efficient zero-copy operations.\n\nuse crate::fitz::error::{Error, Result};\nuse bytes::{Buf, BufMut, Bytes, BytesMut};\nuse std::fmt;\nuse std::io::{self, Read, Write};\nuse std::sync::Arc;\n\n/// A reference-counted buffer for efficient byte storage.\n///\n/// Uses `bytes::Bytes` for immutable shared data and `bytes::BytesMut` for\n/// mutable operations with copy-on-write semantics.\n#[derive(Clone)]\npub struct Buffer {\n    /// Immutable shared data (for reading)\n    data: Bytes,\n    /// Mutable buffer for writes (lazy initialized)\n    mutable: Option\u003cArc\u003cstd::sync::Mutex\u003cBytesMut\u003e\u003e\u003e,\n}\n\nimpl Buffer {\n    /// Create a new empty buffer with the specified capacity.\n    pub fn new(capacity: usize) -\u003e Self {\n        Self {\n            data: Bytes::new(),\n            mutable: Some(Arc::new(std::sync::Mutex::new(BytesMut::with_capacity(capacity)))),\n        }\n    }\n\n    /// Create a buffer from owned data (zero-copy).\n    pub fn from_data(data: Vec\u003cu8\u003e) -\u003e Self {\n        Self {\n            data: Bytes::from(data),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a byte slice (copies data).\n    pub fn from_slice(data: \u0026[u8]) -\u003e Self {\n        Self {\n            data: Bytes::copy_from_slice(data),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a `Bytes` instance (zero-copy).\n    pub fn from_bytes(data: Bytes) -\u003e Self {\n        Self {\n            data,\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a `BytesMut` instance (zero-copy).\n    pub fn from_bytes_mut(data: BytesMut) -\u003e Self {\n        Self {\n            data: data.freeze(),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from base64-encoded data.\n    pub fn from_base64(data: \u0026str) -\u003e Result\u003cSelf\u003e {\n        use base64::Engine;\n        let decoded = base64::engine::general_purpose::STANDARD\n            .decode(data.as_bytes())\n            .map_err(|e| Error::format(format!(\"Invalid base64: {}\", e)))?;\n        Ok(Self::from_data(decoded))\n    }\n\n    /// Returns the number of bytes in the buffer.\n    #[inline]\n    pub fn len(\u0026self) -\u003e usize {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    return self.data.len() + guard.len();\n                }\n            }\n        }\n        self.data.len()\n    }\n\n    /// Returns true if the buffer is empty.\n    #[inline]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    /// Returns the capacity of the buffer.\n    pub fn capacity(\u0026self) -\u003e usize {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                return self.data.len() + guard.capacity();\n            }\n        }\n        self.data.len()\n    }\n\n    /// Returns the buffer contents as a byte slice.\n    ///\n    /// If there are pending mutable writes, this will consolidate them first.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        // If we have no mutable data, return the immutable slice directly\n        if self.mutable.is_none() {\n            return \u0026self.data;\n        }\n\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if guard.is_empty() {\n                    return \u0026self.data;\n                }\n            }\n        }\n\n        // For simplicity, return the base data\n        // Full consolidation would require interior mutability\n        \u0026self.data\n    }\n\n    /// Returns the buffer as a UTF-8 string slice.\n    pub fn as_str(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        std::str::from_utf8(self.as_slice())\n            .map_err(|e| Error::format(format!(\"Invalid UTF-8: {}\", e)))\n    }\n\n    /// Returns a copy of the buffer contents as a Vec.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut result = self.data.to_vec();\n                    result.extend_from_slice(\u0026guard);\n                    return result;\n                }\n            }\n        }\n        self.data.to_vec()\n    }\n\n    /// Returns the buffer contents as `Bytes` (zero-copy if no mutable data).\n    pub fn to_bytes(\u0026self) -\u003e Bytes {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut result = BytesMut::with_capacity(self.data.len() + guard.len());\n                    result.extend_from_slice(\u0026self.data);\n                    result.extend_from_slice(\u0026guard);\n                    return result.freeze();\n                }\n            }\n        }\n        self.data.clone()\n    }\n\n    /// Consolidate any mutable data into the immutable buffer.\n    fn consolidate(\u0026mut self) {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut new_data = BytesMut::with_capacity(self.data.len() + guard.len());\n                    new_data.extend_from_slice(\u0026self.data);\n                    new_data.extend_from_slice(\u0026guard);\n                    self.data = new_data.freeze();\n                }\n            }\n        }\n        self.mutable = None;\n    }\n\n    /// Ensure we have a mutable buffer for writes.\n    fn ensure_mutable(\u0026mut self) {\n        if self.mutable.is_none() {\n            self.mutable = Some(Arc::new(std::sync::Mutex::new(BytesMut::with_capacity(256))));\n        }\n    }\n\n    /// Resize the buffer to the specified size.\n    pub fn resize(\u0026mut self, new_len: usize) {\n        self.consolidate();\n        let mut data = BytesMut::from(self.data.as_ref());\n        data.resize(new_len, 0);\n        self.data = data.freeze();\n    }\n\n    /// Clear all data from the buffer.\n    pub fn clear(\u0026mut self) {\n        self.data = Bytes::new();\n        self.mutable = None;\n    }\n\n    /// Append a byte slice to the buffer.\n    pub fn append_data(\u0026mut self, data: \u0026[u8]) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.extend_from_slice(data);\n            }\n        }\n    }\n\n    /// Append a single byte to the buffer.\n    pub fn append_byte(\u0026mut self, byte: u8) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_u8(byte);\n            }\n        }\n    }\n\n    /// Append a string to the buffer.\n    pub fn append_string(\u0026mut self, s: \u0026str) {\n        self.append_data(s.as_bytes());\n    }\n\n    /// Append a 16-bit integer in little-endian format.\n    pub fn append_int16_le(\u0026mut self, value: i16) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i16_le(value);\n            }\n        }\n    }\n\n    /// Append a 32-bit integer in little-endian format.\n    pub fn append_int32_le(\u0026mut self, value: i32) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i32_le(value);\n            }\n        }\n    }\n\n    /// Append a 16-bit integer in big-endian format.\n    pub fn append_int16_be(\u0026mut self, value: i16) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i16(value);\n            }\n        }\n    }\n\n    /// Append a 32-bit integer in big-endian format.\n    pub fn append_int32_be(\u0026mut self, value: i32) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i32(value);\n            }\n        }\n    }\n\n    /// Compute the MD5 digest of the buffer contents.\n    pub fn md5_digest(\u0026self) -\u003e [u8; 16] {\n        use md5::{Digest, Md5};\n        let mut hasher = Md5::new();\n        hasher.update(\u0026self.data);\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                hasher.update(\u0026*guard);\n            }\n        }\n        hasher.finalize().into()\n    }\n\n    /// Encode the buffer contents as base64.\n    pub fn to_base64(\u0026self) -\u003e String {\n        use base64::Engine;\n        base64::engine::general_purpose::STANDARD.encode(self.to_vec())\n    }\n\n    /// Get a slice of the buffer.\n    pub fn slice(\u0026self, start: usize, end: usize) -\u003e Buffer {\n        let data = self.to_bytes();\n        if start \u003e= data.len() {\n            return Buffer::new(0);\n        }\n        let end = end.min(data.len());\n        Buffer::from_bytes(data.slice(start..end))\n    }\n\n    /// Split the buffer at the given index.\n    pub fn split_at(\u0026self, mid: usize) -\u003e (Buffer, Buffer) {\n        let data = self.to_bytes();\n        if mid \u003e= data.len() {\n            return (Buffer::from_bytes(data), Buffer::new(0));\n        }\n        let first = data.slice(..mid);\n        let second = data.slice(mid..);\n        (Buffer::from_bytes(first), Buffer::from_bytes(second))\n    }\n}\n\nimpl Default for Buffer {\n    fn default() -\u003e Self {\n        Self::new(0)\n    }\n}\n\nimpl fmt::Debug for Buffer {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Buffer\").field(\"len\", \u0026self.len()).finish()\n    }\n}\n\nimpl AsRef\u003c[u8]\u003e for Buffer {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        self.as_slice()\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for Buffer {\n    fn from(data: Vec\u003cu8\u003e) -\u003e Self {\n        Self::from_data(data)\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Buffer {\n    fn from(data: \u0026[u8]) -\u003e Self {\n        Self::from_slice(data)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Buffer {\n    fn from(s: \u0026str) -\u003e Self {\n        Self::from_slice(s.as_bytes())\n    }\n}\n\nimpl From\u003cBytes\u003e for Buffer {\n    fn from(data: Bytes) -\u003e Self {\n        Self::from_bytes(data)\n    }\n}\n\nimpl From\u003cBytesMut\u003e for Buffer {\n    fn from(data: BytesMut) -\u003e Self {\n        Self::from_bytes_mut(data)\n    }\n}\n\nimpl From\u003cBuffer\u003e for Bytes {\n    fn from(buf: Buffer) -\u003e Bytes {\n        buf.to_bytes()\n    }\n}\n\n/// A reader for consuming buffer contents.\npub struct BufferReader {\n    data: Bytes,\n    position: usize,\n}\n\nimpl BufferReader {\n    /// Create a new reader from a buffer.\n    pub fn new(buffer: Buffer) -\u003e Self {\n        Self {\n            data: buffer.to_bytes(),\n            position: 0,\n        }\n    }\n\n    /// Returns the current read position.\n    pub fn position(\u0026self) -\u003e usize {\n        self.position\n    }\n\n    /// Returns the number of bytes remaining.\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.data.len().saturating_sub(self.position)\n    }\n\n    /// Check if we've reached the end.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.position \u003e= self.data.len()\n    }\n\n    /// Peek at the next byte without consuming it.\n    pub fn peek(\u0026self) -\u003e Option\u003cu8\u003e {\n        self.data.get(self.position).copied()\n    }\n\n    /// Read a byte.\n    pub fn read_byte(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003c self.data.len() {\n            let byte = self.data[self.position];\n            self.position += 1;\n            Some(byte)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 16-bit unsigned integer in big-endian format.\n    pub fn read_u16_be(\u0026mut self) -\u003e Option\u003cu16\u003e {\n        if self.remaining() \u003e= 2 {\n            let value = u16::from_be_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n            ]);\n            self.position += 2;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 32-bit unsigned integer in big-endian format.\n    pub fn read_u32_be(\u0026mut self) -\u003e Option\u003cu32\u003e {\n        if self.remaining() \u003e= 4 {\n            let value = u32::from_be_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n                self.data[self.position + 2],\n                self.data[self.position + 3],\n            ]);\n            self.position += 4;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 16-bit unsigned integer in little-endian format.\n    pub fn read_u16_le(\u0026mut self) -\u003e Option\u003cu16\u003e {\n        if self.remaining() \u003e= 2 {\n            let value = u16::from_le_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n            ]);\n            self.position += 2;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 32-bit unsigned integer in little-endian format.\n    pub fn read_u32_le(\u0026mut self) -\u003e Option\u003cu32\u003e {\n        if self.remaining() \u003e= 4 {\n            let value = u32::from_le_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n                self.data[self.position + 2],\n                self.data[self.position + 3],\n            ]);\n            self.position += 4;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Seek to a position.\n    pub fn seek(\u0026mut self, pos: usize) {\n        self.position = pos.min(self.data.len());\n    }\n\n    /// Skip n bytes.\n    pub fn skip(\u0026mut self, n: usize) {\n        self.position = (self.position + n).min(self.data.len());\n    }\n}\n\nimpl Read for BufferReader {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        let remaining = \u0026self.data[self.position..];\n        let to_read = buf.len().min(remaining.len());\n        buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n        self.position += to_read;\n        Ok(to_read)\n    }\n}\n\n/// A writer that accumulates data into a buffer.\npub struct BufferWriter {\n    inner: BytesMut,\n}\n\nimpl BufferWriter {\n    /// Create a new buffer writer.\n    pub fn new() -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(256),\n        }\n    }\n\n    /// Create a new buffer writer with the specified capacity.\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(capacity),\n        }\n    }\n\n    /// Convert the writer into a Buffer.\n    pub fn into_buffer(self) -\u003e Buffer {\n        Buffer::from_bytes_mut(self.inner)\n    }\n\n    /// Get a reference to the accumulated data.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.inner\n    }\n\n    /// Get the current length.\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Check if empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n\n    /// Write a byte.\n    pub fn write_byte(\u0026mut self, byte: u8) {\n        self.inner.put_u8(byte);\n    }\n\n    /// Write a 16-bit integer in big-endian format.\n    pub fn write_u16_be(\u0026mut self, value: u16) {\n        self.inner.put_u16(value);\n    }\n\n    /// Write a 32-bit integer in big-endian format.\n    pub fn write_u32_be(\u0026mut self, value: u32) {\n        self.inner.put_u32(value);\n    }\n\n    /// Write a 16-bit integer in little-endian format.\n    pub fn write_u16_le(\u0026mut self, value: u16) {\n        self.inner.put_u16_le(value);\n    }\n\n    /// Write a 32-bit integer in little-endian format.\n    pub fn write_u32_le(\u0026mut self, value: u32) {\n        self.inner.put_u32_le(value);\n    }\n}\n\nimpl Default for BufferWriter {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Write for BufferWriter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\n// Parallel buffer operations (when rayon feature is enabled)\n#[cfg(feature = \"parallel\")]\npub mod parallel {\n    use super::*;\n    use rayon::prelude::*;\n\n    /// Process multiple buffers in parallel.\n    pub fn process_buffers\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cR\u003e\n    where\n        F: Fn(\u0026Buffer) -\u003e R + Sync + Send,\n        R: Send,\n    {\n        buffers.par_iter().map(f).collect()\n    }\n\n    /// Apply a transformation to buffer data in parallel chunks.\n    pub fn parallel_transform\u003cF\u003e(buffer: \u0026Buffer, chunk_size: usize, f: F) -\u003e Buffer\n    where\n        F: Fn(\u0026[u8]) -\u003e Vec\u003cu8\u003e + Sync + Send,\n    {\n        let data = buffer.to_vec();\n        let chunks: Vec\u003cVec\u003cu8\u003e\u003e = data\n            .par_chunks(chunk_size)\n            .map(f)\n            .collect();\n\n        let total_len: usize = chunks.iter().map(|c| c.len()).sum();\n        let mut result = BytesMut::with_capacity(total_len);\n        for chunk in chunks {\n            result.extend_from_slice(\u0026chunk);\n        }\n        Buffer::from_bytes_mut(result)\n    }\n}\n\n// Async buffer operations (when async feature is enabled)\n#[cfg(feature = \"async\")]\npub mod async_ops {\n    use super::*;\n    use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};\n    use std::pin::Pin;\n    use std::task::{Context, Poll};\n\n    /// Read a buffer from an async reader.\n    pub async fn read_buffer\u003cR: AsyncRead + Unpin\u003e(\n        reader: \u0026mut R,\n        max_size: usize,\n    ) -\u003e Result\u003cBuffer\u003e {\n        let mut data = Vec::with_capacity(max_size.min(8192));\n        let mut chunk = [0u8; 8192];\n\n        loop {\n            let n = reader.read(\u0026mut chunk).await.map_err(Error::System)?;\n            if n == 0 {\n                break;\n            }\n            if data.len() + n \u003e max_size {\n                return Err(Error::generic(\"Buffer size limit exceeded\"));\n            }\n            data.extend_from_slice(\u0026chunk[..n]);\n        }\n\n        Ok(Buffer::from_data(data))\n    }\n\n    /// Write a buffer to an async writer.\n    pub async fn write_buffer\u003cW: AsyncWrite + Unpin\u003e(\n        writer: \u0026mut W,\n        buffer: \u0026Buffer,\n    ) -\u003e Result\u003c()\u003e {\n        writer.write_all(\u0026buffer.to_vec()).await.map_err(Error::System)\n    }\n\n    /// Async buffer reader.\n    pub struct AsyncBufferReader {\n        data: Bytes,\n        position: usize,\n    }\n\n    impl AsyncBufferReader {\n        pub fn new(buffer: Buffer) -\u003e Self {\n            Self {\n                data: buffer.to_bytes(),\n                position: 0,\n            }\n        }\n    }\n\n    impl AsyncRead for AsyncBufferReader {\n        fn poll_read(\n            mut self: Pin\u003c\u0026mut Self\u003e,\n            _cx: \u0026mut Context\u003c'_\u003e,\n            buf: \u0026mut tokio::io::ReadBuf\u003c'_\u003e,\n        ) -\u003e Poll\u003cio::Result\u003c()\u003e\u003e {\n            let remaining = \u0026self.data[self.position..];\n            let to_read = buf.remaining().min(remaining.len());\n            buf.put_slice(\u0026remaining[..to_read]);\n            self.position += to_read;\n            Poll::Ready(Ok(()))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Read, Write};\n\n    #[test]\n    fn test_buffer_new() {\n        let b = Buffer::new(100);\n        assert_eq!(b.len(), 0);\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_from_data() {\n        let data = vec![1, 2, 3, 4, 5];\n        let b = Buffer::from_data(data.clone());\n        assert_eq!(b.len(), 5);\n        assert!(!b.is_empty());\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_from_slice() {\n        let data = [1u8, 2, 3, 4, 5];\n        let b = Buffer::from_slice(\u0026data);\n        assert_eq!(b.as_slice(), \u0026data);\n    }\n\n    #[test]\n    fn test_buffer_from_bytes() {\n        let bytes = Bytes::from_static(\u0026[1, 2, 3]);\n        let b = Buffer::from_bytes(bytes);\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_base64() {\n        let b = Buffer::from_base64(\"SGVsbG8gV29ybGQ=\").unwrap();\n        assert_eq!(b.as_str().unwrap(), \"Hello World\");\n    }\n\n    #[test]\n    fn test_buffer_from_base64_invalid() {\n        let result = Buffer::from_base64(\"!!!invalid!!!\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_buffer_as_str() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        assert_eq!(b.as_str().unwrap(), \"Hello World\");\n    }\n\n    #[test]\n    fn test_buffer_as_str_invalid_utf8() {\n        let b = Buffer::from_slice(\u0026[0xFF, 0xFE, 0x00, 0x01]);\n        assert!(b.as_str().is_err());\n    }\n\n    #[test]\n    fn test_buffer_to_vec() {\n        let data = vec![1, 2, 3];\n        let b = Buffer::from_data(data.clone());\n        assert_eq!(b.to_vec(), data);\n    }\n\n    #[test]\n    fn test_buffer_resize() {\n        let mut b = Buffer::from_slice(\u0026[1, 2, 3]);\n        b.resize(5);\n        assert_eq!(b.len(), 5);\n        assert_eq!(b.to_vec(), vec![1, 2, 3, 0, 0]);\n    }\n\n    #[test]\n    fn test_buffer_clear() {\n        let mut b = Buffer::from_slice(\u0026[1, 2, 3]);\n        b.clear();\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_append_data() {\n        let mut b = Buffer::from_slice(\u0026[1, 2]);\n        b.append_data(\u0026[3, 4, 5]);\n        assert_eq!(b.to_vec(), vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_append_byte() {\n        let mut b = Buffer::new(0);\n        b.append_byte(0x42);\n        assert_eq!(b.to_vec(), vec![0x42]);\n    }\n\n    #[test]\n    fn test_buffer_append_string() {\n        let mut b = Buffer::new(0);\n        b.append_string(\"Hello\");\n        assert_eq!(b.to_vec(), b\"Hello\".to_vec());\n    }\n\n    #[test]\n    fn test_buffer_append_int16_le() {\n        let mut b = Buffer::new(0);\n        b.append_int16_le(0x0102);\n        assert_eq!(b.to_vec(), vec![0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_append_int32_le() {\n        let mut b = Buffer::new(0);\n        b.append_int32_le(0x01020304);\n        assert_eq!(b.to_vec(), vec![0x04, 0x03, 0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_append_int16_be() {\n        let mut b = Buffer::new(0);\n        b.append_int16_be(0x0102);\n        assert_eq!(b.to_vec(), vec![0x01, 0x02]);\n    }\n\n    #[test]\n    fn test_buffer_append_int32_be() {\n        let mut b = Buffer::new(0);\n        b.append_int32_be(0x01020304);\n        assert_eq!(b.to_vec(), vec![0x01, 0x02, 0x03, 0x04]);\n    }\n\n    #[test]\n    fn test_buffer_to_bytes() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let bytes = b.to_bytes();\n        assert_eq!(\u0026bytes[..], \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_md5_digest() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        let digest = b.md5_digest();\n        assert_eq!(digest[0], 0xb1);\n        assert_eq!(digest[1], 0x0a);\n    }\n\n    #[test]\n    fn test_buffer_to_base64() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        assert_eq!(b.to_base64(), \"SGVsbG8gV29ybGQ=\");\n    }\n\n    #[test]\n    fn test_buffer_slice() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let slice = b.slice(1, 4);\n        assert_eq!(slice.to_vec(), vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_buffer_split_at() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let (first, second) = b.split_at(3);\n        assert_eq!(first.to_vec(), vec![1, 2, 3]);\n        assert_eq!(second.to_vec(), vec![4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_default() {\n        let b: Buffer = Default::default();\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_debug() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let debug = format!(\"{:?}\", b);\n        assert!(debug.contains(\"Buffer\"));\n        assert!(debug.contains(\"len\"));\n    }\n\n    #[test]\n    fn test_buffer_as_ref() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let slice: \u0026[u8] = b.as_ref();\n        assert_eq!(slice, \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_vec() {\n        let b: Buffer = vec![1, 2, 3].into();\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_slice_trait() {\n        let data: \u0026[u8] = \u0026[1, 2, 3];\n        let b: Buffer = data.into();\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_str() {\n        let b: Buffer = \"Hello\".into();\n        assert_eq!(b.as_str().unwrap(), \"Hello\");\n    }\n\n    // BufferReader tests\n    #[test]\n    fn test_buffer_reader_new() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let reader = BufferReader::new(b);\n        assert_eq!(reader.position(), 0);\n        assert_eq!(reader.remaining(), 5);\n    }\n\n    #[test]\n    fn test_buffer_reader_read() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        let mut buf = [0u8; 3];\n        let n = reader.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, \u0026[1, 2, 3]);\n        assert_eq!(reader.position(), 3);\n        assert_eq!(reader.remaining(), 2);\n    }\n\n    #[test]\n    fn test_buffer_reader_read_byte() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_byte(), Some(1));\n        assert_eq!(reader.read_byte(), Some(2));\n        assert_eq!(reader.read_byte(), Some(3));\n        assert_eq!(reader.read_byte(), None);\n    }\n\n    #[test]\n    fn test_buffer_reader_peek() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let reader = BufferReader::new(b);\n        assert_eq!(reader.peek(), Some(1));\n        assert_eq!(reader.peek(), Some(1)); // Should not advance\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u16_be() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u16_be(), Some(0x0102));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u32_be() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02, 0x03, 0x04]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u32_be(), Some(0x01020304));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u16_le() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u16_le(), Some(0x0201));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u32_le() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02, 0x03, 0x04]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u32_le(), Some(0x04030201));\n    }\n\n    #[test]\n    fn test_buffer_reader_seek() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        reader.seek(3);\n        assert_eq!(reader.position(), 3);\n        assert_eq!(reader.read_byte(), Some(4));\n    }\n\n    #[test]\n    fn test_buffer_reader_skip() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        reader.skip(2);\n        assert_eq!(reader.position(), 2);\n        assert_eq!(reader.read_byte(), Some(3));\n    }\n\n    #[test]\n    fn test_buffer_reader_is_eof() {\n        let b = Buffer::from_slice(\u0026[1]);\n        let mut reader = BufferReader::new(b);\n        assert!(!reader.is_eof());\n        reader.read_byte();\n        assert!(reader.is_eof());\n    }\n\n    // BufferWriter tests\n    #[test]\n    fn test_buffer_writer_new() {\n        let writer = BufferWriter::new();\n        assert!(writer.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_writer_write() {\n        let mut writer = BufferWriter::new();\n        writer.write_all(\u0026[1, 2, 3]).unwrap();\n        assert_eq!(writer.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_writer_into_buffer() {\n        let mut writer = BufferWriter::new();\n        writer.write_all(b\"Hello\").unwrap();\n        let b = writer.into_buffer();\n        assert_eq!(b.as_str().unwrap(), \"Hello\");\n    }\n\n    #[test]\n    fn test_buffer_writer_write_byte() {\n        let mut writer = BufferWriter::new();\n        writer.write_byte(0x42);\n        assert_eq!(writer.as_slice(), \u0026[0x42]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u16_be() {\n        let mut writer = BufferWriter::new();\n        writer.write_u16_be(0x0102);\n        assert_eq!(writer.as_slice(), \u0026[0x01, 0x02]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u32_be() {\n        let mut writer = BufferWriter::new();\n        writer.write_u32_be(0x01020304);\n        assert_eq!(writer.as_slice(), \u0026[0x01, 0x02, 0x03, 0x04]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u16_le() {\n        let mut writer = BufferWriter::new();\n        writer.write_u16_le(0x0102);\n        assert_eq!(writer.as_slice(), \u0026[0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u32_le() {\n        let mut writer = BufferWriter::new();\n        writer.write_u32_le(0x01020304);\n        assert_eq!(writer.as_slice(), \u0026[0x04, 0x03, 0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_writer_default() {\n        let writer: BufferWriter = Default::default();\n        assert!(writer.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_writer_flush() {\n        let mut writer = BufferWriter::new();\n        assert!(writer.flush().is_ok());\n    }\n\n    #[test]\n    fn test_buffer_clone() {\n        let b1 = Buffer::from_slice(\u0026[1, 2, 3]);\n        let b2 = b1.clone();\n        assert_eq!(b1.to_vec(), b2.to_vec());\n    }\n}\n","traces":[{"line":26,"address":[1412570,1412576,1412368],"length":1,"stats":{"Line":6}},{"line":28,"address":[1412403],"length":1,"stats":{"Line":6}},{"line":29,"address":[1412476,1412418],"length":1,"stats":{"Line":12}},{"line":34,"address":[1710304],"length":1,"stats":{"Line":1}},{"line":36,"address":[1412605],"length":1,"stats":{"Line":2}},{"line":42,"address":[1710400],"length":1,"stats":{"Line":1}},{"line":44,"address":[1710423],"length":1,"stats":{"Line":2}},{"line":50,"address":[1710512],"length":1,"stats":{"Line":1}},{"line":58,"address":[1412864],"length":1,"stats":{"Line":1}},{"line":60,"address":[1710589],"length":1,"stats":{"Line":1}},{"line":66,"address":[1711128,1711157,1710672],"length":1,"stats":{"Line":1}},{"line":68,"address":[1710895,1710757,1710929,1710731],"length":1,"stats":{"Line":6}},{"line":69,"address":[1413027],"length":1,"stats":{"Line":2}},{"line":70,"address":[1754288,1754304],"length":1,"stats":{"Line":3}},{"line":71,"address":[1413273,1413369],"length":1,"stats":{"Line":2}},{"line":76,"address":[1711168,1711631,1711637],"length":1,"stats":{"Line":1}},{"line":77,"address":[1711185],"length":1,"stats":{"Line":3}},{"line":78,"address":[1711292,1711226],"length":1,"stats":{"Line":2}},{"line":79,"address":[1711374,1711310],"length":1,"stats":{"Line":2}},{"line":80,"address":[1711431,1711516,1711400],"length":1,"stats":{"Line":0}},{"line":84,"address":[1711264],"length":1,"stats":{"Line":2}},{"line":89,"address":[1711664],"length":1,"stats":{"Line":1}},{"line":90,"address":[1711669],"length":1,"stats":{"Line":1}},{"line":94,"address":[1414303,1414309,1413968],"length":1,"stats":{"Line":0}},{"line":95,"address":[1711710],"length":1,"stats":{"Line":0}},{"line":96,"address":[1711822,1711751],"length":1,"stats":{"Line":0}},{"line":97,"address":[1414109,1414154,1414226],"length":1,"stats":{"Line":0}},{"line":100,"address":[1711789],"length":1,"stats":{"Line":0}},{"line":106,"address":[1414770,1414776,1414336],"length":1,"stats":{"Line":4}},{"line":108,"address":[1712097],"length":1,"stats":{"Line":3}},{"line":109,"address":[1712150],"length":1,"stats":{"Line":4}},{"line":112,"address":[1712116,1712175],"length":1,"stats":{"Line":0}},{"line":113,"address":[1712184,1712255],"length":1,"stats":{"Line":0}},{"line":114,"address":[1414578,1414530],"length":1,"stats":{"Line":0}},{"line":115,"address":[1712376,1712470],"length":1,"stats":{"Line":0}},{"line":122,"address":[1712222],"length":1,"stats":{"Line":0}},{"line":126,"address":[1712576],"length":1,"stats":{"Line":2}},{"line":127,"address":[1712606],"length":1,"stats":{"Line":2}},{"line":128,"address":[1754432,1754448],"length":1,"stats":{"Line":2}},{"line":132,"address":[1414880,1415451,1415415],"length":1,"stats":{"Line":1}},{"line":133,"address":[1712686],"length":1,"stats":{"Line":2}},{"line":134,"address":[1415026,1414954],"length":1,"stats":{"Line":14}},{"line":135,"address":[1712823,1712890],"length":1,"stats":{"Line":14}},{"line":136,"address":[1712916,1712962],"length":1,"stats":{"Line":14}},{"line":137,"address":[1713051,1712981],"length":1,"stats":{"Line":14}},{"line":138,"address":[1415314],"length":1,"stats":{"Line":7}},{"line":142,"address":[1712768],"length":1,"stats":{"Line":2}},{"line":146,"address":[1415488,1416254,1416218],"length":1,"stats":{"Line":4}},{"line":147,"address":[1713326],"length":1,"stats":{"Line":5}},{"line":148,"address":[1713378,1713444],"length":1,"stats":{"Line":0}},{"line":149,"address":[1713547,1713474],"length":1,"stats":{"Line":0}},{"line":150,"address":[1713607,1713573],"length":1,"stats":{"Line":0}},{"line":151,"address":[1713724,1713800],"length":1,"stats":{"Line":0}},{"line":152,"address":[1713807],"length":1,"stats":{"Line":0}},{"line":153,"address":[1713883],"length":1,"stats":{"Line":0}},{"line":157,"address":[1713421],"length":1,"stats":{"Line":6}},{"line":161,"address":[1715023,1714128,1714954],"length":1,"stats":{"Line":1}},{"line":162,"address":[1714148],"length":1,"stats":{"Line":1}},{"line":163,"address":[1714281,1714200],"length":1,"stats":{"Line":0}},{"line":164,"address":[1714927,1714378,1714305],"length":1,"stats":{"Line":0}},{"line":165,"address":[1714438,1714404],"length":1,"stats":{"Line":0}},{"line":166,"address":[1714631,1714555],"length":1,"stats":{"Line":0}},{"line":167,"address":[1714638],"length":1,"stats":{"Line":0}},{"line":168,"address":[1714709,1714793],"length":1,"stats":{"Line":0}},{"line":172,"address":[1715057,1714238],"length":1,"stats":{"Line":1}},{"line":176,"address":[1417371,1417248],"length":1,"stats":{"Line":1}},{"line":177,"address":[1715299,1715137],"length":1,"stats":{"Line":2}},{"line":178,"address":[1417301,1417362,1417405],"length":1,"stats":{"Line":2}},{"line":183,"address":[1715312,1715646,1715675],"length":1,"stats":{"Line":1}},{"line":184,"address":[1417457],"length":1,"stats":{"Line":1}},{"line":185,"address":[1715363],"length":1,"stats":{"Line":1}},{"line":186,"address":[1715408],"length":1,"stats":{"Line":1}},{"line":187,"address":[1715462,1715528],"length":1,"stats":{"Line":1}},{"line":191,"address":[1715696,1715885],"length":1,"stats":{"Line":1}},{"line":192,"address":[1715714,1715738],"length":1,"stats":{"Line":1}},{"line":193,"address":[1417948,1417924],"length":1,"stats":{"Line":1}},{"line":197,"address":[1716210,1715904,1716204],"length":1,"stats":{"Line":1}},{"line":198,"address":[1715938],"length":1,"stats":{"Line":1}},{"line":199,"address":[1715948],"length":1,"stats":{"Line":1}},{"line":200,"address":[1418149,1418101],"length":1,"stats":{"Line":4}},{"line":201,"address":[1716058,1716124],"length":1,"stats":{"Line":4}},{"line":207,"address":[1418612,1418618,1418336],"length":1,"stats":{"Line":1}},{"line":208,"address":[1716265],"length":1,"stats":{"Line":1}},{"line":209,"address":[1716275],"length":1,"stats":{"Line":1}},{"line":210,"address":[1716316,1716367],"length":1,"stats":{"Line":2}},{"line":211,"address":[1716445,1716385],"length":1,"stats":{"Line":2}},{"line":217,"address":[1716576],"length":1,"stats":{"Line":1}},{"line":218,"address":[1716626],"length":1,"stats":{"Line":1}},{"line":222,"address":[1716656,1716957,1716951],"length":1,"stats":{"Line":1}},{"line":223,"address":[1716683],"length":1,"stats":{"Line":1}},{"line":224,"address":[1716693],"length":1,"stats":{"Line":1}},{"line":225,"address":[1716785,1716734],"length":1,"stats":{"Line":2}},{"line":226,"address":[1716864,1716803],"length":1,"stats":{"Line":2}},{"line":232,"address":[1716992,1717278,1717284],"length":1,"stats":{"Line":1}},{"line":233,"address":[1717014],"length":1,"stats":{"Line":1}},{"line":234,"address":[1717024],"length":1,"stats":{"Line":1}},{"line":235,"address":[1717065,1717116],"length":1,"stats":{"Line":2}},{"line":236,"address":[1717134,1717194],"length":1,"stats":{"Line":2}},{"line":242,"address":[1717312,1717607,1717613],"length":1,"stats":{"Line":1}},{"line":243,"address":[1717339],"length":1,"stats":{"Line":1}},{"line":244,"address":[1717349],"length":1,"stats":{"Line":1}},{"line":245,"address":[1419422,1419470],"length":1,"stats":{"Line":2}},{"line":246,"address":[1717520,1717459],"length":1,"stats":{"Line":2}},{"line":252,"address":[1717934,1717940,1717648],"length":1,"stats":{"Line":1}},{"line":253,"address":[1717670],"length":1,"stats":{"Line":1}},{"line":254,"address":[1717680],"length":1,"stats":{"Line":1}},{"line":255,"address":[1717772,1717721],"length":1,"stats":{"Line":2}},{"line":256,"address":[1717850,1717790],"length":1,"stats":{"Line":2}},{"line":262,"address":[1718418,1717968,1718424],"length":1,"stats":{"Line":1}},{"line":264,"address":[1717998],"length":1,"stats":{"Line":1}},{"line":265,"address":[1718014],"length":1,"stats":{"Line":1}},{"line":266,"address":[1718030],"length":1,"stats":{"Line":1}},{"line":267,"address":[1718074,1718213],"length":1,"stats":{"Line":0}},{"line":268,"address":[1718243,1718311],"length":1,"stats":{"Line":0}},{"line":271,"address":[1718113],"length":1,"stats":{"Line":1}},{"line":275,"address":[1718464],"length":1,"stats":{"Line":1}},{"line":277,"address":[1718483],"length":1,"stats":{"Line":1}},{"line":281,"address":[1718831,1718837,1718528],"length":1,"stats":{"Line":1}},{"line":282,"address":[1718579],"length":1,"stats":{"Line":1}},{"line":283,"address":[1718603,1718666],"length":1,"stats":{"Line":2}},{"line":284,"address":[1718693],"length":1,"stats":{"Line":0}},{"line":286,"address":[1718676,1718718],"length":1,"stats":{"Line":2}},{"line":287,"address":[1718752],"length":1,"stats":{"Line":1}},{"line":291,"address":[1718864,1719506,1719680],"length":1,"stats":{"Line":1}},{"line":292,"address":[1718901],"length":1,"stats":{"Line":1}},{"line":293,"address":[1718957,1719019],"length":1,"stats":{"Line":2}},{"line":294,"address":[1719556,1719052],"length":1,"stats":{"Line":0}},{"line":296,"address":[1421051,1420989],"length":1,"stats":{"Line":2}},{"line":297,"address":[1421120,1421072],"length":1,"stats":{"Line":2}},{"line":298,"address":[1719300,1719192],"length":1,"stats":{"Line":2}},{"line":303,"address":[1421632],"length":1,"stats":{"Line":1}},{"line":304,"address":[1719720],"length":1,"stats":{"Line":1}},{"line":309,"address":[1421664],"length":1,"stats":{"Line":1}},{"line":310,"address":[1719763],"length":1,"stats":{"Line":1}},{"line":315,"address":[1421776],"length":1,"stats":{"Line":1}},{"line":316,"address":[1421781],"length":1,"stats":{"Line":1}},{"line":321,"address":[1719872],"length":1,"stats":{"Line":1}},{"line":322,"address":[1421800],"length":1,"stats":{"Line":1}},{"line":327,"address":[1421824],"length":1,"stats":{"Line":1}},{"line":328,"address":[1421845],"length":1,"stats":{"Line":1}},{"line":333,"address":[1719952],"length":1,"stats":{"Line":1}},{"line":334,"address":[1421922],"length":1,"stats":{"Line":1}},{"line":339,"address":[1421952],"length":1,"stats":{"Line":0}},{"line":340,"address":[1720040],"length":1,"stats":{"Line":0}},{"line":345,"address":[1720064],"length":1,"stats":{"Line":0}},{"line":346,"address":[1421992],"length":1,"stats":{"Line":0}},{"line":351,"address":[1821361,1821280],"length":1,"stats":{"Line":0}},{"line":352,"address":[1821297],"length":1,"stats":{"Line":0}},{"line":364,"address":[1422140,1422016],"length":1,"stats":{"Line":1}},{"line":366,"address":[1720114],"length":1,"stats":{"Line":4}},{"line":372,"address":[1422160],"length":1,"stats":{"Line":1}},{"line":373,"address":[1720261],"length":1,"stats":{"Line":1}},{"line":377,"address":[1720272],"length":1,"stats":{"Line":3}},{"line":378,"address":[1720286],"length":1,"stats":{"Line":2}},{"line":382,"address":[1422224],"length":1,"stats":{"Line":1}},{"line":383,"address":[1422233],"length":1,"stats":{"Line":1}},{"line":387,"address":[1720368],"length":1,"stats":{"Line":1}},{"line":388,"address":[1720382],"length":1,"stats":{"Line":1}},{"line":392,"address":[1720432],"length":1,"stats":{"Line":1}},{"line":393,"address":[1422350,1422537,1422382],"length":1,"stats":{"Line":5}},{"line":394,"address":[1720593,1720485,1720552],"length":1,"stats":{"Line":3}},{"line":395,"address":[1720563,1720620,1720635],"length":1,"stats":{"Line":4}},{"line":396,"address":[1422528],"length":1,"stats":{"Line":3}},{"line":398,"address":[1720473],"length":1,"stats":{"Line":1}},{"line":403,"address":[1720656],"length":1,"stats":{"Line":1}},{"line":404,"address":[1721005,1720689,1720670],"length":1,"stats":{"Line":2}},{"line":405,"address":[1422788],"length":1,"stats":{"Line":1}},{"line":406,"address":[1720765,1720696,1720825],"length":1,"stats":{"Line":2}},{"line":407,"address":[1720772,1720848,1720961],"length":1,"stats":{"Line":2}},{"line":409,"address":[1721010,1720931,1720989],"length":1,"stats":{"Line":2}},{"line":410,"address":[1422896],"length":1,"stats":{"Line":1}},{"line":412,"address":[1422585],"length":1,"stats":{"Line":0}},{"line":417,"address":[1422928],"length":1,"stats":{"Line":1}},{"line":418,"address":[1423621,1422951,1422973],"length":1,"stats":{"Line":2}},{"line":419,"address":[1721560],"length":1,"stats":{"Line":1}},{"line":420,"address":[1721080,1721240,1721171],"length":1,"stats":{"Line":2}},{"line":421,"address":[1423081,1423267,1423166],"length":1,"stats":{"Line":2}},{"line":422,"address":[1721488,1721308,1721387],"length":1,"stats":{"Line":2}},{"line":423,"address":[1423414,1423335,1423569],"length":1,"stats":{"Line":2}},{"line":425,"address":[1423626,1423539,1423599],"length":1,"stats":{"Line":2}},{"line":426,"address":[1423603],"length":1,"stats":{"Line":1}},{"line":428,"address":[1721059],"length":1,"stats":{"Line":0}},{"line":433,"address":[1423648],"length":1,"stats":{"Line":1}},{"line":434,"address":[1423680,1423996,1423662],"length":1,"stats":{"Line":2}},{"line":435,"address":[1423876],"length":1,"stats":{"Line":1}},{"line":436,"address":[1423816,1423687,1423756],"length":1,"stats":{"Line":2}},{"line":437,"address":[1423952,1423763,1423839],"length":1,"stats":{"Line":2}},{"line":439,"address":[1722077,1722019,1722098],"length":1,"stats":{"Line":2}},{"line":440,"address":[1722081],"length":1,"stats":{"Line":1}},{"line":442,"address":[1423673],"length":1,"stats":{"Line":0}},{"line":447,"address":[1722112],"length":1,"stats":{"Line":1}},{"line":448,"address":[1722135,1722806,1722158],"length":1,"stats":{"Line":2}},{"line":449,"address":[1722648],"length":1,"stats":{"Line":1}},{"line":450,"address":[1424071,1424162,1424231],"length":1,"stats":{"Line":2}},{"line":451,"address":[1722266,1722351,1722452],"length":1,"stats":{"Line":2}},{"line":452,"address":[1424479,1424378,1424299],"length":1,"stats":{"Line":2}},{"line":453,"address":[1424423,1424502,1424657],"length":1,"stats":{"Line":2}},{"line":455,"address":[1722811,1722784,1722724],"length":1,"stats":{"Line":2}},{"line":456,"address":[1424691],"length":1,"stats":{"Line":1}},{"line":458,"address":[1722147],"length":1,"stats":{"Line":0}},{"line":463,"address":[1424736],"length":1,"stats":{"Line":1}},{"line":464,"address":[1722856],"length":1,"stats":{"Line":1}},{"line":468,"address":[1424800],"length":1,"stats":{"Line":1}},{"line":469,"address":[1424874,1424819],"length":1,"stats":{"Line":1}},{"line":474,"address":[1424896],"length":1,"stats":{"Line":1}},{"line":475,"address":[1424933],"length":1,"stats":{"Line":1}},{"line":476,"address":[1425000],"length":1,"stats":{"Line":1}},{"line":477,"address":[1425032],"length":1,"stats":{"Line":1}},{"line":478,"address":[1723293,1723228],"length":1,"stats":{"Line":1}},{"line":479,"address":[1425165],"length":1,"stats":{"Line":1}},{"line":490,"address":[1723312],"length":1,"stats":{"Line":1}},{"line":492,"address":[1425230],"length":1,"stats":{"Line":3}},{"line":497,"address":[1723392],"length":1,"stats":{"Line":0}},{"line":499,"address":[1425314],"length":1,"stats":{"Line":0}},{"line":504,"address":[1723472],"length":1,"stats":{"Line":1}},{"line":505,"address":[1723483],"length":1,"stats":{"Line":1}},{"line":509,"address":[1425456],"length":1,"stats":{"Line":1}},{"line":510,"address":[1723557],"length":1,"stats":{"Line":1}},{"line":514,"address":[1425472],"length":1,"stats":{"Line":0}},{"line":515,"address":[1723573],"length":1,"stats":{"Line":0}},{"line":519,"address":[1723584],"length":1,"stats":{"Line":1}},{"line":520,"address":[1425493],"length":1,"stats":{"Line":1}},{"line":524,"address":[1425504],"length":1,"stats":{"Line":1}},{"line":525,"address":[1425520],"length":1,"stats":{"Line":1}},{"line":529,"address":[1425536],"length":1,"stats":{"Line":1}},{"line":530,"address":[1425553],"length":1,"stats":{"Line":1}},{"line":534,"address":[1425568],"length":1,"stats":{"Line":1}},{"line":535,"address":[1723677],"length":1,"stats":{"Line":1}},{"line":539,"address":[1723696],"length":1,"stats":{"Line":1}},{"line":540,"address":[1723713],"length":1,"stats":{"Line":1}},{"line":544,"address":[1723728],"length":1,"stats":{"Line":1}},{"line":545,"address":[1723741],"length":1,"stats":{"Line":1}},{"line":550,"address":[1723760],"length":1,"stats":{"Line":1}},{"line":551,"address":[1723768],"length":1,"stats":{"Line":1}},{"line":556,"address":[1723792],"length":1,"stats":{"Line":1}},{"line":557,"address":[1723816],"length":1,"stats":{"Line":1}},{"line":558,"address":[1723826],"length":1,"stats":{"Line":1}},{"line":561,"address":[1425760],"length":1,"stats":{"Line":1}},{"line":562,"address":[1723861],"length":1,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[1663424,1663548],"length":1,"stats":{"Line":0}},{"line":648,"address":[1663447],"length":1,"stats":{"Line":0}},{"line":655,"address":[1663568],"length":1,"stats":{"Line":0}},{"line":660,"address":[1663595],"length":1,"stats":{"Line":0}},{"line":661,"address":[1663683],"length":1,"stats":{"Line":0}},{"line":662,"address":[1663728],"length":1,"stats":{"Line":0}},{"line":663,"address":[1663761,1663858],"length":1,"stats":{"Line":0}},{"line":664,"address":[1663812],"length":1,"stats":{"Line":0}}],"covered":198,"coverable":268},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","colorspace.rs"],"content":"//! Colorspace definitions\n\n#[derive(Debug, Clone)]\npub struct Colorspace { name: String, n: u8 }\n\nimpl Colorspace {\n    pub fn device_gray() -\u003e Self { Self { name: \"DeviceGray\".into(), n: 1 } }\n    pub fn device_rgb() -\u003e Self { Self { name: \"DeviceRGB\".into(), n: 3 } }\n    pub fn device_cmyk() -\u003e Self { Self { name: \"DeviceCMYK\".into(), n: 4 } }\n    pub fn name(\u0026self) -\u003e \u0026str { \u0026self.name }\n    pub fn n(\u0026self) -\u003e u8 { self.n }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_device_gray() {\n        let cs = Colorspace::device_gray();\n        assert_eq!(cs.name(), \"DeviceGray\");\n        assert_eq!(cs.n(), 1);\n    }\n\n    #[test]\n    fn test_device_rgb() {\n        let cs = Colorspace::device_rgb();\n        assert_eq!(cs.name(), \"DeviceRGB\");\n        assert_eq!(cs.n(), 3);\n    }\n\n    #[test]\n    fn test_device_cmyk() {\n        let cs = Colorspace::device_cmyk();\n        assert_eq!(cs.name(), \"DeviceCMYK\");\n        assert_eq!(cs.n(), 4);\n    }\n\n    #[test]\n    fn test_colorspace_clone() {\n        let cs1 = Colorspace::device_rgb();\n        let cs2 = cs1.clone();\n        assert_eq!(cs1.name(), cs2.name());\n        assert_eq!(cs1.n(), cs2.n());\n    }\n\n    #[test]\n    fn test_colorspace_debug() {\n        let cs = Colorspace::device_rgb();\n        let debug = format!(\"{:?}\", cs);\n        assert!(debug.contains(\"DeviceRGB\"));\n        assert!(debug.contains(\"3\"));\n    }\n}\n\n","traces":[{"line":7,"address":[1680669,1680656],"length":1,"stats":{"Line":2}},{"line":8,"address":[1680752,1680765],"length":1,"stats":{"Line":2}},{"line":9,"address":[1680848,1680861],"length":1,"stats":{"Line":2}},{"line":10,"address":[1680944,1680949],"length":1,"stats":{"Line":2}},{"line":11,"address":[1680960,1680965],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","device.rs"],"content":"//! Rendering device trait\nuse crate::fitz::geometry::{Matrix, Rect};\nuse crate::fitz::path::Path;\nuse crate::fitz::text::TextSpan;\nuse crate::fitz::image::Image;\nuse crate::fitz::colorspace::Colorspace;\n\npub trait Device {\n    fn fill_path(\u0026mut self, path: \u0026Path, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn stroke_path(\u0026mut self, path: \u0026Path, stroke: \u0026StrokeState, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn fill_text(\u0026mut self, text: \u0026TextSpan, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn fill_image(\u0026mut self, image: \u0026Image, ctm: Matrix, alpha: f32);\n}\n\npub struct StrokeState { pub linewidth: f32, pub linecap: u8, pub linejoin: u8 }\nimpl Default for StrokeState { fn default() -\u003e Self { Self { linewidth: 1.0, linecap: 0, linejoin: 0 } } }\n\npub struct NullDevice;\nimpl Device for NullDevice {\n    fn fill_path(\u0026mut self, _: \u0026Path, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn stroke_path(\u0026mut self, _: \u0026Path, _: \u0026StrokeState, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn fill_text(\u0026mut self, _: \u0026TextSpan, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn fill_image(\u0026mut self, _: \u0026Image, _: Matrix, _: f32) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::fitz::geometry::Point;\n\n    #[test]\n    fn test_stroke_state_default() {\n        let ss: StrokeState = Default::default();\n        assert_eq!(ss.linewidth, 1.0);\n        assert_eq!(ss.linecap, 0);\n        assert_eq!(ss.linejoin, 0);\n    }\n\n    #[test]\n    fn test_stroke_state_custom() {\n        let ss = StrokeState {\n            linewidth: 2.5,\n            linecap: 1,\n            linejoin: 2,\n        };\n        assert_eq!(ss.linewidth, 2.5);\n        assert_eq!(ss.linecap, 1);\n        assert_eq!(ss.linejoin, 2);\n    }\n\n    #[test]\n    fn test_null_device_fill_path() {\n        let mut device = NullDevice;\n        let path = Path::new();\n        let cs = Colorspace::device_rgb();\n        let color = [1.0, 0.0, 0.0];\n\n        // Should not panic\n        device.fill_path(\u0026path, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_stroke_path() {\n        let mut device = NullDevice;\n        let path = Path::new();\n        let cs = Colorspace::device_rgb();\n        let color = [0.0, 1.0, 0.0];\n        let stroke = StrokeState::default();\n\n        // Should not panic\n        device.stroke_path(\u0026path, \u0026stroke, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_fill_text() {\n        let mut device = NullDevice;\n        let text = TextSpan::new();\n        let cs = Colorspace::device_rgb();\n        let color = [0.0, 0.0, 0.0];\n\n        // Should not panic\n        device.fill_text(\u0026text, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_fill_image() {\n        let mut device = NullDevice;\n        let image = Image::new(100, 100, None);\n\n        // Should not panic\n        device.fill_image(\u0026image, Matrix::IDENTITY, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_implements_device_trait() {\n        fn takes_device\u003cD: Device\u003e(_d: \u0026mut D) {}\n        let mut device = NullDevice;\n        takes_device(\u0026mut device);\n    }\n}\n\n","traces":[{"line":16,"address":[1677856],"length":1,"stats":{"Line":1}},{"line":20,"address":[1677888,1677919],"length":1,"stats":{"Line":2}},{"line":21,"address":[1677961,1677920],"length":1,"stats":{"Line":2}},{"line":22,"address":[1677999,1677968],"length":1,"stats":{"Line":2}},{"line":23,"address":[1678016,1678000],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","document.rs"],"content":"//! Document trait\nuse crate::fitz::error::Result;\nuse crate::fitz::page::Page;\n\npub trait Document {\n    fn page_count(\u0026self) -\u003e i32;\n    fn load_page(\u0026self, page_num: i32) -\u003e Result\u003cBox\u003cdyn Page + '_\u003e\u003e;\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","error.rs"],"content":"//! Error handling for MicroPDF\n\nuse std::io;\nuse thiserror::Error;\n\n/// The main error type for MicroPDF operations\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    Generic(String),\n    #[error(\"System error: {0}\")]\n    System(#[from] io::Error),\n    #[error(\"Invalid argument: {0}\")]\n    Argument(String),\n    #[error(\"Limit exceeded: {0}\")]\n    Limit(String),\n    #[error(\"Unsupported: {0}\")]\n    Unsupported(String),\n    #[error(\"Format error: {0}\")]\n    Format(String),\n    #[error(\"Syntax error: {0}\")]\n    Syntax(String),\n    #[error(\"PDF error: {0}\")]\n    Pdf(String),\n    #[error(\"Encryption error: {0}\")]\n    Encryption(String),\n    #[error(\"Font error: {0}\")]\n    Font(String),\n    #[error(\"Image error: {0}\")]\n    Image(String),\n    #[error(\"Unexpected end of file\")]\n    Eof,\n    #[error(\"Operation aborted\")]\n    Abort,\n}\n\nimpl Error {\n    pub fn generic\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Generic(msg.into()) }\n    pub fn argument\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Argument(msg.into()) }\n    pub fn limit\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Limit(msg.into()) }\n    pub fn unsupported\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Unsupported(msg.into()) }\n    pub fn format\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Format(msg.into()) }\n    pub fn syntax\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Syntax(msg.into()) }\n    pub fn pdf\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Pdf(msg.into()) }\n    pub fn encryption\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Encryption(msg.into()) }\n    pub fn font\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Font(msg.into()) }\n    pub fn image\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Image(msg.into()) }\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_generic() {\n        let e = Error::generic(\"test error\");\n        assert!(matches!(e, Error::Generic(_)));\n        assert_eq!(format!(\"{}\", e), \"test error\");\n    }\n\n    #[test]\n    fn test_error_argument() {\n        let e = Error::argument(\"bad argument\");\n        assert!(matches!(e, Error::Argument(_)));\n        assert!(format!(\"{}\", e).contains(\"bad argument\"));\n    }\n\n    #[test]\n    fn test_error_limit() {\n        let e = Error::limit(\"size exceeded\");\n        assert!(matches!(e, Error::Limit(_)));\n        assert!(format!(\"{}\", e).contains(\"size exceeded\"));\n    }\n\n    #[test]\n    fn test_error_unsupported() {\n        let e = Error::unsupported(\"feature not supported\");\n        assert!(matches!(e, Error::Unsupported(_)));\n        assert!(format!(\"{}\", e).contains(\"feature not supported\"));\n    }\n\n    #[test]\n    fn test_error_format() {\n        let e = Error::format(\"invalid format\");\n        assert!(matches!(e, Error::Format(_)));\n        assert!(format!(\"{}\", e).contains(\"invalid format\"));\n    }\n\n    #[test]\n    fn test_error_syntax() {\n        let e = Error::syntax(\"syntax error at line 5\");\n        assert!(matches!(e, Error::Syntax(_)));\n        assert!(format!(\"{}\", e).contains(\"syntax error\"));\n    }\n\n    #[test]\n    fn test_error_pdf() {\n        let e = Error::pdf(\"invalid PDF structure\");\n        assert!(matches!(e, Error::Pdf(_)));\n        assert!(format!(\"{}\", e).contains(\"invalid PDF\"));\n    }\n\n    #[test]\n    fn test_error_encryption() {\n        let e = Error::encryption(\"wrong password\");\n        assert!(matches!(e, Error::Encryption(_)));\n        assert!(format!(\"{}\", e).contains(\"wrong password\"));\n    }\n\n    #[test]\n    fn test_error_font() {\n        let e = Error::font(\"font not found\");\n        assert!(matches!(e, Error::Font(_)));\n        assert!(format!(\"{}\", e).contains(\"font not found\"));\n    }\n\n    #[test]\n    fn test_error_image() {\n        let e = Error::image(\"corrupted image\");\n        assert!(matches!(e, Error::Image(_)));\n        assert!(format!(\"{}\", e).contains(\"corrupted image\"));\n    }\n\n    #[test]\n    fn test_error_eof() {\n        let e = Error::Eof;\n        assert!(matches!(e, Error::Eof));\n        assert!(format!(\"{}\", e).contains(\"end of file\"));\n    }\n\n    #[test]\n    fn test_error_abort() {\n        let e = Error::Abort;\n        assert!(matches!(e, Error::Abort));\n        assert!(format!(\"{}\", e).contains(\"aborted\"));\n    }\n\n    #[test]\n    fn test_error_from_io_error() {\n        let io_err = io::Error::new(io::ErrorKind::NotFound, \"file not found\");\n        let e: Error = io_err.into();\n        assert!(matches!(e, Error::System(_)));\n        assert!(format!(\"{}\", e).contains(\"file not found\"));\n    }\n\n    #[test]\n    fn test_error_debug() {\n        let e = Error::generic(\"test\");\n        let debug = format!(\"{:?}\", e);\n        assert!(debug.contains(\"Generic\"));\n    }\n\n    #[test]\n    fn test_result_type() {\n        fn returns_ok() -\u003e Result\u003ci32\u003e {\n            Ok(42)\n        }\n\n        fn returns_err() -\u003e Result\u003ci32\u003e {\n            Err(Error::generic(\"error\"))\n        }\n\n        assert_eq!(returns_ok().unwrap(), 42);\n        assert!(returns_err().is_err());\n    }\n}\n\n","traces":[{"line":38,"address":[1726880,1726903],"length":1,"stats":{"Line":2}},{"line":39,"address":[1726999,1726976],"length":1,"stats":{"Line":2}},{"line":40,"address":[2042432,2042455],"length":1,"stats":{"Line":2}},{"line":41,"address":[2042528,2042551],"length":1,"stats":{"Line":2}},{"line":42,"address":[1727072,1727085],"length":1,"stats":{"Line":5}},{"line":43,"address":[2042823,2042800],"length":1,"stats":{"Line":2}},{"line":44,"address":[2042896,2042919],"length":1,"stats":{"Line":2}},{"line":45,"address":[2043015,2042992],"length":1,"stats":{"Line":2}},{"line":46,"address":[2043088,2043111],"length":1,"stats":{"Line":2}},{"line":47,"address":[2043184,2043207],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","font.rs"],"content":"//! Font handling\npub struct Font { name: String }\nimpl Font {\n    pub fn new(name: \u0026str) -\u003e Self { Self { name: name.to_string() } }\n    pub fn name(\u0026self) -\u003e \u0026str { \u0026self.name }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_new() {\n        let font = Font::new(\"Helvetica\");\n        assert_eq!(font.name(), \"Helvetica\");\n    }\n\n    #[test]\n    fn test_font_empty_name() {\n        let font = Font::new(\"\");\n        assert_eq!(font.name(), \"\");\n    }\n\n    #[test]\n    fn test_font_unicode_name() {\n        let font = Font::new(\"Arial\");\n        assert_eq!(font.name(), \"Arial\");\n    }\n}\n\n","traces":[{"line":4,"address":[1681607,1681584],"length":1,"stats":{"Line":6}},{"line":5,"address":[1681664,1681669],"length":1,"stats":{"Line":6}}],"covered":2,"coverable":2},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","geometry.rs"],"content":"//! Geometry primitives - Point, Rect, Matrix, Quad\n\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Point { pub x: f32, pub y: f32 }\n\nimpl Point {\n    pub const ORIGIN: Point = Point { x: 0.0, y: 0.0 };\n    pub fn new(x: f32, y: f32) -\u003e Self { Self { x, y } }\n    pub fn transform(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            x: self.x * m.a + self.y * m.c + m.e,\n            y: self.x * m.b + self.y * m.d + m.f,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Rect { pub x0: f32, pub y0: f32, pub x1: f32, pub y1: f32 }\n\nimpl Rect {\n    pub const EMPTY: Rect = Rect { x0: INFINITY, y0: INFINITY, x1: NEG_INFINITY, y1: NEG_INFINITY };\n    pub const INFINITE: Rect = Rect { x0: NEG_INFINITY, y0: NEG_INFINITY, x1: INFINITY, y1: INFINITY };\n    pub const UNIT: Rect = Rect { x0: 0.0, y0: 0.0, x1: 1.0, y1: 1.0 };\n\n    pub fn new(x0: f32, y0: f32, x1: f32, y1: f32) -\u003e Self { Self { x0, y0, x1, y1 } }\n    pub fn width(\u0026self) -\u003e f32 { self.x1 - self.x0 }\n    pub fn height(\u0026self) -\u003e f32 { self.y1 - self.y0 }\n    pub fn is_empty(\u0026self) -\u003e bool { self.x0 \u003e= self.x1 || self.y0 \u003e= self.y1 }\n    pub fn is_infinite(\u0026self) -\u003e bool { self.x0 == NEG_INFINITY }\n    pub fn contains(\u0026self, x: f32, y: f32) -\u003e bool {\n        x \u003e= self.x0 \u0026\u0026 x \u003c self.x1 \u0026\u0026 y \u003e= self.y0 \u0026\u0026 y \u003c self.y1\n    }\n    pub fn union(\u0026self, other: \u0026Rect) -\u003e Rect {\n        Rect {\n            x0: self.x0.min(other.x0), y0: self.y0.min(other.y0),\n            x1: self.x1.max(other.x1), y1: self.y1.max(other.y1),\n        }\n    }\n    pub fn intersect(\u0026self, other: \u0026Rect) -\u003e Rect {\n        Rect {\n            x0: self.x0.max(other.x0), y0: self.y0.max(other.y0),\n            x1: self.x1.min(other.x1), y1: self.y1.min(other.y1),\n        }\n    }\n    pub fn include_point(\u0026mut self, p: Point) {\n        self.x0 = self.x0.min(p.x); self.y0 = self.y0.min(p.y);\n        self.x1 = self.x1.max(p.x); self.y1 = self.y1.max(p.y);\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct IRect { pub x0: i32, pub y0: i32, pub x1: i32, pub y1: i32 }\n\nimpl IRect {\n    pub fn new(x0: i32, y0: i32, x1: i32, y1: i32) -\u003e Self { Self { x0, y0, x1, y1 } }\n    pub fn width(\u0026self) -\u003e i32 { self.x1 - self.x0 }\n    pub fn height(\u0026self) -\u003e i32 { self.y1 - self.y0 }\n    pub fn is_empty(\u0026self) -\u003e bool { self.x0 \u003e= self.x1 || self.y0 \u003e= self.y1 }\n}\n\nimpl From\u003cRect\u003e for IRect {\n    fn from(r: Rect) -\u003e Self {\n        IRect { x0: r.x0.floor() as i32, y0: r.y0.floor() as i32,\n                x1: r.x1.ceil() as i32, y1: r.y1.ceil() as i32 }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Matrix { pub a: f32, pub b: f32, pub c: f32, pub d: f32, pub e: f32, pub f: f32 }\n\nimpl Default for Matrix {\n    fn default() -\u003e Self { Self::IDENTITY }\n}\n\nimpl Matrix {\n    pub const IDENTITY: Matrix = Matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 };\n\n    pub fn new(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32) -\u003e Self { Self { a, b, c, d, e, f } }\n    pub fn translate(tx: f32, ty: f32) -\u003e Self { Self { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: tx, f: ty } }\n    pub fn scale(sx: f32, sy: f32) -\u003e Self { Self { a: sx, b: 0.0, c: 0.0, d: sy, e: 0.0, f: 0.0 } }\n    pub fn rotate(degrees: f32) -\u003e Self {\n        let rad = degrees * std::f32::consts::PI / 180.0;\n        let (s, c) = (rad.sin(), rad.cos());\n        Self { a: c, b: s, c: -s, d: c, e: 0.0, f: 0.0 }\n    }\n    pub fn concat(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            a: self.a * m.a + self.b * m.c,\n            b: self.a * m.b + self.b * m.d,\n            c: self.c * m.a + self.d * m.c,\n            d: self.c * m.b + self.d * m.d,\n            e: self.e * m.a + self.f * m.c + m.e,\n            f: self.e * m.b + self.f * m.d + m.f,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Quad { pub ul: Point, pub ur: Point, pub ll: Point, pub lr: Point }\n\nimpl Quad {\n    pub fn from_rect(r: \u0026Rect) -\u003e Self {\n        Self {\n            ul: Point::new(r.x0, r.y0), ur: Point::new(r.x1, r.y0),\n            ll: Point::new(r.x0, r.y1), lr: Point::new(r.x1, r.y1),\n        }\n    }\n    pub fn transform(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            ul: self.ul.transform(m), ur: self.ur.transform(m),\n            ll: self.ll.transform(m), lr: self.lr.transform(m),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Point tests\n    #[test]\n    fn test_point_origin() {\n        assert_eq!(Point::ORIGIN.x, 0.0);\n        assert_eq!(Point::ORIGIN.y, 0.0);\n    }\n\n    #[test]\n    fn test_point_new() {\n        let p = Point::new(3.0, 4.0);\n        assert_eq!(p.x, 3.0);\n        assert_eq!(p.y, 4.0);\n    }\n\n    #[test]\n    fn test_point_transform_identity() {\n        let p = Point::new(5.0, 10.0);\n        let transformed = p.transform(\u0026Matrix::IDENTITY);\n        assert_eq!(transformed.x, 5.0);\n        assert_eq!(transformed.y, 10.0);\n    }\n\n    #[test]\n    fn test_point_transform_translate() {\n        let p = Point::new(5.0, 10.0);\n        let m = Matrix::translate(2.0, 3.0);\n        let transformed = p.transform(\u0026m);\n        assert!((transformed.x - 7.0).abs() \u003c 0.001);\n        assert!((transformed.y - 13.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_point_transform_scale() {\n        let p = Point::new(5.0, 10.0);\n        let m = Matrix::scale(2.0, 3.0);\n        let transformed = p.transform(\u0026m);\n        assert!((transformed.x - 10.0).abs() \u003c 0.001);\n        assert!((transformed.y - 30.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_point_default() {\n        let p: Point = Default::default();\n        assert_eq!(p.x, 0.0);\n        assert_eq!(p.y, 0.0);\n    }\n\n    // Rect tests\n    #[test]\n    fn test_rect_new() {\n        let r = Rect::new(1.0, 2.0, 10.0, 20.0);\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_rect_width_height() {\n        let r = Rect::new(0.0, 0.0, 10.0, 20.0);\n        assert_eq!(r.width(), 10.0);\n        assert_eq!(r.height(), 20.0);\n    }\n\n    #[test]\n    fn test_rect_is_empty() {\n        assert!(Rect::EMPTY.is_empty());\n        assert!(!Rect::UNIT.is_empty());\n        assert!(Rect::new(10.0, 10.0, 5.0, 5.0).is_empty()); // inverted\n    }\n\n    #[test]\n    fn test_rect_is_infinite() {\n        assert!(Rect::INFINITE.is_infinite());\n        assert!(!Rect::UNIT.is_infinite());\n    }\n\n    #[test]\n    fn test_rect_contains() {\n        let r = Rect::new(0.0, 0.0, 10.0, 10.0);\n        assert!(r.contains(5.0, 5.0));\n        assert!(r.contains(0.0, 0.0));\n        assert!(!r.contains(10.0, 10.0)); // exclusive upper bound\n        assert!(!r.contains(-1.0, 5.0));\n        assert!(!r.contains(5.0, -1.0));\n        assert!(!r.contains(11.0, 5.0));\n        assert!(!r.contains(5.0, 11.0));\n    }\n\n    #[test]\n    fn test_rect_union() {\n        let r1 = Rect::new(0.0, 0.0, 5.0, 5.0);\n        let r2 = Rect::new(3.0, 3.0, 10.0, 10.0);\n        let u = r1.union(\u0026r2);\n        assert_eq!(u.x0, 0.0);\n        assert_eq!(u.y0, 0.0);\n        assert_eq!(u.x1, 10.0);\n        assert_eq!(u.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_intersect() {\n        let r1 = Rect::new(0.0, 0.0, 10.0, 10.0);\n        let r2 = Rect::new(5.0, 5.0, 15.0, 15.0);\n        let i = r1.intersect(\u0026r2);\n        assert_eq!(i.x0, 5.0);\n        assert_eq!(i.y0, 5.0);\n        assert_eq!(i.x1, 10.0);\n        assert_eq!(i.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_include_point() {\n        let mut r = Rect::EMPTY;\n        r.include_point(Point::new(5.0, 5.0));\n        r.include_point(Point::new(0.0, 0.0));\n        r.include_point(Point::new(10.0, 10.0));\n        assert_eq!(r.x0, 0.0);\n        assert_eq!(r.y0, 0.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_constants() {\n        assert!(Rect::EMPTY.is_empty());\n        assert!(Rect::INFINITE.is_infinite());\n        assert_eq!(Rect::UNIT.width(), 1.0);\n        assert_eq!(Rect::UNIT.height(), 1.0);\n    }\n\n    // IRect tests\n    #[test]\n    fn test_irect_new() {\n        let r = IRect::new(1, 2, 10, 20);\n        assert_eq!(r.x0, 1);\n        assert_eq!(r.y0, 2);\n        assert_eq!(r.x1, 10);\n        assert_eq!(r.y1, 20);\n    }\n\n    #[test]\n    fn test_irect_width_height() {\n        let r = IRect::new(0, 0, 10, 20);\n        assert_eq!(r.width(), 10);\n        assert_eq!(r.height(), 20);\n    }\n\n    #[test]\n    fn test_irect_is_empty() {\n        assert!(IRect::new(5, 5, 5, 5).is_empty());\n        assert!(IRect::new(10, 10, 5, 5).is_empty());\n        assert!(!IRect::new(0, 0, 10, 10).is_empty());\n    }\n\n    #[test]\n    fn test_irect_from_rect() {\n        let r = Rect::new(0.5, 1.5, 9.5, 19.5);\n        let ir: IRect = r.into();\n        assert_eq!(ir.x0, 0);\n        assert_eq!(ir.y0, 1);\n        assert_eq!(ir.x1, 10);\n        assert_eq!(ir.y1, 20);\n    }\n\n    // Matrix tests\n    #[test]\n    fn test_matrix_identity() {\n        let m = Matrix::IDENTITY;\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 0.0);\n        assert_eq!(m.c, 0.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_matrix_new() {\n        let m = Matrix::new(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 2.0);\n        assert_eq!(m.c, 3.0);\n        assert_eq!(m.d, 4.0);\n        assert_eq!(m.e, 5.0);\n        assert_eq!(m.f, 6.0);\n    }\n\n    #[test]\n    fn test_matrix_translate() {\n        let m = Matrix::translate(10.0, 20.0);\n        assert_eq!(m.e, 10.0);\n        assert_eq!(m.f, 20.0);\n        // Should be identity otherwise\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n    }\n\n    #[test]\n    fn test_matrix_scale() {\n        let m = Matrix::scale(2.0, 3.0);\n        assert_eq!(m.a, 2.0);\n        assert_eq!(m.d, 3.0);\n    }\n\n    #[test]\n    fn test_matrix_rotate() {\n        let m = Matrix::rotate(90.0);\n        // cos(90)  0, sin(90) = 1\n        assert!((m.a - 0.0).abs() \u003c 0.001);\n        assert!((m.b - 1.0).abs() \u003c 0.001);\n        assert!((m.c - (-1.0)).abs() \u003c 0.001);\n        assert!((m.d - 0.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_matrix_concat_identity() {\n        let m1 = Matrix::scale(2.0, 3.0);\n        let m2 = Matrix::IDENTITY;\n        let result = m1.concat(\u0026m2);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 3.0);\n    }\n\n    #[test]\n    fn test_matrix_concat_scale_translate() {\n        let scale = Matrix::scale(2.0, 2.0);\n        let translate = Matrix::translate(10.0, 10.0);\n        let result = scale.concat(\u0026translate);\n        // Scaling first, then translating\n        assert_eq!(result.e, 10.0);\n        assert_eq!(result.f, 10.0);\n    }\n\n    #[test]\n    fn test_matrix_default() {\n        let m: Matrix = Default::default();\n        assert_eq!(m, Matrix::IDENTITY);\n    }\n\n    // Quad tests\n    #[test]\n    fn test_quad_from_rect() {\n        let r = Rect::new(0.0, 0.0, 10.0, 20.0);\n        let q = Quad::from_rect(\u0026r);\n        assert_eq!(q.ul.x, 0.0);\n        assert_eq!(q.ul.y, 0.0);\n        assert_eq!(q.ur.x, 10.0);\n        assert_eq!(q.ur.y, 0.0);\n        assert_eq!(q.ll.x, 0.0);\n        assert_eq!(q.ll.y, 20.0);\n        assert_eq!(q.lr.x, 10.0);\n        assert_eq!(q.lr.y, 20.0);\n    }\n\n    #[test]\n    fn test_quad_transform() {\n        let r = Rect::new(0.0, 0.0, 10.0, 10.0);\n        let q = Quad::from_rect(\u0026r);\n        let m = Matrix::translate(5.0, 5.0);\n        let transformed = q.transform(\u0026m);\n        assert_eq!(transformed.ul.x, 5.0);\n        assert_eq!(transformed.ul.y, 5.0);\n        assert_eq!(transformed.lr.x, 15.0);\n        assert_eq!(transformed.lr.y, 15.0);\n    }\n\n    #[test]\n    fn test_quad_default() {\n        let q: Quad = Default::default();\n        assert_eq!(q.ul, Point::default());\n        assert_eq!(q.ur, Point::default());\n        assert_eq!(q.ll, Point::default());\n        assert_eq!(q.lr, Point::default());\n    }\n}\n\n","traces":[{"line":10,"address":[1634928,1634940],"length":1,"stats":{"Line":2}},{"line":11,"address":[1634944],"length":1,"stats":{"Line":1}},{"line":13,"address":[1634954,1634972],"length":1,"stats":{"Line":5}},{"line":14,"address":[1634967,1635004],"length":1,"stats":{"Line":5}},{"line":27,"address":[1635040,1635067],"length":1,"stats":{"Line":2}},{"line":28,"address":[1635088,1635093],"length":1,"stats":{"Line":2}},{"line":29,"address":[1635109,1635104],"length":1,"stats":{"Line":3}},{"line":30,"address":[1635120,1635130],"length":1,"stats":{"Line":5}},{"line":31,"address":[1635184,1635189],"length":1,"stats":{"Line":2}},{"line":32,"address":[1635216],"length":1,"stats":{"Line":1}},{"line":33,"address":[1635250],"length":1,"stats":{"Line":1}},{"line":35,"address":[1635344],"length":1,"stats":{"Line":1}},{"line":37,"address":[1635378],"length":1,"stats":{"Line":1}},{"line":38,"address":[1635438],"length":1,"stats":{"Line":1}},{"line":41,"address":[1635536],"length":1,"stats":{"Line":1}},{"line":43,"address":[1635570],"length":1,"stats":{"Line":1}},{"line":44,"address":[1635630],"length":1,"stats":{"Line":1}},{"line":47,"address":[1635728],"length":1,"stats":{"Line":1}},{"line":48,"address":[1635781],"length":1,"stats":{"Line":2}},{"line":49,"address":[1635831],"length":1,"stats":{"Line":2}},{"line":57,"address":[1635908,1635888],"length":1,"stats":{"Line":6}},{"line":58,"address":[1635936,1635945],"length":1,"stats":{"Line":2}},{"line":59,"address":[1635993,1635984],"length":1,"stats":{"Line":2}},{"line":60,"address":[1636032,1636042],"length":1,"stats":{"Line":2}},{"line":64,"address":[1636096],"length":1,"stats":{"Line":1}},{"line":65,"address":[1636114,1636328],"length":1,"stats":{"Line":2}},{"line":66,"address":[1636211],"length":1,"stats":{"Line":1}},{"line":74,"address":[1636352,1636355],"length":1,"stats":{"Line":2}},{"line":80,"address":[1636400,1636439],"length":1,"stats":{"Line":2}},{"line":81,"address":[1636495,1636480],"length":1,"stats":{"Line":3}},{"line":82,"address":[1636575,1636560],"length":1,"stats":{"Line":3}},{"line":83,"address":[1636624],"length":1,"stats":{"Line":1}},{"line":84,"address":[1636644],"length":1,"stats":{"Line":1}},{"line":85,"address":[1636679],"length":1,"stats":{"Line":1}},{"line":86,"address":[1636731],"length":1,"stats":{"Line":1}},{"line":88,"address":[1636800],"length":1,"stats":{"Line":1}},{"line":90,"address":[1636813],"length":1,"stats":{"Line":2}},{"line":91,"address":[1636835],"length":1,"stats":{"Line":2}},{"line":92,"address":[1636858],"length":1,"stats":{"Line":2}},{"line":93,"address":[1636881],"length":1,"stats":{"Line":2}},{"line":94,"address":[1636905],"length":1,"stats":{"Line":2}},{"line":95,"address":[1636933],"length":1,"stats":{"Line":2}},{"line":104,"address":[1636992],"length":1,"stats":{"Line":2}},{"line":106,"address":[1637015],"length":1,"stats":{"Line":2}},{"line":107,"address":[1637076],"length":1,"stats":{"Line":2}},{"line":110,"address":[1637216],"length":1,"stats":{"Line":1}},{"line":112,"address":[1637264],"length":1,"stats":{"Line":1}},{"line":113,"address":[1637320],"length":1,"stats":{"Line":1}}],"covered":48,"coverable":48},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","image.rs"],"content":"//! Image handling\nuse crate::fitz::colorspace::Colorspace;\nuse crate::fitz::pixmap::Pixmap;\n\npub struct Image { width: i32, height: i32, pixmap: Option\u003cPixmap\u003e }\n\nimpl Image {\n    pub fn new(width: i32, height: i32, pixmap: Option\u003cPixmap\u003e) -\u003e Self {\n        Self { width, height, pixmap }\n    }\n    pub fn width(\u0026self) -\u003e i32 { self.width }\n    pub fn height(\u0026self) -\u003e i32 { self.height }\n    pub fn pixmap(\u0026self) -\u003e Option\u003c\u0026Pixmap\u003e { self.pixmap.as_ref() }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_image_new_without_pixmap() {\n        let img = Image::new(100, 50, None);\n        assert_eq!(img.width(), 100);\n        assert_eq!(img.height(), 50);\n        assert!(img.pixmap().is_none());\n    }\n\n    #[test]\n    fn test_image_new_with_pixmap() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, false).unwrap();\n        let img = Image::new(100, 50, Some(pm));\n\n        assert_eq!(img.width(), 100);\n        assert_eq!(img.height(), 50);\n        assert!(img.pixmap().is_some());\n\n        let pm_ref = img.pixmap().unwrap();\n        assert_eq!(pm_ref.width(), 100);\n        assert_eq!(pm_ref.height(), 50);\n    }\n\n    #[test]\n    fn test_image_dimensions() {\n        let img = Image::new(1920, 1080, None);\n        assert_eq!(img.width(), 1920);\n        assert_eq!(img.height(), 1080);\n    }\n}\n\n","traces":[{"line":8,"address":[2132656],"length":1,"stats":{"Line":1}},{"line":11,"address":[2132693,2132688],"length":1,"stats":{"Line":4}},{"line":12,"address":[2132704,2132709],"length":1,"stats":{"Line":4}},{"line":13,"address":[2132725,2132720],"length":1,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","mod.rs"],"content":"//! Fitz - Core rendering and document infrastructure\n//!\n//! This module provides foundational types for document handling,\n//! geometry, rendering, and I/O operations.\n\npub mod error;\npub mod geometry;\npub mod buffer;\npub mod stream;\npub mod colorspace;\npub mod pixmap;\npub mod font;\npub mod path;\npub mod text;\npub mod image;\npub mod device;\npub mod document;\npub mod page;\n\n#[cfg(feature = \"parallel\")]\npub mod parallel;\n\n#[cfg(feature = \"async\")]\npub mod async_io;\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","page.rs"],"content":"//! Page abstraction\nuse crate::fitz::geometry::Rect;\n\npub trait Page {\n    fn bounds(\u0026self) -\u003e Rect;\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","parallel.rs"],"content":"//! Parallel processing utilities using Rayon\n//!\n//! This module provides utilities for parallel processing of PDF operations,\n//! enabling significant performance improvements on multi-core systems.\n\nuse rayon::prelude::*;\nuse std::path::Path;\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::Result;\nuse crate::fitz::pixmap::Pixmap;\nuse crate::fitz::stream::Stream;\n\n/// Process multiple buffers in parallel using a custom function.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::parallel::process_buffers;\n/// use micropdf::fitz::buffer::Buffer;\n///\n/// let buffers = vec![Buffer::from_slice(b\"data1\"), Buffer::from_slice(b\"data2\")];\n/// let results: Vec\u003cusize\u003e = process_buffers(\u0026buffers, |b| b.len());\n/// ```\npub fn process_buffers\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cR\u003e\nwhere\n    F: Fn(\u0026Buffer) -\u003e R + Sync + Send,\n    R: Send,\n{\n    buffers.par_iter().map(f).collect()\n}\n\n/// Process multiple buffers with results in parallel.\npub fn process_buffers_result\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\nwhere\n    F: Fn(\u0026Buffer) -\u003e Result\u003cR\u003e + Sync + Send,\n    R: Send,\n{\n    buffers.par_iter().map(f).collect()\n}\n\n/// Transform buffer data in parallel chunks.\n///\n/// Splits the buffer into chunks and applies the transformation function\n/// to each chunk in parallel, then reassembles the results.\npub fn parallel_transform\u003cF\u003e(buffer: \u0026Buffer, chunk_size: usize, f: F) -\u003e Buffer\nwhere\n    F: Fn(\u0026[u8]) -\u003e Vec\u003cu8\u003e + Sync + Send,\n{\n    let data = buffer.to_vec();\n    let chunks: Vec\u003cVec\u003cu8\u003e\u003e = data\n        .par_chunks(chunk_size)\n        .map(f)\n        .collect();\n\n    let total_len: usize = chunks.iter().map(|c| c.len()).sum();\n    let mut result = Vec::with_capacity(total_len);\n    for chunk in chunks {\n        result.extend(chunk);\n    }\n    Buffer::from_data(result)\n}\n\n/// Read multiple files in parallel.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::parallel::read_files;\n///\n/// let paths = vec![\"file1.pdf\", \"file2.pdf\", \"file3.pdf\"];\n/// let results = read_files(\u0026paths);\n/// ```\npub fn read_files\u003cP: AsRef\u003cPath\u003e + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n    paths\n        .par_iter()\n        .map(|path| {\n            let mut stream = Stream::open_file(path)?;\n            stream.read_all(0)\n        })\n        .collect()\n}\n\n/// Process multiple pixmaps in parallel.\npub fn process_pixmaps\u003cF, R\u003e(pixmaps: \u0026[Pixmap], f: F) -\u003e Vec\u003cR\u003e\nwhere\n    F: Fn(\u0026Pixmap) -\u003e R + Sync + Send,\n    R: Send,\n{\n    pixmaps.par_iter().map(f).collect()\n}\n\n/// Apply a pixel transformation to multiple pixmaps in parallel.\npub fn transform_pixmaps\u003cF\u003e(pixmaps: Vec\u003cPixmap\u003e, f: F) -\u003e Vec\u003cPixmap\u003e\nwhere\n    F: Fn(Pixmap) -\u003e Pixmap + Sync + Send,\n{\n    pixmaps.into_par_iter().map(f).collect()\n}\n\n/// Batch process items with a parallel iterator.\npub fn batch_process\u003cT, F, R\u003e(items: Vec\u003cT\u003e, f: F) -\u003e Vec\u003cR\u003e\nwhere\n    T: Send,\n    F: Fn(T) -\u003e R + Sync + Send,\n    R: Send,\n{\n    items.into_par_iter().map(f).collect()\n}\n\n/// Batch process items with results.\npub fn batch_process_result\u003cT, F, R\u003e(items: Vec\u003cT\u003e, f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\nwhere\n    T: Send,\n    F: Fn(T) -\u003e Result\u003cR\u003e + Sync + Send,\n    R: Send,\n{\n    items.into_par_iter().map(f).collect()\n}\n\n/// Filter items in parallel.\npub fn parallel_filter\u003cT, F\u003e(items: Vec\u003cT\u003e, predicate: F) -\u003e Vec\u003cT\u003e\nwhere\n    T: Send,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.into_par_iter().filter(predicate).collect()\n}\n\n/// Find items in parallel that match a predicate.\npub fn parallel_find\u003cT, F\u003e(items: \u0026[T], predicate: F) -\u003e Option\u003c\u0026T\u003e\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.par_iter().find_any(|item| predicate(item))\n}\n\n/// Count items matching a predicate in parallel.\npub fn parallel_count\u003cT, F\u003e(items: \u0026[T], predicate: F) -\u003e usize\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.par_iter().filter(|item| predicate(*item)).count()\n}\n\n/// Sum values extracted from items in parallel.\npub fn parallel_sum\u003cT, F\u003e(items: \u0026[T], f: F) -\u003e i64\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e i64 + Sync + Send,\n{\n    items.par_iter().map(f).sum()\n}\n\n/// Get the number of available parallel threads.\npub fn num_threads() -\u003e usize {\n    rayon::current_num_threads()\n}\n\n/// Execute work with a specific thread pool size.\npub fn with_thread_count\u003cF, R\u003e(num_threads: usize, f: F) -\u003e R\nwhere\n    F: FnOnce() -\u003e R + Send,\n    R: Send,\n{\n    let pool = rayon::ThreadPoolBuilder::new()\n        .num_threads(num_threads)\n        .build()\n        .expect(\"Failed to create thread pool\");\n    pool.install(f)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_process_buffers() {\n        let buffers = vec![\n            Buffer::from_slice(\u0026[1, 2, 3]),\n            Buffer::from_slice(\u0026[4, 5]),\n            Buffer::from_slice(\u0026[6, 7, 8, 9]),\n        ];\n\n        let lengths: Vec\u003cusize\u003e = process_buffers(\u0026buffers, |b| b.len());\n        assert_eq!(lengths, vec![3, 2, 4]);\n    }\n\n    #[test]\n    fn test_parallel_transform() {\n        let buffer = Buffer::from_slice(\u0026[1, 2, 3, 4, 5, 6, 7, 8]);\n\n        let result = parallel_transform(\u0026buffer, 2, |chunk| {\n            chunk.iter().map(|b| b * 2).collect()\n        });\n\n        assert_eq!(result.to_vec(), vec![2, 4, 6, 8, 10, 12, 14, 16]);\n    }\n\n    #[test]\n    fn test_batch_process() {\n        let items = vec![1, 2, 3, 4, 5];\n        let results: Vec\u003ci32\u003e = batch_process(items, |x| x * x);\n        assert_eq!(results, vec![1, 4, 9, 16, 25]);\n    }\n\n    #[test]\n    fn test_parallel_filter() {\n        let items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let evens = parallel_filter(items, |x| x % 2 == 0);\n        assert_eq!(evens, vec![2, 4, 6, 8, 10]);\n    }\n\n    #[test]\n    fn test_parallel_count() {\n        let items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let count = parallel_count(\u0026items, |x| *x \u003e 5);\n        assert_eq!(count, 5);\n    }\n\n    #[test]\n    fn test_parallel_sum() {\n        let items = vec![1i64, 2, 3, 4, 5];\n        let sum = parallel_sum(\u0026items, |x| *x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_num_threads() {\n        let threads = num_threads();\n        assert!(threads \u003e 0);\n    }\n\n    #[test]\n    fn test_with_thread_count() {\n        let result = with_thread_count(2, || {\n            assert!(rayon::current_num_threads() \u003c= 2);\n            42\n        });\n        assert_eq!(result, 42);\n    }\n}\n\n","traces":[{"line":24,"address":[1408390,1408224],"length":1,"stats":{"Line":1}},{"line":29,"address":[1408336,1408274],"length":1,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[1408416,1409350,1409396],"length":1,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[1408778,1409424,1409449,1408710],"length":1,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[1409580,1409472],"length":1,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[1409600,1409708],"length":1,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[1409728,1409759],"length":1,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[1410000,1409872],"length":1,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[1683408],"length":1,"stats":{"Line":1}},{"line":157,"address":[1683409],"length":1,"stats":{"Line":1}},{"line":161,"address":[1410301,1410016,1410307],"length":1,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":1}}],"covered":24,"coverable":36},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","path.rs"],"content":"//! Vector paths\nuse crate::fitz::geometry::{Point, Rect};\n\npub struct Path { elements: Vec\u003cPathElement\u003e }\npub enum PathElement { MoveTo(Point), LineTo(Point), CurveTo(Point, Point, Point), Close }\n\nimpl Path {\n    pub fn new() -\u003e Self { Self { elements: Vec::new() } }\n    pub fn move_to(\u0026mut self, p: Point) { self.elements.push(PathElement::MoveTo(p)); }\n    pub fn line_to(\u0026mut self, p: Point) { self.elements.push(PathElement::LineTo(p)); }\n    pub fn curve_to(\u0026mut self, p1: Point, p2: Point, p3: Point) {\n        self.elements.push(PathElement::CurveTo(p1, p2, p3));\n    }\n    pub fn close(\u0026mut self) { self.elements.push(PathElement::Close); }\n    pub fn bounds(\u0026self) -\u003e Rect {\n        let mut bbox = Rect::EMPTY;\n        for el in \u0026self.elements {\n            match el {\n                PathElement::MoveTo(p) | PathElement::LineTo(p) =\u003e bbox.include_point(*p),\n                PathElement::CurveTo(p1, p2, p3) =\u003e {\n                    bbox.include_point(*p1); bbox.include_point(*p2); bbox.include_point(*p3);\n                }\n                PathElement::Close =\u003e {}\n            }\n        }\n        bbox\n    }\n    pub fn len(\u0026self) -\u003e usize { self.elements.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.elements.is_empty() }\n}\nimpl Default for Path { fn default() -\u003e Self { Self::new() } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_path_new() {\n        let path = Path::new();\n        assert!(path.is_empty());\n        assert_eq!(path.len(), 0);\n    }\n\n    #[test]\n    fn test_path_default() {\n        let path: Path = Default::default();\n        assert!(path.is_empty());\n    }\n\n    #[test]\n    fn test_path_move_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(10.0, 20.0));\n        assert_eq!(path.len(), 1);\n        assert!(!path.is_empty());\n    }\n\n    #[test]\n    fn test_path_line_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        assert_eq!(path.len(), 2);\n    }\n\n    #[test]\n    fn test_path_curve_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.curve_to(\n            Point::new(5.0, 10.0),\n            Point::new(15.0, 10.0),\n            Point::new(20.0, 0.0),\n        );\n        assert_eq!(path.len(), 2);\n    }\n\n    #[test]\n    fn test_path_close() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        path.close();\n        assert_eq!(path.len(), 4);\n    }\n\n    #[test]\n    fn test_path_bounds_simple() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(100.0, 50.0));\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 100.0);\n        assert_eq!(bounds.y1, 50.0);\n    }\n\n    #[test]\n    fn test_path_bounds_with_curve() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.curve_to(\n            Point::new(50.0, 100.0),\n            Point::new(100.0, 100.0),\n            Point::new(150.0, 0.0),\n        );\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 150.0);\n        assert_eq!(bounds.y1, 100.0);\n    }\n\n    #[test]\n    fn test_path_bounds_empty() {\n        let path = Path::new();\n        let bounds = path.bounds();\n        assert!(bounds.is_empty());\n    }\n\n    #[test]\n    fn test_path_bounds_with_close() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        path.close();\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 10.0);\n        assert_eq!(bounds.y1, 10.0);\n    }\n\n    #[test]\n    fn test_path_rectangle() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(100.0, 0.0));\n        path.line_to(Point::new(100.0, 50.0));\n        path.line_to(Point::new(0.0, 50.0));\n        path.close();\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.width(), 100.0);\n        assert_eq!(bounds.height(), 50.0);\n    }\n}\n\n","traces":[{"line":8,"address":[1614112,1614125],"length":1,"stats":{"Line":2}},{"line":9,"address":[1614197,1614176],"length":1,"stats":{"Line":2}},{"line":10,"address":[1614240,1614261],"length":1,"stats":{"Line":2}},{"line":11,"address":[1614304],"length":1,"stats":{"Line":1}},{"line":12,"address":[1614349],"length":1,"stats":{"Line":1}},{"line":14,"address":[1614416,1614425],"length":1,"stats":{"Line":2}},{"line":15,"address":[1614464],"length":1,"stats":{"Line":1}},{"line":16,"address":[1614499],"length":1,"stats":{"Line":1}},{"line":17,"address":[1614523,1614538],"length":1,"stats":{"Line":2}},{"line":18,"address":[1614596,1614675,1614694],"length":1,"stats":{"Line":4}},{"line":19,"address":[1614666,1614685,1614815],"length":1,"stats":{"Line":5}},{"line":20,"address":[1614701],"length":1,"stats":{"Line":1}},{"line":21,"address":[1614740],"length":1,"stats":{"Line":1}},{"line":26,"address":[1614634],"length":1,"stats":{"Line":1}},{"line":28,"address":[1614848,1614853],"length":1,"stats":{"Line":2}},{"line":29,"address":[1614864,1614869],"length":1,"stats":{"Line":2}},{"line":31,"address":[1614888,1614880],"length":1,"stats":{"Line":2}}],"covered":17,"coverable":17},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","pixmap.rs"],"content":"//! Pixmap - Pixel buffer for rendering\n\nuse crate::fitz::colorspace::Colorspace;\nuse crate::fitz::error::{Error, Result};\nuse crate::fitz::geometry::IRect;\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct Pixmap { inner: Arc\u003cPixmapInner\u003e }\n\n#[derive(Clone)]\nstruct PixmapInner {\n    x: i32, y: i32, w: i32, h: i32, n: u8, alpha: u8,\n    stride: usize, colorspace: Option\u003cColorspace\u003e, samples: Vec\u003cu8\u003e,\n}\n\nimpl Pixmap {\n    pub fn new(colorspace: Option\u003cColorspace\u003e, w: i32, h: i32, alpha: bool) -\u003e Result\u003cSelf\u003e {\n        if w \u003c= 0 || h \u003c= 0 { return Err(Error::argument(\"Invalid dimensions\")); }\n        let n = match \u0026colorspace {\n            Some(cs) =\u003e cs.n() + if alpha { 1 } else { 0 },\n            None if alpha =\u003e 1,\n            None =\u003e return Err(Error::argument(\"Pixmap must have colorspace or alpha\")),\n        };\n        let stride = (w as usize) * (n as usize);\n        Ok(Self { inner: Arc::new(PixmapInner {\n            x: 0, y: 0, w, h, n, alpha: if alpha { 1 } else { 0 },\n            stride, colorspace, samples: vec![0; stride * (h as usize)],\n        }) })\n    }\n    pub fn width(\u0026self) -\u003e i32 { self.inner.w }\n    pub fn height(\u0026self) -\u003e i32 { self.inner.h }\n    pub fn n(\u0026self) -\u003e u8 { self.inner.n }\n    pub fn has_alpha(\u0026self) -\u003e bool { self.inner.alpha \u003e 0 }\n    pub fn stride(\u0026self) -\u003e usize { self.inner.stride }\n    pub fn colorspace(\u0026self) -\u003e Option\u003c\u0026Colorspace\u003e { self.inner.colorspace.as_ref() }\n    pub fn samples(\u0026self) -\u003e \u0026[u8] { \u0026self.inner.samples }\n    pub fn samples_mut(\u0026mut self) -\u003e \u0026mut [u8] { \u0026mut Arc::make_mut(\u0026mut self.inner).samples }\n    pub fn clear(\u0026mut self, value: u8) {\n        let inner = Arc::make_mut(\u0026mut self.inner);\n        inner.samples.fill(value);\n    }\n    pub fn get_pixel(\u0026self, x: i32, y: i32) -\u003e Option\u003c\u0026[u8]\u003e {\n        if x \u003c 0 || x \u003e= self.inner.w || y \u003c 0 || y \u003e= self.inner.h { return None; }\n        let offset = (y as usize) * self.inner.stride + (x as usize) * (self.inner.n as usize);\n        Some(\u0026self.inner.samples[offset..offset + self.inner.n as usize])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pixmap_new_rgb() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, false).unwrap();\n        assert_eq!(pm.width(), 100);\n        assert_eq!(pm.height(), 50);\n        assert_eq!(pm.n(), 3); // RGB\n        assert!(!pm.has_alpha());\n        assert_eq!(pm.stride(), 300); // 100 * 3\n    }\n\n    #[test]\n    fn test_pixmap_new_rgb_with_alpha() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, true).unwrap();\n        assert_eq!(pm.n(), 4); // RGBA\n        assert!(pm.has_alpha());\n        assert_eq!(pm.stride(), 400); // 100 * 4\n    }\n\n    #[test]\n    fn test_pixmap_new_gray() {\n        let cs = Colorspace::device_gray();\n        let pm = Pixmap::new(Some(cs), 100, 100, false).unwrap();\n        assert_eq!(pm.n(), 1);\n        assert!(!pm.has_alpha());\n    }\n\n    #[test]\n    fn test_pixmap_new_cmyk() {\n        let cs = Colorspace::device_cmyk();\n        let pm = Pixmap::new(Some(cs), 50, 50, false).unwrap();\n        assert_eq!(pm.n(), 4);\n    }\n\n    #[test]\n    fn test_pixmap_new_alpha_only() {\n        let pm = Pixmap::new(None, 100, 100, true).unwrap();\n        assert_eq!(pm.n(), 1);\n        assert!(pm.has_alpha());\n        assert!(pm.colorspace().is_none());\n    }\n\n    #[test]\n    fn test_pixmap_new_invalid_dimensions() {\n        let cs = Colorspace::device_rgb();\n        assert!(Pixmap::new(Some(cs.clone()), 0, 100, false).is_err());\n        assert!(Pixmap::new(Some(cs.clone()), 100, 0, false).is_err());\n        assert!(Pixmap::new(Some(cs), -1, 100, false).is_err());\n    }\n\n    #[test]\n    fn test_pixmap_new_no_colorspace_no_alpha() {\n        // Must have either colorspace or alpha\n        assert!(Pixmap::new(None, 100, 100, false).is_err());\n    }\n\n    #[test]\n    fn test_pixmap_samples() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let samples = pm.samples();\n        assert_eq!(samples.len(), 10 * 10 * 3);\n        // Should be initialized to 0\n        assert!(samples.iter().all(|\u0026b| b == 0));\n    }\n\n    #[test]\n    fn test_pixmap_samples_mut() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let samples = pm.samples_mut();\n        samples[0] = 255;\n        samples[1] = 128;\n        samples[2] = 64;\n\n        let samples_read = pm.samples();\n        assert_eq!(samples_read[0], 255);\n        assert_eq!(samples_read[1], 128);\n        assert_eq!(samples_read[2], 64);\n    }\n\n    #[test]\n    fn test_pixmap_clear() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        pm.clear(128);\n\n        assert!(pm.samples().iter().all(|\u0026b| b == 128));\n    }\n\n    #[test]\n    fn test_pixmap_get_pixel() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        // Set pixel at (2, 3)\n        let offset = 3 * 30 + 2 * 3; // y * stride + x * n\n        pm.samples_mut()[offset] = 255;\n        pm.samples_mut()[offset + 1] = 128;\n        pm.samples_mut()[offset + 2] = 64;\n\n        let pixel = pm.get_pixel(2, 3).unwrap();\n        assert_eq!(pixel, \u0026[255, 128, 64]);\n    }\n\n    #[test]\n    fn test_pixmap_get_pixel_out_of_bounds() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        assert!(pm.get_pixel(-1, 0).is_none());\n        assert!(pm.get_pixel(0, -1).is_none());\n        assert!(pm.get_pixel(10, 0).is_none());\n        assert!(pm.get_pixel(0, 10).is_none());\n    }\n\n    #[test]\n    fn test_pixmap_colorspace() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        let cs_ref = pm.colorspace().unwrap();\n        assert_eq!(cs_ref.name(), \"DeviceRGB\");\n    }\n\n    #[test]\n    fn test_pixmap_clone() {\n        let cs = Colorspace::device_rgb();\n        let pm1 = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let pm2 = pm1.clone();\n\n        assert_eq!(pm1.width(), pm2.width());\n        assert_eq!(pm1.height(), pm2.height());\n        assert_eq!(pm1.n(), pm2.n());\n    }\n}\n\n","traces":[{"line":18,"address":[2721008,2721884,2721935],"length":1,"stats":{"Line":1}},{"line":19,"address":[1749724,1748876],"length":1,"stats":{"Line":2}},{"line":20,"address":[1748942],"length":1,"stats":{"Line":5}},{"line":21,"address":[1748979,1749192],"length":1,"stats":{"Line":5}},{"line":22,"address":[1749009,1749046],"length":1,"stats":{"Line":2}},{"line":23,"address":[1749015,1749099],"length":1,"stats":{"Line":2}},{"line":25,"address":[1749290,1749166,1749268],"length":1,"stats":{"Line":7}},{"line":26,"address":[1749526],"length":1,"stats":{"Line":1}},{"line":27,"address":[1749308,1749276],"length":1,"stats":{"Line":7}},{"line":28,"address":[1749340],"length":1,"stats":{"Line":7}},{"line":31,"address":[1749813,1749808],"length":1,"stats":{"Line":2}},{"line":32,"address":[1749829,1749824],"length":1,"stats":{"Line":4}},{"line":33,"address":[2722005,2722000],"length":1,"stats":{"Line":6}},{"line":34,"address":[1749856,1749861],"length":1,"stats":{"Line":3}},{"line":35,"address":[1749893,1749888],"length":1,"stats":{"Line":2}},{"line":36,"address":[1749920,1749925],"length":1,"stats":{"Line":2}},{"line":37,"address":[1749952,1749957],"length":1,"stats":{"Line":2}},{"line":38,"address":[1749989,1749984],"length":1,"stats":{"Line":2}},{"line":39,"address":[2722160],"length":1,"stats":{"Line":1}},{"line":40,"address":[1750036],"length":1,"stats":{"Line":1}},{"line":41,"address":[1750050],"length":1,"stats":{"Line":1}},{"line":43,"address":[1750080],"length":1,"stats":{"Line":1}},{"line":44,"address":[1750110,1750156],"length":1,"stats":{"Line":2}},{"line":45,"address":[1750193,1750392],"length":1,"stats":{"Line":1}},{"line":46,"address":[1750343,1750420,1750445],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":25},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","stream.rs"],"content":"//! Stream - Buffered I/O abstraction using the `bytes` crate\n//!\n//! This module provides high-performance stream implementations for reading\n//! PDF data from files, memory, and other sources.\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::{Error, Result};\nuse bytes::{Buf, Bytes, BytesMut};\nuse std::fs::File;\nuse std::io::{self, BufReader, Read, Seek, SeekFrom};\nuse std::path::Path;\nuse std::sync::Arc;\n\n/// A buffered stream for reading PDF data.\npub struct Stream {\n    inner: Box\u003cdyn StreamSource\u003e,\n    buffer: BytesMut,\n    rp: usize,\n    wp: usize,\n    pos: i64,\n    eof: bool,\n    error: bool,\n    bits: u32,\n    avail: u8,\n    filename: Option\u003cString\u003e,\n}\n\n/// Trait for stream data sources.\npub trait StreamSource: Send + Sync {\n    /// Read data into the buffer.\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e;\n    /// Seek to a position.\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e;\n    /// Get current position.\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e;\n    /// Get total length if known.\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e;\n}\n\n/// File-based stream source.\nstruct FileSource {\n    reader: BufReader\u003cFile\u003e,\n    len: u64,\n}\n\nimpl StreamSource for FileSource {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.reader.read(buf)\n    }\n\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e {\n        self.reader.seek(pos)\n    }\n\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e {\n        self.reader.stream_position()\n    }\n\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        Some(self.len)\n    }\n}\n\n/// Memory-based stream source using `bytes::Bytes`.\nstruct MemorySource {\n    data: Bytes,\n    position: usize,\n}\n\nimpl StreamSource for MemorySource {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        let remaining = \u0026self.data[self.position..];\n        let to_read = buf.len().min(remaining.len());\n        buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n        self.position += to_read;\n        Ok(to_read)\n    }\n\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e {\n        let new_pos = match pos {\n            SeekFrom::Start(offset) =\u003e offset as i64,\n            SeekFrom::End(offset) =\u003e self.data.len() as i64 + offset,\n            SeekFrom::Current(offset) =\u003e self.position as i64 + offset,\n        };\n        if new_pos \u003c 0 {\n            return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Seek before start\"));\n        }\n        self.position = (new_pos as usize).min(self.data.len());\n        Ok(self.position as u64)\n    }\n\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e {\n        Ok(self.position as u64)\n    }\n\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        Some(self.data.len() as u64)\n    }\n}\n\nconst STREAM_BUFFER_SIZE: usize = 8192;\n\nimpl Stream {\n    /// Open a stream from a file path.\n    pub fn open_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        let file = File::open(path).map_err(Error::System)?;\n        let len = file.metadata().map_err(Error::System)?.len();\n        Ok(Self {\n            inner: Box::new(FileSource {\n                reader: BufReader::with_capacity(STREAM_BUFFER_SIZE, file),\n                len,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: Some(path.to_string_lossy().into_owned()),\n        })\n    }\n\n    /// Open a stream from a byte slice.\n    pub fn open_memory(data: \u0026[u8]) -\u003e Self {\n        Self {\n            inner: Box::new(MemorySource {\n                data: Bytes::copy_from_slice(data),\n                position: 0,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: None,\n        }\n    }\n\n    /// Open a stream from a `Bytes` instance (zero-copy).\n    pub fn open_bytes(data: Bytes) -\u003e Self {\n        Self {\n            inner: Box::new(MemorySource {\n                data,\n                position: 0,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: None,\n        }\n    }\n\n    /// Open a stream from a Buffer.\n    pub fn open_buffer(buffer: \u0026Buffer) -\u003e Self {\n        Self::open_bytes(buffer.to_bytes())\n    }\n\n    /// Get the current read position.\n    pub fn tell(\u0026self) -\u003e i64 {\n        self.pos - (self.wp - self.rp) as i64\n    }\n\n    /// Get the total length of the stream if known.\n    pub fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.inner.len()\n    }\n\n    /// Check if the stream is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.len() == Some(0)\n    }\n\n    /// Check if we've reached EOF.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.eof \u0026\u0026 self.rp \u003e= self.wp\n    }\n\n    /// Get the filename if this is a file stream.\n    pub fn filename(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.filename.as_deref()\n    }\n\n    /// Fill the internal buffer.\n    fn fill_buffer(\u0026mut self) -\u003e Result\u003cusize\u003e {\n        if self.eof {\n            return Ok(0);\n        }\n\n        // Compact the buffer\n        if self.rp \u003e 0 {\n            if self.rp \u003c self.wp {\n                // Move remaining data to the start\n                let remaining = self.wp - self.rp;\n                self.buffer.copy_within(self.rp..self.wp, 0);\n                self.buffer.truncate(remaining);\n                self.wp = remaining;\n            } else {\n                self.buffer.clear();\n                self.wp = 0;\n            }\n            self.rp = 0;\n        }\n\n        // Ensure buffer has space\n        if self.buffer.len() \u003c STREAM_BUFFER_SIZE {\n            self.buffer.resize(STREAM_BUFFER_SIZE, 0);\n        }\n\n        // Read more data\n        match self.inner.read(\u0026mut self.buffer[self.wp..]) {\n            Ok(0) =\u003e {\n                self.eof = true;\n                Ok(0)\n            }\n            Ok(n) =\u003e {\n                self.wp += n;\n                self.pos += n as i64;\n                Ok(n)\n            }\n            Err(e) =\u003e {\n                self.error = true;\n                Err(Error::System(e))\n            }\n        }\n    }\n\n    /// Read a single byte.\n    pub fn read_byte(\u0026mut self) -\u003e Result\u003cOption\u003cu8\u003e\u003e {\n        if self.rp \u003e= self.wp \u0026\u0026 self.fill_buffer()? == 0 {\n            return Ok(None);\n        }\n        let byte = self.buffer[self.rp];\n        self.rp += 1;\n        Ok(Some(byte))\n    }\n\n    /// Peek at the next byte without consuming it.\n    pub fn peek_byte(\u0026mut self) -\u003e Result\u003cOption\u003cu8\u003e\u003e {\n        if self.rp \u003e= self.wp \u0026\u0026 self.fill_buffer()? == 0 {\n            return Ok(None);\n        }\n        Ok(Some(self.buffer[self.rp]))\n    }\n\n    /// Read bytes into a buffer.\n    pub fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize\u003e {\n        let mut total = 0;\n        while total \u003c buf.len() {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                let to_copy = buffered.min(buf.len() - total);\n                buf[total..total + to_copy].copy_from_slice(\u0026self.buffer[self.rp..self.rp + to_copy]);\n                self.rp += to_copy;\n                total += to_copy;\n            } else if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(total)\n    }\n\n    /// Read exactly the specified number of bytes.\n    pub fn read_exact(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003c()\u003e {\n        if self.read(buf)? \u003c buf.len() {\n            return Err(Error::Eof);\n        }\n        Ok(())\n    }\n\n    /// Read all remaining data into a Buffer.\n    pub fn read_all(\u0026mut self, initial_capacity: usize) -\u003e Result\u003cBuffer\u003e {\n        let mut result = BytesMut::with_capacity(initial_capacity);\n        loop {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                result.extend_from_slice(\u0026self.buffer[self.rp..self.wp]);\n                self.rp = self.wp;\n            }\n            if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(Buffer::from_bytes_mut(result))\n    }\n\n    /// Read a line (up to and including newline).\n    pub fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e {\n        let mut line = Vec::new();\n        loop {\n            match self.read_byte()? {\n                None =\u003e {\n                    if line.is_empty() {\n                        return Ok(None);\n                    }\n                    break;\n                }\n                Some(b'\\n') =\u003e {\n                    line.push(b'\\n');\n                    break;\n                }\n                Some(b) =\u003e {\n                    line.push(b);\n                }\n            }\n        }\n        Ok(Some(line))\n    }\n\n    /// Skip n bytes.\n    pub fn skip(\u0026mut self, mut n: usize) -\u003e Result\u003cusize\u003e {\n        let mut skipped = 0;\n        while n \u003e 0 {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                let to_skip = buffered.min(n);\n                self.rp += to_skip;\n                skipped += to_skip;\n                n -= to_skip;\n            } else if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(skipped)\n    }\n\n    /// Seek to a position in the stream.\n    pub fn seek(\u0026mut self, pos: i64, whence: i32) -\u003e Result\u003c()\u003e {\n        let seek_from = match whence {\n            0 =\u003e SeekFrom::Start(pos as u64),\n            1 =\u003e SeekFrom::Current(pos),\n            2 =\u003e SeekFrom::End(pos),\n            _ =\u003e return Err(Error::generic(\"Invalid seek whence\")),\n        };\n\n        // Clear buffer and seek\n        self.rp = 0;\n        self.wp = 0;\n        self.eof = false;\n        self.pos = self.inner.seek(seek_from).map_err(Error::System)? as i64;\n        Ok(())\n    }\n\n    /// Read a 16-bit unsigned integer in big-endian format.\n    pub fn read_uint16(\u0026mut self) -\u003e Result\u003cu16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u16::from_be_bytes(buf))\n    }\n\n    /// Read a 24-bit unsigned integer in big-endian format.\n    pub fn read_uint24(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 3];\n        self.read_exact(\u0026mut buf)?;\n        Ok(((buf[0] as u32) \u003c\u003c 16) | ((buf[1] as u32) \u003c\u003c 8) | (buf[2] as u32))\n    }\n\n    /// Read a 32-bit unsigned integer in big-endian format.\n    pub fn read_uint32(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u32::from_be_bytes(buf))\n    }\n\n    /// Read a 16-bit signed integer in little-endian format.\n    pub fn read_int16_le(\u0026mut self) -\u003e Result\u003ci16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(i16::from_le_bytes(buf))\n    }\n\n    /// Read a 32-bit signed integer in little-endian format.\n    pub fn read_int32_le(\u0026mut self) -\u003e Result\u003ci32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(i32::from_le_bytes(buf))\n    }\n\n    /// Read a 16-bit unsigned integer in little-endian format.\n    pub fn read_uint16_le(\u0026mut self) -\u003e Result\u003cu16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u16::from_le_bytes(buf))\n    }\n\n    /// Read a 32-bit unsigned integer in little-endian format.\n    pub fn read_uint32_le(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u32::from_le_bytes(buf))\n    }\n\n    /// Read bits from the stream.\n    pub fn read_bits(\u0026mut self, n: u8) -\u003e Result\u003cu32\u003e {\n        while self.avail \u003c n {\n            match self.read_byte()? {\n                Some(b) =\u003e {\n                    self.bits = (self.bits \u003c\u003c 8) | (b as u32);\n                    self.avail += 8;\n                }\n                None =\u003e return Err(Error::Eof),\n            }\n        }\n        self.avail -= n;\n        let mask = (1u32 \u003c\u003c n) - 1;\n        Ok((self.bits \u003e\u003e self.avail) \u0026 mask)\n    }\n\n    /// Sync bits - discard any partial byte.\n    pub fn sync_bits(\u0026mut self) {\n        self.bits = 0;\n        self.avail = 0;\n    }\n}\n\nimpl std::fmt::Debug for Stream {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Stream\")\n            .field(\"pos\", \u0026self.tell())\n            .field(\"eof\", \u0026self.eof)\n            .field(\"filename\", \u0026self.filename)\n            .finish()\n    }\n}\n\n// Async stream support (when async feature is enabled)\n#[cfg(feature = \"async\")]\npub mod async_stream {\n    use super::*;\n    use bytes::Bytes;\n    use tokio::fs::File as AsyncFile;\n    use tokio::io::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt, BufReader as AsyncBufReader};\n    use std::pin::Pin;\n    use std::task::{Context, Poll};\n\n    /// Async stream for non-blocking I/O.\n    pub struct AsyncStream {\n        inner: AsyncStreamInner,\n        buffer: BytesMut,\n        pos: u64,\n        eof: bool,\n    }\n\n    enum AsyncStreamInner {\n        File(AsyncBufReader\u003cAsyncFile\u003e),\n        Memory { data: Bytes, position: usize },\n    }\n\n    impl AsyncStream {\n        /// Open a file asynchronously.\n        pub async fn open_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cSelf\u003e {\n            let file = AsyncFile::open(path).await.map_err(Error::System)?;\n            Ok(Self {\n                inner: AsyncStreamInner::File(AsyncBufReader::with_capacity(STREAM_BUFFER_SIZE, file)),\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            })\n        }\n\n        /// Open from memory.\n        pub fn open_memory(data: \u0026[u8]) -\u003e Self {\n            Self {\n                inner: AsyncStreamInner::Memory {\n                    data: Bytes::copy_from_slice(data),\n                    position: 0,\n                },\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            }\n        }\n\n        /// Open from Bytes (zero-copy).\n        pub fn open_bytes(data: Bytes) -\u003e Self {\n            Self {\n                inner: AsyncStreamInner::Memory {\n                    data,\n                    position: 0,\n                },\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            }\n        }\n\n        /// Read bytes asynchronously.\n        pub async fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize\u003e {\n            match \u0026mut self.inner {\n                AsyncStreamInner::File(reader) =\u003e {\n                    let n = reader.read(buf).await.map_err(Error::System)?;\n                    self.pos += n as u64;\n                    if n == 0 {\n                        self.eof = true;\n                    }\n                    Ok(n)\n                }\n                AsyncStreamInner::Memory { data, position } =\u003e {\n                    let remaining = \u0026data[*position..];\n                    let to_read = buf.len().min(remaining.len());\n                    buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n                    *position += to_read;\n                    self.pos += to_read as u64;\n                    if to_read == 0 {\n                        self.eof = true;\n                    }\n                    Ok(to_read)\n                }\n            }\n        }\n\n        /// Read all data asynchronously.\n        pub async fn read_all(\u0026mut self) -\u003e Result\u003cBuffer\u003e {\n            let mut result = BytesMut::with_capacity(8192);\n            let mut chunk = [0u8; 8192];\n            loop {\n                let n = self.read(\u0026mut chunk).await?;\n                if n == 0 {\n                    break;\n                }\n                result.extend_from_slice(\u0026chunk[..n]);\n            }\n            Ok(Buffer::from_bytes_mut(result))\n        }\n\n        /// Seek asynchronously.\n        pub async fn seek(\u0026mut self, pos: SeekFrom) -\u003e Result\u003cu64\u003e {\n            match \u0026mut self.inner {\n                AsyncStreamInner::File(reader) =\u003e {\n                    let new_pos = reader.seek(pos).await.map_err(Error::System)?;\n                    self.pos = new_pos;\n                    self.eof = false;\n                    Ok(new_pos)\n                }\n                AsyncStreamInner::Memory { data, position } =\u003e {\n                    let new_pos = match pos {\n                        SeekFrom::Start(offset) =\u003e offset as i64,\n                        SeekFrom::End(offset) =\u003e data.len() as i64 + offset,\n                        SeekFrom::Current(offset) =\u003e *position as i64 + offset,\n                    };\n                    if new_pos \u003c 0 {\n                        return Err(Error::generic(\"Seek before start\"));\n                    }\n                    *position = (new_pos as usize).min(data.len());\n                    self.pos = *position as u64;\n                    self.eof = false;\n                    Ok(self.pos)\n                }\n            }\n        }\n\n        /// Get current position.\n        pub fn tell(\u0026self) -\u003e u64 {\n            self.pos\n        }\n\n        /// Check if EOF.\n        pub fn is_eof(\u0026self) -\u003e bool {\n            self.eof\n        }\n    }\n}\n\n// Parallel stream processing (when parallel feature is enabled)\n#[cfg(feature = \"parallel\")]\npub mod parallel {\n    use super::*;\n    use rayon::prelude::*;\n\n    /// Process multiple streams in parallel.\n    pub fn process_streams\u003cF, R\u003e(streams: Vec\u003cStream\u003e, f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\n    where\n        F: Fn(Stream) -\u003e Result\u003cR\u003e + Sync + Send,\n        R: Send,\n    {\n        streams.into_par_iter().map(f).collect()\n    }\n\n    /// Read multiple files in parallel.\n    pub fn read_files\u003cP: AsRef\u003cPath\u003e + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n        paths\n            .par_iter()\n            .map(|path| {\n                let mut stream = Stream::open_file(path)?;\n                stream.read_all(0)\n            })\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stream_open_memory() {\n        let data = b\"Hello World\";\n        let stream = Stream::open_memory(data);\n        assert_eq!(stream.tell(), 0);\n        assert_eq!(stream.len(), Some(data.len() as u64));\n        assert!(!stream.is_empty());\n    }\n\n    #[test]\n    fn test_stream_open_memory_empty() {\n        let stream = Stream::open_memory(\u0026[]);\n        assert!(stream.is_empty());\n        assert_eq!(stream.len(), Some(0));\n    }\n\n    #[test]\n    fn test_stream_open_buffer() {\n        let buffer = Buffer::from_slice(b\"Test Data\");\n        let stream = Stream::open_buffer(\u0026buffer);\n        assert_eq!(stream.len(), Some(9));\n    }\n\n    #[test]\n    fn test_stream_open_bytes() {\n        let bytes = Bytes::from_static(b\"Hello World\");\n        let stream = Stream::open_bytes(bytes);\n        assert_eq!(stream.len(), Some(11));\n    }\n\n    #[test]\n    fn test_stream_read_byte() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.read_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.read_byte().unwrap(), Some(b'B'));\n        assert_eq!(stream.read_byte().unwrap(), Some(b'C'));\n        assert_eq!(stream.read_byte().unwrap(), None);\n    }\n\n    #[test]\n    fn test_stream_peek_byte() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'A')); // Should not advance\n        assert_eq!(stream.read_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'B'));\n    }\n\n    #[test]\n    fn test_stream_read() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 5];\n\n        let n = stream.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 5);\n        assert_eq!(\u0026buf, b\"Hello\");\n    }\n\n    #[test]\n    fn test_stream_read_exact() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 5];\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"Hello\");\n    }\n\n    #[test]\n    fn test_stream_read_exact_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 10];\n\n        let result = stream.read_exact(\u0026mut buf);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_stream_read_all() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.as_slice(), data);\n    }\n\n    #[test]\n    fn test_stream_read_line() {\n        let data = b\"Hello\\nWorld\\n\";\n        let mut stream = Stream::open_memory(data);\n\n        let line1 = stream.read_line().unwrap().unwrap();\n        assert_eq!(line1, b\"Hello\\n\");\n\n        let line2 = stream.read_line().unwrap().unwrap();\n        assert_eq!(line2, b\"World\\n\");\n\n        let line3 = stream.read_line().unwrap();\n        assert!(line3.is_none());\n    }\n\n    #[test]\n    fn test_stream_skip() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n\n        let skipped = stream.skip(6).unwrap();\n        assert_eq!(skipped, 6);\n\n        let mut buf = [0u8; 5];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"World\");\n    }\n\n    #[test]\n    fn test_stream_read_uint16() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint16().unwrap(), 0x0102);\n    }\n\n    #[test]\n    fn test_stream_read_uint24() {\n        let data = [0x01, 0x02, 0x03];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint24().unwrap(), 0x010203);\n    }\n\n    #[test]\n    fn test_stream_read_uint32() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint32().unwrap(), 0x01020304);\n    }\n\n    #[test]\n    fn test_stream_read_int16_le() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_int16_le().unwrap(), 0x0201);\n    }\n\n    #[test]\n    fn test_stream_read_int32_le() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_int32_le().unwrap(), 0x04030201);\n    }\n\n    #[test]\n    fn test_stream_read_uint16_le() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint16_le().unwrap(), 0x0201);\n    }\n\n    #[test]\n    fn test_stream_read_uint32_le() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint32_le().unwrap(), 0x04030201);\n    }\n\n    #[test]\n    fn test_stream_read_bits() {\n        let data = [0b10110100, 0b11001010];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        // Read 4 bits: 1011\n        assert_eq!(stream.read_bits(4).unwrap(), 0b1011);\n        // Read 4 bits: 0100\n        assert_eq!(stream.read_bits(4).unwrap(), 0b0100);\n        // Read 8 bits: 11001010\n        assert_eq!(stream.read_bits(8).unwrap(), 0b11001010);\n    }\n\n    #[test]\n    fn test_stream_sync_bits() {\n        let data = [0xFF, 0x00];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        stream.read_bits(4).unwrap();\n        stream.sync_bits();\n\n        // After sync, should read fresh byte\n        assert_eq!(stream.read_byte().unwrap(), Some(0x00));\n    }\n\n    #[test]\n    fn test_stream_tell() {\n        let data = b\"Hello\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.tell(), 0);\n        stream.read_byte().unwrap();\n    }\n\n    #[test]\n    fn test_stream_debug() {\n        let stream = Stream::open_memory(b\"test\");\n        let debug = format!(\"{:?}\", stream);\n        assert!(debug.contains(\"Stream\"));\n        assert!(debug.contains(\"pos\"));\n        assert!(debug.contains(\"eof\"));\n    }\n\n    #[test]\n    fn test_stream_sequential_reads() {\n        let data = b\"ABCDEFGHIJ\";\n        let mut stream = Stream::open_memory(data);\n\n        let mut buf = [0u8; 3];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"ABC\");\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"DEF\");\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"GHI\");\n    }\n\n    #[test]\n    fn test_stream_large_read() {\n        let data: Vec\u003cu8\u003e = (0..20000).map(|i| (i % 256) as u8).collect();\n        let mut stream = Stream::open_memory(\u0026data);\n\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.len(), data.len());\n        assert_eq!(buffer.as_slice(), \u0026data[..]);\n    }\n\n    #[test]\n    fn test_stream_is_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n\n        assert!(!stream.is_eof());\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap(); // Returns None, sets EOF\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_memory_source_seek() {\n        let data = b\"Hello World\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n\n        let pos = source.seek(SeekFrom::Start(6)).unwrap();\n        assert_eq!(pos, 6);\n        assert_eq!(source.position, 6);\n\n        let pos = source.seek(SeekFrom::Current(2)).unwrap();\n        assert_eq!(pos, 8);\n\n        let pos = source.seek(SeekFrom::End(-5)).unwrap();\n        assert_eq!(pos, 6);\n    }\n\n    #[test]\n    fn test_memory_source_seek_before_start() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 2,\n        };\n\n        let result = source.seek(SeekFrom::Current(-10));\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // Additional coverage tests\n    // ============================================================================\n\n    #[test]\n    fn test_memory_source_len() {\n        let data = b\"Hello\";\n        let source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n        assert_eq!(source.len(), Some(5));\n    }\n\n    #[test]\n    fn test_memory_source_tell() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 3,\n        };\n        assert_eq!(source.tell().unwrap(), 3);\n    }\n\n    #[test]\n    fn test_memory_source_read() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n        let mut buf = [0u8; 3];\n        let n = source.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, b\"Hel\");\n    }\n\n    #[test]\n    fn test_stream_filename() {\n        let stream = Stream::open_memory(b\"Test\");\n        assert!(stream.filename().is_none());\n    }\n\n    #[test]\n    fn test_stream_read_at_eof() {\n        let mut stream = Stream::open_memory(b\"AB\");\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        let r = stream.read_byte().unwrap(); // Returns None at EOF\n        assert!(r.is_none());\n\n        let mut buf = [0u8; 10];\n        let result = stream.read(\u0026mut buf);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n\n    #[test]\n    fn test_stream_len() {\n        let stream = Stream::open_memory(b\"Hello World\");\n        assert_eq!(stream.len(), Some(11));\n    }\n\n    #[test]\n    fn test_stream_is_empty() {\n        let stream = Stream::open_memory(b\"\");\n        assert!(stream.is_empty());\n\n        let stream2 = Stream::open_memory(b\"Test\");\n        assert!(!stream2.is_empty());\n    }\n\n    #[test]\n    fn test_stream_seek_start() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        stream.seek(0, 0).unwrap(); // SEEK_SET\n        assert_eq!(stream.tell(), 0);\n    }\n\n    #[test]\n    fn test_stream_seek_end() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        stream.seek(-5, 2).unwrap(); // SEEK_END\n        let mut buf = [0u8; 5];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"World\");\n    }\n\n    #[test]\n    fn test_stream_read_all_with_hint() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        let buffer = stream.read_all(20).unwrap();\n        assert_eq!(buffer.as_slice(), b\"Hello World\");\n    }\n\n    #[test]\n    fn test_stream_read_all_no_hint() {\n        let mut stream = Stream::open_memory(b\"Test\");\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.as_slice(), b\"Test\");\n    }\n\n    #[test]\n    fn test_stream_read_line_crlf() {\n        let data = b\"Line1\\r\\nLine2\\r\\n\";\n        let mut stream = Stream::open_memory(data);\n\n        let line1 = stream.read_line().unwrap().unwrap();\n        assert_eq!(\u0026line1[..5], b\"Line1\");\n\n        let line2 = stream.read_line().unwrap().unwrap();\n        assert_eq!(\u0026line2[..5], b\"Line2\");\n    }\n\n    #[test]\n    fn test_stream_read_line_no_newline() {\n        let data = b\"NoNewline\";\n        let mut stream = Stream::open_memory(data);\n\n        // Should read all remaining data even without newline\n        let line = stream.read_line().unwrap();\n        assert!(line.is_none() || !line.unwrap().is_empty());\n    }\n\n    #[test]\n    fn test_stream_read_bits_cross_byte() {\n        let data = [0xFF, 0xFF];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        // Read 12 bits spanning two bytes\n        let val = stream.read_bits(12).unwrap();\n        assert_eq!(val, 0xFFF);\n    }\n\n    #[test]\n    fn test_stream_peek_after_read() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n        stream.read_byte().unwrap();\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'B'));\n    }\n\n    #[test]\n    fn test_stream_skip_past_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n        let skipped = stream.skip(100).unwrap();\n        assert_eq!(skipped, 2);\n    }\n}\n","traces":[{"line":47,"address":[1790208],"length":1,"stats":{"Line":0}},{"line":48,"address":[1790226],"length":1,"stats":{"Line":0}},{"line":51,"address":[1790240],"length":1,"stats":{"Line":0}},{"line":52,"address":[1790258],"length":1,"stats":{"Line":0}},{"line":55,"address":[1790272],"length":1,"stats":{"Line":0}},{"line":56,"address":[1790277],"length":1,"stats":{"Line":0}},{"line":59,"address":[1790288],"length":1,"stats":{"Line":0}},{"line":60,"address":[1790293],"length":1,"stats":{"Line":0}},{"line":71,"address":[1790336],"length":1,"stats":{"Line":1}},{"line":72,"address":[1790373],"length":1,"stats":{"Line":1}},{"line":73,"address":[1790440],"length":1,"stats":{"Line":1}},{"line":74,"address":[1790472],"length":1,"stats":{"Line":1}},{"line":75,"address":[1790572,1790637],"length":1,"stats":{"Line":1}},{"line":76,"address":[1790605],"length":1,"stats":{"Line":5}},{"line":79,"address":[1790656],"length":1,"stats":{"Line":2}},{"line":80,"address":[1790683],"length":1,"stats":{"Line":2}},{"line":81,"address":[1790717],"length":1,"stats":{"Line":1}},{"line":82,"address":[1790828,1790739],"length":1,"stats":{"Line":2}},{"line":83,"address":[1790784,1790853],"length":1,"stats":{"Line":2}},{"line":85,"address":[1790813],"length":1,"stats":{"Line":1}},{"line":86,"address":[1790939],"length":1,"stats":{"Line":1}},{"line":88,"address":[1790878],"length":1,"stats":{"Line":1}},{"line":89,"address":[1790919],"length":1,"stats":{"Line":1}},{"line":92,"address":[1791008],"length":1,"stats":{"Line":1}},{"line":93,"address":[1791013],"length":1,"stats":{"Line":1}},{"line":96,"address":[1791056],"length":1,"stats":{"Line":1}},{"line":97,"address":[1791065],"length":1,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[1791104,1791433,1791439],"length":1,"stats":{"Line":13}},{"line":129,"address":[1791150],"length":1,"stats":{"Line":3}},{"line":133,"address":[1791216],"length":1,"stats":{"Line":13}},{"line":146,"address":[1791737,1791456],"length":1,"stats":{"Line":1}},{"line":148,"address":[1791472],"length":1,"stats":{"Line":1}},{"line":152,"address":[1791535],"length":1,"stats":{"Line":2}},{"line":165,"address":[1791760],"length":1,"stats":{"Line":1}},{"line":166,"address":[1791778],"length":1,"stats":{"Line":1}},{"line":170,"address":[1791824],"length":1,"stats":{"Line":1}},{"line":171,"address":[1791833,1791914],"length":1,"stats":{"Line":1}},{"line":175,"address":[1791936],"length":1,"stats":{"Line":1}},{"line":176,"address":[1791944],"length":1,"stats":{"Line":3}},{"line":180,"address":[1791968],"length":1,"stats":{"Line":2}},{"line":181,"address":[1791980],"length":1,"stats":{"Line":2}},{"line":185,"address":[1792032],"length":1,"stats":{"Line":1}},{"line":186,"address":[1792042],"length":1,"stats":{"Line":1}},{"line":190,"address":[1792096],"length":1,"stats":{"Line":1}},{"line":191,"address":[1792101],"length":1,"stats":{"Line":1}},{"line":195,"address":[1792112],"length":1,"stats":{"Line":2}},{"line":196,"address":[1792139],"length":1,"stats":{"Line":1}},{"line":197,"address":[1792164],"length":1,"stats":{"Line":1}},{"line":201,"address":[1792150,1792304],"length":1,"stats":{"Line":9}},{"line":202,"address":[1792258,1792220,1792404],"length":1,"stats":{"Line":5}},{"line":204,"address":[1792265,1792406,1792316],"length":1,"stats":{"Line":0}},{"line":205,"address":[1792324],"length":1,"stats":{"Line":0}},{"line":206,"address":[1792380],"length":1,"stats":{"Line":0}},{"line":207,"address":[1792400],"length":1,"stats":{"Line":0}},{"line":209,"address":[1792235],"length":1,"stats":{"Line":2}},{"line":210,"address":[1792250],"length":1,"stats":{"Line":5}},{"line":212,"address":[1792296],"length":1,"stats":{"Line":3}},{"line":216,"address":[1792189],"length":1,"stats":{"Line":4}},{"line":217,"address":[1792523],"length":1,"stats":{"Line":5}},{"line":221,"address":[1792424,1792620],"length":1,"stats":{"Line":8}},{"line":223,"address":[1792638],"length":1,"stats":{"Line":3}},{"line":224,"address":[1792642],"length":1,"stats":{"Line":3}},{"line":226,"address":[1792664],"length":1,"stats":{"Line":5}},{"line":227,"address":[1792682,1792726,1792745],"length":1,"stats":{"Line":12}},{"line":228,"address":[1792777,1792730,1792794],"length":1,"stats":{"Line":12}},{"line":229,"address":[1792781],"length":1,"stats":{"Line":6}},{"line":231,"address":[1792552],"length":1,"stats":{"Line":0}},{"line":232,"address":[1792565],"length":1,"stats":{"Line":0}},{"line":233,"address":[1792569],"length":1,"stats":{"Line":0}},{"line":239,"address":[1792816],"length":1,"stats":{"Line":1}},{"line":240,"address":[1792846,1792916],"length":1,"stats":{"Line":2}},{"line":241,"address":[1793073],"length":1,"stats":{"Line":1}},{"line":243,"address":[1793183,1792861,1793139],"length":1,"stats":{"Line":6}},{"line":244,"address":[1793215,1793153,1793269],"length":1,"stats":{"Line":6}},{"line":245,"address":[1793219],"length":1,"stats":{"Line":7}},{"line":249,"address":[1793296],"length":1,"stats":{"Line":1}},{"line":250,"address":[1793395,1793326],"length":1,"stats":{"Line":2}},{"line":251,"address":[1793543],"length":1,"stats":{"Line":0}},{"line":253,"address":[1793668,1793341,1793608],"length":1,"stats":{"Line":2}},{"line":257,"address":[1793696],"length":1,"stats":{"Line":1}},{"line":258,"address":[1793764],"length":1,"stats":{"Line":1}},{"line":259,"address":[1793781],"length":1,"stats":{"Line":1}},{"line":260,"address":[1793831,1793876],"length":1,"stats":{"Line":1}},{"line":261,"address":[1793868,1794528],"length":1,"stats":{"Line":2}},{"line":262,"address":[1793969,1794209,1794153],"length":1,"stats":{"Line":4}},{"line":263,"address":[1794245,1794447,1794172],"length":1,"stats":{"Line":5}},{"line":264,"address":[1794502,1794431,1794478],"length":1,"stats":{"Line":5}},{"line":265,"address":[1794520,1794533,1794482],"length":1,"stats":{"Line":5}},{"line":266,"address":[1793897,1794010],"length":1,"stats":{"Line":1}},{"line":270,"address":[1793799],"length":1,"stats":{"Line":3}},{"line":274,"address":[1794560],"length":1,"stats":{"Line":1}},{"line":275,"address":[1794605],"length":1,"stats":{"Line":2}},{"line":276,"address":[1794760],"length":1,"stats":{"Line":1}},{"line":278,"address":[1794746],"length":1,"stats":{"Line":3}},{"line":282,"address":[1794832,1795403,1795432],"length":1,"stats":{"Line":1}},{"line":283,"address":[1794883],"length":1,"stats":{"Line":3}},{"line":285,"address":[1794959,1794914],"length":1,"stats":{"Line":1}},{"line":286,"address":[1794951,1795152],"length":1,"stats":{"Line":4}},{"line":287,"address":[1795045],"length":1,"stats":{"Line":1}},{"line":288,"address":[1795144],"length":1,"stats":{"Line":3}},{"line":290,"address":[1795033,1795170],"length":1,"stats":{"Line":4}},{"line":294,"address":[1795281],"length":1,"stats":{"Line":2}},{"line":298,"address":[1796048,1795440,1796054],"length":1,"stats":{"Line":1}},{"line":299,"address":[1795470],"length":1,"stats":{"Line":2}},{"line":301,"address":[1796046,1795491,1795549],"length":1,"stats":{"Line":6}},{"line":303,"address":[1795701],"length":1,"stats":{"Line":1}},{"line":304,"address":[1795880],"length":1,"stats":{"Line":1}},{"line":309,"address":[1796023,1795954],"length":1,"stats":{"Line":2}},{"line":312,"address":[1795990],"length":1,"stats":{"Line":3}},{"line":313,"address":[1796041,1796000,1795982],"length":1,"stats":{"Line":9}},{"line":317,"address":[1795740],"length":1,"stats":{"Line":2}},{"line":321,"address":[1796080],"length":1,"stats":{"Line":1}},{"line":322,"address":[1796115],"length":1,"stats":{"Line":1}},{"line":323,"address":[1796124],"length":1,"stats":{"Line":1}},{"line":324,"address":[1796208,1796163],"length":1,"stats":{"Line":1}},{"line":325,"address":[1796565,1796200],"length":1,"stats":{"Line":2}},{"line":326,"address":[1796286],"length":1,"stats":{"Line":1}},{"line":327,"address":[1796491,1796470,1796315],"length":1,"stats":{"Line":2}},{"line":328,"address":[1796542,1796514,1796474],"length":1,"stats":{"Line":2}},{"line":329,"address":[1796570,1796560,1796519],"length":1,"stats":{"Line":2}},{"line":330,"address":[1796226,1796340],"length":1,"stats":{"Line":1}},{"line":334,"address":[1796137],"length":1,"stats":{"Line":1}},{"line":338,"address":[1796592],"length":1,"stats":{"Line":2}},{"line":339,"address":[1796646],"length":1,"stats":{"Line":2}},{"line":340,"address":[1796746],"length":1,"stats":{"Line":1}},{"line":341,"address":[1796767],"length":1,"stats":{"Line":0}},{"line":342,"address":[1796788],"length":1,"stats":{"Line":1}},{"line":343,"address":[1796674],"length":1,"stats":{"Line":0}},{"line":347,"address":[1796807],"length":1,"stats":{"Line":2}},{"line":348,"address":[1796815],"length":1,"stats":{"Line":2}},{"line":349,"address":[1796823],"length":1,"stats":{"Line":2}},{"line":350,"address":[1796827],"length":1,"stats":{"Line":2}},{"line":351,"address":[1797007],"length":1,"stats":{"Line":2}},{"line":355,"address":[1797040],"length":1,"stats":{"Line":1}},{"line":356,"address":[1797069],"length":1,"stats":{"Line":1}},{"line":357,"address":[1797091],"length":1,"stats":{"Line":1}},{"line":358,"address":[1797214],"length":1,"stats":{"Line":1}},{"line":362,"address":[1797296],"length":1,"stats":{"Line":1}},{"line":363,"address":[1797326],"length":1,"stats":{"Line":1}},{"line":364,"address":[1797348],"length":1,"stats":{"Line":1}},{"line":365,"address":[1797480],"length":1,"stats":{"Line":1}},{"line":369,"address":[1797536],"length":1,"stats":{"Line":1}},{"line":370,"address":[1797565],"length":1,"stats":{"Line":1}},{"line":371,"address":[1797587],"length":1,"stats":{"Line":1}},{"line":372,"address":[1797710],"length":1,"stats":{"Line":1}},{"line":376,"address":[1797776],"length":1,"stats":{"Line":1}},{"line":377,"address":[1797805],"length":1,"stats":{"Line":1}},{"line":378,"address":[1797827],"length":1,"stats":{"Line":1}},{"line":379,"address":[1797950],"length":1,"stats":{"Line":1}},{"line":383,"address":[1798032],"length":1,"stats":{"Line":1}},{"line":384,"address":[1798061],"length":1,"stats":{"Line":1}},{"line":385,"address":[1798083],"length":1,"stats":{"Line":1}},{"line":386,"address":[1798206],"length":1,"stats":{"Line":1}},{"line":390,"address":[1798272],"length":1,"stats":{"Line":1}},{"line":391,"address":[1798301],"length":1,"stats":{"Line":1}},{"line":392,"address":[1798323],"length":1,"stats":{"Line":1}},{"line":393,"address":[1798446],"length":1,"stats":{"Line":1}},{"line":397,"address":[1798528],"length":1,"stats":{"Line":1}},{"line":398,"address":[1798557],"length":1,"stats":{"Line":1}},{"line":399,"address":[1798579],"length":1,"stats":{"Line":1}},{"line":400,"address":[1798702],"length":1,"stats":{"Line":1}},{"line":404,"address":[1798768],"length":1,"stats":{"Line":2}},{"line":405,"address":[1798820,1799361],"length":1,"stats":{"Line":4}},{"line":406,"address":[1798856,1799116],"length":1,"stats":{"Line":2}},{"line":407,"address":[1799234],"length":1,"stats":{"Line":2}},{"line":408,"address":[1799248],"length":1,"stats":{"Line":2}},{"line":409,"address":[1799262,1799366,1799358],"length":1,"stats":{"Line":4}},{"line":411,"address":[1799285],"length":1,"stats":{"Line":0}},{"line":414,"address":[1798928,1798834,1798937],"length":1,"stats":{"Line":4}},{"line":415,"address":[1798931,1798954,1799031],"length":1,"stats":{"Line":4}},{"line":416,"address":[1799061,1799011,1799085],"length":1,"stats":{"Line":4}},{"line":420,"address":[1799392],"length":1,"stats":{"Line":1}},{"line":421,"address":[1799397],"length":1,"stats":{"Line":1}},{"line":422,"address":[1799404],"length":1,"stats":{"Line":1}},{"line":427,"address":[1799424],"length":1,"stats":{"Line":1}},{"line":428,"address":[1799528,1799481,1799443],"length":1,"stats":{"Line":3}},{"line":429,"address":[1799471],"length":1,"stats":{"Line":1}},{"line":430,"address":[1799524],"length":1,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[2705248,2705512,2705518],"length":1,"stats":{"Line":0}},{"line":474,"address":[2705297],"length":1,"stats":{"Line":0}},{"line":478,"address":[2705354],"length":1,"stats":{"Line":0}},{"line":485,"address":[2705536,2705758],"length":1,"stats":{"Line":0}},{"line":487,"address":[2705552],"length":1,"stats":{"Line":0}},{"line":491,"address":[2705600],"length":1,"stats":{"Line":0}},{"line":498,"address":[2705810,2705792],"length":1,"stats":{"Line":0}},{"line":499,"address":[1426164],"length":1,"stats":{"Line":0}},{"line":500,"address":[1426345],"length":1,"stats":{"Line":0}},{"line":501,"address":[1427119,1426431,1426361,1426239,1427563],"length":1,"stats":{"Line":0}},{"line":502,"address":[1427493,1427425],"length":1,"stats":{"Line":0}},{"line":503,"address":[1427485],"length":1,"stats":{"Line":0}},{"line":504,"address":[1427514],"length":1,"stats":{"Line":0}},{"line":506,"address":[1427538],"length":1,"stats":{"Line":0}},{"line":508,"address":[1426260],"length":1,"stats":{"Line":0}},{"line":509,"address":[1426536,1426295],"length":1,"stats":{"Line":0}},{"line":510,"address":[1426629],"length":1,"stats":{"Line":0}},{"line":511,"address":[1426674],"length":1,"stats":{"Line":0}},{"line":512,"address":[1426816,1426883],"length":1,"stats":{"Line":0}},{"line":513,"address":[1426913,1426850,1426940],"length":1,"stats":{"Line":0}},{"line":514,"address":[1426932],"length":1,"stats":{"Line":0}},{"line":515,"address":[1426958],"length":1,"stats":{"Line":0}},{"line":517,"address":[1426982],"length":1,"stats":{"Line":0}},{"line":523,"address":[2705840,2705848],"length":1,"stats":{"Line":0}},{"line":524,"address":[1427687],"length":1,"stats":{"Line":0}},{"line":525,"address":[1427810],"length":1,"stats":{"Line":0}},{"line":527,"address":[1428543,1427900,1428170,1427924,1427738,1427839],"length":1,"stats":{"Line":0}},{"line":528,"address":[1428279],"length":1,"stats":{"Line":0}},{"line":531,"address":[1428518,1428360],"length":1,"stats":{"Line":0}},{"line":533,"address":[1428402,1428285],"length":1,"stats":{"Line":0}},{"line":537,"address":[1428859,1428700,1429707,1429031,1428656],"length":1,"stats":{"Line":0}},{"line":538,"address":[1428814],"length":1,"stats":{"Line":0}},{"line":539,"address":[1428992],"length":1,"stats":{"Line":0}},{"line":540,"address":[1430099,1428886,1429000,1429738,1429094],"length":1,"stats":{"Line":0}},{"line":541,"address":[1430036],"length":1,"stats":{"Line":0}},{"line":542,"address":[1430055],"length":1,"stats":{"Line":0}},{"line":543,"address":[1430074],"length":1,"stats":{"Line":0}},{"line":545,"address":[1428904],"length":1,"stats":{"Line":0}},{"line":546,"address":[1428941],"length":1,"stats":{"Line":0}},{"line":547,"address":[1429172],"length":1,"stats":{"Line":0}},{"line":548,"address":[1429295,1429203],"length":1,"stats":{"Line":0}},{"line":549,"address":[1429241,1429348],"length":1,"stats":{"Line":0}},{"line":551,"address":[1429272],"length":1,"stats":{"Line":0}},{"line":552,"address":[1429638,1429406],"length":1,"stats":{"Line":0}},{"line":554,"address":[1429381,1429446],"length":1,"stats":{"Line":0}},{"line":555,"address":[1429475],"length":1,"stats":{"Line":0}},{"line":556,"address":[1429497],"length":1,"stats":{"Line":0}},{"line":557,"address":[1429516],"length":1,"stats":{"Line":0}},{"line":563,"address":[2705920],"length":1,"stats":{"Line":0}},{"line":564,"address":[2705925],"length":1,"stats":{"Line":0}},{"line":568,"address":[2705936],"length":1,"stats":{"Line":0}},{"line":569,"address":[2705941],"length":1,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}}],"covered":159,"coverable":260},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","text.rs"],"content":"//! Text spans and pages\nuse crate::fitz::geometry::Quad;\n\npub struct TextSpan { chars: Vec\u003cTextChar\u003e }\npub struct TextChar { pub c: char, pub quad: Quad }\n\nimpl TextSpan {\n    pub fn new() -\u003e Self { Self { chars: Vec::new() } }\n    pub fn add_char(\u0026mut self, c: char, quad: Quad) { self.chars.push(TextChar { c, quad }); }\n    pub fn text(\u0026self) -\u003e String { self.chars.iter().map(|c| c.c).collect() }\n    pub fn len(\u0026self) -\u003e usize { self.chars.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.chars.is_empty() }\n}\nimpl Default for TextSpan { fn default() -\u003e Self { Self::new() } }\n\npub struct TextPage { spans: Vec\u003cTextSpan\u003e }\nimpl TextPage {\n    pub fn new() -\u003e Self { Self { spans: Vec::new() } }\n    pub fn add_span(\u0026mut self, span: TextSpan) { self.spans.push(span); }\n    pub fn spans(\u0026self) -\u003e \u0026[TextSpan] { \u0026self.spans }\n    pub fn len(\u0026self) -\u003e usize { self.spans.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.spans.is_empty() }\n}\nimpl Default for TextPage { fn default() -\u003e Self { Self::new() } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::fitz::geometry::{Point, Rect};\n\n    fn make_quad(x: f32, y: f32, w: f32, h: f32) -\u003e Quad {\n        Quad::from_rect(\u0026Rect::new(x, y, x + w, y + h))\n    }\n\n    #[test]\n    fn test_text_span_new() {\n        let span = TextSpan::new();\n        assert!(span.is_empty());\n        assert_eq!(span.len(), 0);\n        assert_eq!(span.text(), \"\");\n    }\n\n    #[test]\n    fn test_text_span_default() {\n        let span: TextSpan = Default::default();\n        assert!(span.is_empty());\n    }\n\n    #[test]\n    fn test_text_span_add_char() {\n        let mut span = TextSpan::new();\n        span.add_char('H', make_quad(0.0, 0.0, 10.0, 12.0));\n        span.add_char('i', make_quad(10.0, 0.0, 5.0, 12.0));\n\n        assert_eq!(span.len(), 2);\n        assert!(!span.is_empty());\n        assert_eq!(span.text(), \"Hi\");\n    }\n\n    #[test]\n    fn test_text_span_unicode() {\n        let mut span = TextSpan::new();\n        span.add_char('', make_quad(0.0, 0.0, 12.0, 12.0));\n        span.add_char('', make_quad(12.0, 0.0, 12.0, 12.0));\n        span.add_char('', make_quad(24.0, 0.0, 12.0, 12.0));\n\n        assert_eq!(span.text(), \"\");\n    }\n\n    #[test]\n    fn test_text_page_new() {\n        let page = TextPage::new();\n        assert!(page.is_empty());\n        assert_eq!(page.len(), 0);\n    }\n\n    #[test]\n    fn test_text_page_default() {\n        let page: TextPage = Default::default();\n        assert!(page.is_empty());\n    }\n\n    #[test]\n    fn test_text_page_add_span() {\n        let mut page = TextPage::new();\n\n        let mut span1 = TextSpan::new();\n        span1.add_char('A', make_quad(0.0, 0.0, 10.0, 12.0));\n        page.add_span(span1);\n\n        let mut span2 = TextSpan::new();\n        span2.add_char('B', make_quad(0.0, 12.0, 10.0, 12.0));\n        page.add_span(span2);\n\n        assert_eq!(page.len(), 2);\n        assert!(!page.is_empty());\n    }\n\n    #[test]\n    fn test_text_page_spans() {\n        let mut page = TextPage::new();\n\n        let mut span = TextSpan::new();\n        span.add_char('X', make_quad(0.0, 0.0, 10.0, 12.0));\n        page.add_span(span);\n\n        let spans = page.spans();\n        assert_eq!(spans.len(), 1);\n        assert_eq!(spans[0].text(), \"X\");\n    }\n\n    #[test]\n    fn test_text_char_fields() {\n        let quad = make_quad(5.0, 10.0, 8.0, 12.0);\n        let tc = TextChar { c: 'Z', quad };\n\n        assert_eq!(tc.c, 'Z');\n        assert_eq!(tc.quad.ul.x, 5.0);\n        assert_eq!(tc.quad.ul.y, 10.0);\n    }\n}\n\n","traces":[{"line":8,"address":[2327776,2327789],"length":1,"stats":{"Line":2}},{"line":9,"address":[2327840,2327853],"length":1,"stats":{"Line":6}},{"line":10,"address":[1800928,1800938],"length":1,"stats":{"Line":5}},{"line":11,"address":[2328016,2328021],"length":1,"stats":{"Line":3}},{"line":12,"address":[2328032,2328037],"length":1,"stats":{"Line":2}},{"line":14,"address":[2328048,2328056],"length":1,"stats":{"Line":2}},{"line":18,"address":[2328080,2328093],"length":1,"stats":{"Line":4}},{"line":19,"address":[2328149,2328144],"length":1,"stats":{"Line":3}},{"line":20,"address":[2328181,2328176],"length":1,"stats":{"Line":2}},{"line":21,"address":[2328192,2328197],"length":1,"stats":{"Line":2}},{"line":22,"address":[2328213,2328208],"length":1,"stats":{"Line":2}},{"line":24,"address":[2328224,2328232],"length":1,"stats":{"Line":2}}],"covered":12,"coverable":12},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","lib.rs"],"content":"//! MicroPDF - A native Rust PDF library inspired by MuPDF\n//!\n//! This library provides PDF parsing, rendering, and manipulation capabilities.\n//!\n//! # FFI Module\n//!\n//! The `ffi` module provides C-compatible exports that match MuPDF's API.\n//! When compiled as a staticlib or cdylib, these functions can be called\n//! from C code using the same function signatures as MuPDF.\n\npub mod fitz;\npub mod pdf;\npub mod ffi;\n\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","annot.rs"],"content":"//! PDF annot module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","cmap.rs"],"content":"//! PDF cmap module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","colorspace.rs"],"content":"//! PDF colorspace module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","crypt.rs"],"content":"//! PDF encryption/decryption\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","document.rs"],"content":"//! PDF document implementation\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","filter.rs"],"content":"//! PDF Stream Filter/Compression Module\n//!\n//! This module implements all PDF stream filters for decompression and compression.\n//! Supports the complete set of PDF filters as defined in PDF 1.7 specification.\n\nuse std::io::{self, Read, Write};\nuse flate2::read::{ZlibDecoder, ZlibEncoder};\nuse flate2::Compression;\n\nuse crate::fitz::error::{Error, Result};\n\n/// PDF Filter types as defined in PDF specification\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FilterType {\n    /// FlateDecode - zlib/deflate compression (most common)\n    FlateDecode,\n    /// LZWDecode - Lempel-Ziv-Welch compression\n    LZWDecode,\n    /// ASCII85Decode - ASCII base-85 encoding\n    ASCII85Decode,\n    /// ASCIIHexDecode - Hexadecimal encoding\n    ASCIIHexDecode,\n    /// RunLengthDecode - Run-length encoding\n    RunLengthDecode,\n    /// CCITTFaxDecode - CCITT Group 3 and Group 4 fax encoding\n    CCITTFaxDecode,\n    /// DCTDecode - JPEG compression\n    DCTDecode,\n    /// JPXDecode - JPEG 2000 compression\n    JPXDecode,\n    /// JBIG2Decode - JBIG2 compression\n    JBIG2Decode,\n    /// Crypt - Encryption filter\n    Crypt,\n}\n\nimpl FilterType {\n    /// Parse filter type from PDF name\n    pub fn from_name(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name {\n            \"FlateDecode\" | \"Fl\" =\u003e Some(FilterType::FlateDecode),\n            \"LZWDecode\" | \"LZW\" =\u003e Some(FilterType::LZWDecode),\n            \"ASCII85Decode\" | \"A85\" =\u003e Some(FilterType::ASCII85Decode),\n            \"ASCIIHexDecode\" | \"AHx\" =\u003e Some(FilterType::ASCIIHexDecode),\n            \"RunLengthDecode\" | \"RL\" =\u003e Some(FilterType::RunLengthDecode),\n            \"CCITTFaxDecode\" | \"CCF\" =\u003e Some(FilterType::CCITTFaxDecode),\n            \"DCTDecode\" | \"DCT\" =\u003e Some(FilterType::DCTDecode),\n            \"JPXDecode\" =\u003e Some(FilterType::JPXDecode),\n            \"JBIG2Decode\" =\u003e Some(FilterType::JBIG2Decode),\n            \"Crypt\" =\u003e Some(FilterType::Crypt),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the PDF name for this filter\n    pub fn to_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            FilterType::FlateDecode =\u003e \"FlateDecode\",\n            FilterType::LZWDecode =\u003e \"LZWDecode\",\n            FilterType::ASCII85Decode =\u003e \"ASCII85Decode\",\n            FilterType::ASCIIHexDecode =\u003e \"ASCIIHexDecode\",\n            FilterType::RunLengthDecode =\u003e \"RunLengthDecode\",\n            FilterType::CCITTFaxDecode =\u003e \"CCITTFaxDecode\",\n            FilterType::DCTDecode =\u003e \"DCTDecode\",\n            FilterType::JPXDecode =\u003e \"JPXDecode\",\n            FilterType::JBIG2Decode =\u003e \"JBIG2Decode\",\n            FilterType::Crypt =\u003e \"Crypt\",\n        }\n    }\n}\n\n/// Parameters for FlateDecode filter\n#[derive(Debug, Clone, Default)]\npub struct FlateDecodeParams {\n    /// PNG predictor algorithm (1 = None, 2 = TIFF, 10-15 = PNG)\n    pub predictor: i32,\n    /// Number of color components per sample\n    pub colors: i32,\n    /// Number of bits per color component\n    pub bits_per_component: i32,\n    /// Number of samples per row\n    pub columns: i32,\n}\n\n/// Parameters for LZWDecode filter\n#[derive(Debug, Clone, Default)]\npub struct LZWDecodeParams {\n    /// PNG predictor algorithm\n    pub predictor: i32,\n    /// Number of color components per sample\n    pub colors: i32,\n    /// Number of bits per color component\n    pub bits_per_component: i32,\n    /// Number of samples per row\n    pub columns: i32,\n    /// Early change parameter (0 or 1)\n    pub early_change: i32,\n}\n\n/// Parameters for CCITTFaxDecode filter\n#[derive(Debug, Clone)]\npub struct CCITTFaxDecodeParams {\n    /// Encoding scheme: 0 = Group 3 1D, \u003c0 = Group 3 2D, \u003e0 = Group 4\n    pub k: i32,\n    /// If true, end-of-line bit patterns are required\n    pub end_of_line: bool,\n    /// If true, byte-aligned encoding is expected\n    pub encoded_byte_align: bool,\n    /// Width of the image in pixels\n    pub columns: i32,\n    /// Height of the image in pixels\n    pub rows: i32,\n    /// If true, uncompressed data should be end-of-block\n    pub end_of_block: bool,\n    /// If true, 0 means white, 1 means black (default: false)\n    pub black_is_1: bool,\n    /// Number of damaged rows allowed\n    pub damaged_rows_before_error: i32,\n}\n\nimpl Default for CCITTFaxDecodeParams {\n    fn default() -\u003e Self {\n        Self {\n            k: 0,\n            end_of_line: false,\n            encoded_byte_align: false,\n            columns: 1728,\n            rows: 0,\n            end_of_block: true,\n            black_is_1: false,\n            damaged_rows_before_error: 0,\n        }\n    }\n}\n\n/// Parameters for DCTDecode filter (JPEG)\n#[derive(Debug, Clone, Default)]\npub struct DCTDecodeParams {\n    /// Color transform: 0 = no transform, 1 = YCbCr to RGB\n    pub color_transform: i32,\n}\n\n/// Parameters for JBIG2Decode filter\n#[derive(Debug, Clone, Default)]\npub struct JBIG2DecodeParams {\n    /// Global segment data\n    pub jbig2_globals: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n// ============================================================================\n// FlateDecode (zlib/deflate)\n// ============================================================================\n\n/// Decode FlateDecode (zlib/deflate) compressed data\npub fn decode_flate(data: \u0026[u8], params: Option\u003c\u0026FlateDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut decoder = ZlibDecoder::new(data);\n    let mut decompressed = Vec::new();\n    decoder.read_to_end(\u0026mut decompressed)\n        .map_err(|e| Error::Generic(format!(\"FlateDecode failed: {}\", e)))?;\n\n    // Apply predictor if specified\n    if let Some(params) = params {\n        if params.predictor \u003e 1 {\n            decompressed = apply_predictor_decode(\u0026decompressed, params)?;\n        }\n    }\n\n    Ok(decompressed)\n}\n\n/// Encode data with FlateDecode (zlib/deflate)\npub fn encode_flate(data: \u0026[u8], level: u32) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let compression = match level {\n        0 =\u003e Compression::none(),\n        1..=3 =\u003e Compression::fast(),\n        4..=6 =\u003e Compression::default(),\n        _ =\u003e Compression::best(),\n    };\n\n    let mut encoder = ZlibEncoder::new(data, compression);\n    let mut compressed = Vec::new();\n    encoder.read_to_end(\u0026mut compressed)\n        .map_err(|e| Error::Generic(format!(\"FlateDecode encode failed: {}\", e)))?;\n\n    Ok(compressed)\n}\n\n// ============================================================================\n// LZWDecode\n// ============================================================================\n\n/// Decode LZW compressed data\npub fn decode_lzw(data: \u0026[u8], params: Option\u003c\u0026LZWDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let early_change = params.map(|p| p.early_change != 0).unwrap_or(true);\n\n    let mut decoder = weezl::decode::Decoder::with_tiff_size_switch(\n        weezl::BitOrder::Msb,\n        if early_change { 8 } else { 9 },\n    );\n\n    let decompressed = decoder.decode(data)\n        .map_err(|e| Error::Generic(format!(\"LZWDecode failed: {:?}\", e)))?;\n\n    // Apply predictor if specified\n    let mut result = decompressed;\n    if let Some(params) = params {\n        if params.predictor \u003e 1 {\n            let flate_params = FlateDecodeParams {\n                predictor: params.predictor,\n                colors: params.colors,\n                bits_per_component: params.bits_per_component,\n                columns: params.columns,\n            };\n            result = apply_predictor_decode(\u0026result, \u0026flate_params)?;\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with LZW compression\npub fn encode_lzw(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut encoder = weezl::encode::Encoder::with_tiff_size_switch(weezl::BitOrder::Msb, 8);\n    encoder.encode(data)\n        .map_err(|e| Error::Generic(format!(\"LZWEncode failed: {:?}\", e)))\n}\n\n// ============================================================================\n// ASCII85Decode\n// ============================================================================\n\n/// Decode ASCII85 encoded data\npub fn decode_ascii85(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 4 / 5);\n    let mut group: u32 = 0;\n    let mut count = 0;\n\n    for \u0026byte in data {\n        // Skip whitespace\n        if byte.is_ascii_whitespace() {\n            continue;\n        }\n\n        // End of data marker\n        if byte == b'~' {\n            break;\n        }\n\n        // Special 'z' character represents 4 zero bytes\n        if byte == b'z' {\n            if count != 0 {\n                return Err(Error::Generic(\"Invalid 'z' in ASCII85 stream\".into()));\n            }\n            result.extend_from_slice(\u0026[0, 0, 0, 0]);\n            continue;\n        }\n\n        // Regular ASCII85 character\n        if !(b'!'..=b'u').contains(\u0026byte) {\n            return Err(Error::Generic(format!(\"Invalid ASCII85 character: {}\", byte)));\n        }\n\n        group = group * 85 + (byte - b'!') as u32;\n        count += 1;\n\n        if count == 5 {\n            result.push((group \u003e\u003e 24) as u8);\n            result.push((group \u003e\u003e 16) as u8);\n            result.push((group \u003e\u003e 8) as u8);\n            result.push(group as u8);\n            group = 0;\n            count = 0;\n        }\n    }\n\n    // Handle remaining bytes\n    if count \u003e 0 {\n        // Pad with 'u' characters\n        for _ in count..5 {\n            group = group * 85 + 84;\n        }\n\n        for i in 0..(count - 1) {\n            result.push((group \u003e\u003e (24 - i * 8)) as u8);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with ASCII85\npub fn encode_ascii85(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 5 / 4 + 10);\n\n    let mut i = 0;\n    while i \u003c data.len() {\n        let chunk_len = (data.len() - i).min(4);\n        let chunk = \u0026data[i..i + chunk_len];\n\n        let mut group: u32 = 0;\n        for (j, \u0026byte) in chunk.iter().enumerate() {\n            group |= (byte as u32) \u003c\u003c (24 - j * 8);\n        }\n\n        // Special case: all zeros (only for complete 4-byte chunks)\n        if group == 0 \u0026\u0026 chunk_len == 4 {\n            result.push(b'z');\n            i += 4;\n            continue;\n        }\n\n        let mut encoded = [0u8; 5];\n        let mut temp = group;\n        for j in (0..5).rev() {\n            encoded[j] = (temp % 85) as u8 + b'!';\n            temp /= 85;\n        }\n\n        // Output all 5 bytes for complete groups, or chunk_len + 1 for partial\n        let output_len = if chunk_len == 4 { 5 } else { chunk_len + 1 };\n        result.extend_from_slice(\u0026encoded[..output_len]);\n\n        i += chunk_len;\n    }\n\n    // Add end marker\n    result.extend_from_slice(b\"~\u003e\");\n\n    Ok(result)\n}\n\n// ============================================================================\n// ASCIIHexDecode\n// ============================================================================\n\n/// Decode ASCIIHex encoded data\npub fn decode_ascii_hex(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() / 2);\n    let mut high_nibble: Option\u003cu8\u003e = None;\n\n    for \u0026byte in data {\n        // Skip whitespace\n        if byte.is_ascii_whitespace() {\n            continue;\n        }\n\n        // End of data marker\n        if byte == b'\u003e' {\n            break;\n        }\n\n        let nibble = match byte {\n            b'0'..=b'9' =\u003e byte - b'0',\n            b'A'..=b'F' =\u003e byte - b'A' + 10,\n            b'a'..=b'f' =\u003e byte - b'a' + 10,\n            _ =\u003e return Err(Error::Generic(format!(\"Invalid hex character: {}\", byte))),\n        };\n\n        match high_nibble {\n            None =\u003e high_nibble = Some(nibble),\n            Some(high) =\u003e {\n                result.push((high \u003c\u003c 4) | nibble);\n                high_nibble = None;\n            }\n        }\n    }\n\n    // Handle odd number of hex digits\n    if let Some(high) = high_nibble {\n        result.push(high \u003c\u003c 4);\n    }\n\n    Ok(result)\n}\n\n/// Encode data with ASCIIHex\npub fn encode_ascii_hex(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 2 + 1);\n\n    for \u0026byte in data {\n        let high = (byte \u003e\u003e 4) \u0026 0x0F;\n        let low = byte \u0026 0x0F;\n\n        result.push(if high \u003c 10 { b'0' + high } else { b'A' + high - 10 });\n        result.push(if low \u003c 10 { b'0' + low } else { b'A' + low - 10 });\n    }\n\n    result.push(b'\u003e');\n\n    Ok(result)\n}\n\n// ============================================================================\n// RunLengthDecode\n// ============================================================================\n\n/// Decode RunLength encoded data\npub fn decode_run_length(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::new();\n    let mut i = 0;\n\n    while i \u003c data.len() {\n        let length_byte = data[i];\n        i += 1;\n\n        if length_byte == 128 {\n            // End of data\n            break;\n        } else if length_byte \u003c 128 {\n            // Copy next (length_byte + 1) bytes literally\n            let count = length_byte as usize + 1;\n            if i + count \u003e data.len() {\n                return Err(Error::Generic(\"RunLengthDecode: unexpected end of data\".into()));\n            }\n            result.extend_from_slice(\u0026data[i..i + count]);\n            i += count;\n        } else {\n            // Repeat next byte (257 - length_byte) times\n            let count = 257 - length_byte as usize;\n            if i \u003e= data.len() {\n                return Err(Error::Generic(\"RunLengthDecode: unexpected end of data\".into()));\n            }\n            let byte = data[i];\n            i += 1;\n            result.resize(result.len() + count, byte);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with RunLength\npub fn encode_run_length(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::new();\n    let mut i = 0;\n\n    while i \u003c data.len() {\n        // Look for a run of identical bytes\n        let start = i;\n        let byte = data[i];\n        while i \u003c data.len() \u0026\u0026 data[i] == byte \u0026\u0026 i - start \u003c 128 {\n            i += 1;\n        }\n        let run_length = i - start;\n\n        if run_length \u003e= 2 {\n            // Encode as a run\n            result.push((257 - run_length) as u8);\n            result.push(byte);\n        } else {\n            // Look for literal bytes\n            i = start;\n            let literal_start = i;\n\n            while i \u003c data.len() {\n                // Check for a run of 3+ identical bytes\n                if i + 2 \u003c data.len() \u0026\u0026 data[i] == data[i + 1] \u0026\u0026 data[i] == data[i + 2] {\n                    break;\n                }\n                i += 1;\n                if i - literal_start \u003e= 128 {\n                    break;\n                }\n            }\n\n            let literal_length = i - literal_start;\n            if literal_length \u003e 0 {\n                result.push((literal_length - 1) as u8);\n                result.extend_from_slice(\u0026data[literal_start..i]);\n            }\n        }\n    }\n\n    // End of data marker\n    result.push(128);\n\n    Ok(result)\n}\n\n// ============================================================================\n// CCITTFaxDecode\n// ============================================================================\n\n/// Decode CCITT Group 3/4 fax encoded data\npub fn decode_ccitt_fax(data: \u0026[u8], params: \u0026CCITTFaxDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // CCITT fax decoding is complex - for now provide a stub\n    // Full implementation would require a dedicated CCITT decoder\n\n    let width = params.columns as usize;\n    let height = if params.rows \u003e 0 { params.rows as usize } else { 0 };\n\n    // For Group 4 (k \u003e 0), we need to implement the 2D coding scheme\n    // For Group 3 1D (k = 0), we need to implement the 1D coding scheme\n    // For Group 3 2D (k \u003c 0), we need to implement mixed 1D/2D\n\n    // Basic implementation using run-length decoding pattern\n    let bytes_per_row = (width + 7) / 8;\n    let estimated_rows = if height \u003e 0 { height } else { data.len() * 8 / width.max(1) };\n\n    let mut result = Vec::with_capacity(bytes_per_row * estimated_rows);\n\n    // Simplified: treat as raw bitmap if no compression recognized\n    // This is a fallback - real implementation needs full CCITT codec\n    if data.len() == bytes_per_row * estimated_rows {\n        result.extend_from_slice(data);\n    } else {\n        // Attempt basic decompression\n        result = decode_ccitt_g4(data, width, height, params)?;\n    }\n\n    // Apply black_is_1 transformation if needed\n    if !params.black_is_1 {\n        for byte in \u0026mut result {\n            *byte = !*byte;\n        }\n    }\n\n    Ok(result)\n}\n\n/// Basic CCITT Group 4 decoder\nfn decode_ccitt_g4(data: \u0026[u8], width: usize, height: usize, _params: \u0026CCITTFaxDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // Group 4 uses 2D coding exclusively\n    // This is a simplified implementation\n\n    let bytes_per_row = (width + 7) / 8;\n    let total_rows = if height \u003e 0 { height } else { 1000 }; // Max rows as fallback\n\n    let mut result = Vec::with_capacity(bytes_per_row * total_rows);\n    let mut reference_line = vec![0u8; bytes_per_row];\n    let mut current_line = vec![0u8; bytes_per_row];\n\n    let mut bit_reader = BitReader::new(data);\n    let mut row_count = 0;\n\n    while row_count \u003c total_rows {\n        // Try to decode a row\n        match decode_g4_row(\u0026mut bit_reader, \u0026reference_line, \u0026mut current_line, width) {\n            Ok(()) =\u003e {\n                result.extend_from_slice(\u0026current_line);\n                std::mem::swap(\u0026mut reference_line, \u0026mut current_line);\n                current_line.fill(0);\n                row_count += 1;\n            }\n            Err(_) =\u003e break, // End of data or error\n        }\n    }\n\n    Ok(result)\n}\n\n/// Bit reader for CCITT decoding\nstruct BitReader\u003c'a\u003e {\n    data: \u0026'a [u8],\n    byte_pos: usize,\n    bit_pos: u8,\n}\n\nimpl\u003c'a\u003e BitReader\u003c'a\u003e {\n    fn new(data: \u0026'a [u8]) -\u003e Self {\n        Self {\n            data,\n            byte_pos: 0,\n            bit_pos: 0,\n        }\n    }\n\n    fn read_bit(\u0026mut self) -\u003e Option\u003cbool\u003e {\n        if self.byte_pos \u003e= self.data.len() {\n            return None;\n        }\n\n        let bit = (self.data[self.byte_pos] \u003e\u003e (7 - self.bit_pos)) \u0026 1;\n        self.bit_pos += 1;\n        if self.bit_pos \u003e= 8 {\n            self.bit_pos = 0;\n            self.byte_pos += 1;\n        }\n\n        Some(bit != 0)\n    }\n\n    fn read_bits(\u0026mut self, count: usize) -\u003e Option\u003cu32\u003e {\n        let mut value = 0u32;\n        for _ in 0..count {\n            value = (value \u003c\u003c 1) | (self.read_bit()? as u32);\n        }\n        Some(value)\n    }\n}\n\n/// Decode a single Group 4 row\nfn decode_g4_row(\n    _reader: \u0026mut BitReader,\n    _reference: \u0026[u8],\n    current: \u0026mut [u8],\n    _width: usize,\n) -\u003e Result\u003c()\u003e {\n    // Simplified: fill with white\n    // Full implementation needs CCITT code tables\n    current.fill(0);\n    Ok(())\n}\n\n// ============================================================================\n// DCTDecode (JPEG)\n// ============================================================================\n\n/// Decode JPEG compressed data\npub fn decode_dct(data: \u0026[u8], _params: Option\u003c\u0026DCTDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use image::io::Reader as ImageReader;\n    use std::io::Cursor;\n\n    let reader = ImageReader::with_format(\n        Cursor::new(data),\n        image::ImageFormat::Jpeg,\n    );\n\n    let img = reader.decode()\n        .map_err(|e| Error::Generic(format!(\"DCTDecode failed: {}\", e)))?;\n\n    Ok(img.into_bytes())\n}\n\n/// Encode data with JPEG compression\npub fn encode_dct(data: \u0026[u8], width: u32, height: u32, quality: u8) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use image::{ImageBuffer, Rgb};\n    use std::io::Cursor;\n\n    // Assume RGB data\n    let img: ImageBuffer\u003cRgb\u003cu8\u003e, _\u003e = ImageBuffer::from_raw(width, height, data.to_vec())\n        .ok_or_else(|| Error::Generic(\"Invalid image dimensions\".into()))?;\n\n    let mut output = Cursor::new(Vec::new());\n    img.write_to(\u0026mut output, image::ImageFormat::Jpeg)\n        .map_err(|e| Error::Generic(format!(\"DCTEncode failed: {}\", e)))?;\n\n    let _ = quality; // TODO: Use quality parameter\n\n    Ok(output.into_inner())\n}\n\n// ============================================================================\n// JPXDecode (JPEG 2000)\n// ============================================================================\n\n/// Decode JPEG 2000 compressed data\n#[cfg(feature = \"jpeg2000\")]\npub fn decode_jpx(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use jpeg2k::Image;\n\n    let image = Image::from_bytes(data)\n        .map_err(|e| Error::Generic(format!(\"JPXDecode failed: {:?}\", e)))?;\n\n    // Get the decoded image data\n    // The jpeg2k crate provides access to image data through its API\n    let mut result = Vec::new();\n\n    // Get dimensions\n    let width = image.width() as usize;\n    let height = image.height() as usize;\n    let num_components = image.components().len();\n\n    // Reserve space for the output\n    result.reserve(width * height * num_components);\n\n    // Extract data component by component\n    // JPEG2000 stores components separately, we need to interleave them\n    for y in 0..height {\n        for x in 0..width {\n            for comp in image.components() {\n                let comp_width = comp.width() as usize;\n                let idx = y * comp_width + x;\n                if let Some(\u0026val) = comp.data().get(idx) {\n                    // jpeg2k returns i32 values, convert to u8\n                    result.push(val.clamp(0, 255) as u8);\n                }\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n#[cfg(not(feature = \"jpeg2000\"))]\npub fn decode_jpx(_data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    Err(Error::Generic(\"JPEG 2000 support not enabled. Enable 'jpeg2000' feature.\".into()))\n}\n\n// ============================================================================\n// JBIG2Decode\n// ============================================================================\n\n/// Decode JBIG2 compressed data\npub fn decode_jbig2(data: \u0026[u8], _params: Option\u003c\u0026JBIG2DecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // JBIG2 is a complex format for bi-level (black \u0026 white) images\n    // Full implementation would require a dedicated JBIG2 decoder\n    // For now, return the data as-is or error\n\n    #[cfg(feature = \"jbig2\")]\n    {\n        // Would use jbig2dec or similar library\n        Err(Error::Generic(\"JBIG2 decoder not yet implemented\".into()))\n    }\n\n    #[cfg(not(feature = \"jbig2\"))]\n    {\n        let _ = data;\n        Err(Error::Generic(\"JBIG2 support not enabled. Enable 'jbig2' feature.\".into()))\n    }\n}\n\n// ============================================================================\n// Predictor Functions\n// ============================================================================\n\n/// Apply PNG/TIFF predictor for decoding\nfn apply_predictor_decode(data: \u0026[u8], params: \u0026FlateDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let predictor = params.predictor;\n    let colors = params.colors.max(1) as usize;\n    let bits = params.bits_per_component.max(8) as usize;\n    let columns = params.columns.max(1) as usize;\n\n    // Calculate bytes per pixel and bytes per row\n    let bytes_per_pixel = (colors * bits + 7) / 8;\n    let bytes_per_row = (colors * bits * columns + 7) / 8;\n\n    match predictor {\n        1 =\u003e Ok(data.to_vec()), // No predictor\n        2 =\u003e apply_tiff_predictor_decode(data, bytes_per_row, bytes_per_pixel),\n        10..=15 =\u003e apply_png_predictor_decode(data, bytes_per_row, bytes_per_pixel),\n        _ =\u003e Err(Error::Generic(format!(\"Unsupported predictor: {}\", predictor))),\n    }\n}\n\n/// Apply TIFF predictor (horizontal differencing)\nfn apply_tiff_predictor_decode(data: \u0026[u8], bytes_per_row: usize, bytes_per_pixel: usize) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len());\n\n    for row in data.chunks(bytes_per_row) {\n        let mut prev = vec![0u8; bytes_per_pixel];\n\n        for pixel in row.chunks(bytes_per_pixel) {\n            for (i, \u0026byte) in pixel.iter().enumerate() {\n                let decoded = byte.wrapping_add(prev[i]);\n                result.push(decoded);\n                prev[i] = decoded;\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n/// Apply PNG predictor\nfn apply_png_predictor_decode(data: \u0026[u8], bytes_per_row: usize, bytes_per_pixel: usize) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // PNG predictor includes a filter type byte at the start of each row\n    let row_size = bytes_per_row + 1;\n    let mut result = Vec::with_capacity(data.len());\n    let mut prev_row = vec![0u8; bytes_per_row];\n\n    for row_data in data.chunks(row_size) {\n        if row_data.is_empty() {\n            continue;\n        }\n\n        let filter_type = row_data[0];\n        let row = \u0026row_data[1..];\n\n        if row.len() \u003c bytes_per_row {\n            // Incomplete row, pad with zeros\n            let mut padded = row.to_vec();\n            padded.resize(bytes_per_row, 0);\n            decode_png_filter(filter_type, \u0026padded, \u0026prev_row, bytes_per_pixel, \u0026mut result)?;\n        } else {\n            decode_png_filter(filter_type, \u0026row[..bytes_per_row], \u0026prev_row, bytes_per_pixel, \u0026mut result)?;\n        }\n\n        // Update previous row\n        let start = result.len().saturating_sub(bytes_per_row);\n        prev_row.copy_from_slice(\u0026result[start..]);\n    }\n\n    Ok(result)\n}\n\n/// Decode a single PNG filter row\nfn decode_png_filter(\n    filter_type: u8,\n    row: \u0026[u8],\n    prev_row: \u0026[u8],\n    bytes_per_pixel: usize,\n    output: \u0026mut Vec\u003cu8\u003e,\n) -\u003e Result\u003c()\u003e {\n    match filter_type {\n        0 =\u003e {\n            // None\n            output.extend_from_slice(row);\n        }\n        1 =\u003e {\n            // Sub\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel]\n                } else {\n                    0\n                };\n                output.push(byte.wrapping_add(left));\n            }\n        }\n        2 =\u003e {\n            // Up\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let up = prev_row.get(i).copied().unwrap_or(0);\n                output.push(byte.wrapping_add(up));\n            }\n        }\n        3 =\u003e {\n            // Average\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel] as u32\n                } else {\n                    0\n                };\n                let up = prev_row.get(i).copied().unwrap_or(0) as u32;\n                let avg = ((left + up) / 2) as u8;\n                output.push(byte.wrapping_add(avg));\n            }\n        }\n        4 =\u003e {\n            // Paeth\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel]\n                } else {\n                    0\n                };\n                let up = prev_row.get(i).copied().unwrap_or(0);\n                let up_left = if i \u003e= bytes_per_pixel {\n                    prev_row.get(i - bytes_per_pixel).copied().unwrap_or(0)\n                } else {\n                    0\n                };\n                let paeth = paeth_predictor(left, up, up_left);\n                output.push(byte.wrapping_add(paeth));\n            }\n        }\n        _ =\u003e {\n            return Err(Error::Generic(format!(\"Unknown PNG filter type: {}\", filter_type)));\n        }\n    }\n\n    Ok(())\n}\n\n/// Paeth predictor function\nfn paeth_predictor(a: u8, b: u8, c: u8) -\u003e u8 {\n    let a = a as i32;\n    let b = b as i32;\n    let c = c as i32;\n\n    let p = a + b - c;\n    let pa = (p - a).abs();\n    let pb = (p - b).abs();\n    let pc = (p - c).abs();\n\n    if pa \u003c= pb \u0026\u0026 pa \u003c= pc {\n        a as u8\n    } else if pb \u003c= pc {\n        b as u8\n    } else {\n        c as u8\n    }\n}\n\n// ============================================================================\n// Filter Chain\n// ============================================================================\n\n/// A chain of filters to apply\n#[derive(Debug, Clone)]\npub struct FilterChain {\n    filters: Vec\u003cFilterType\u003e,\n}\n\nimpl FilterChain {\n    pub fn new() -\u003e Self {\n        Self { filters: Vec::new() }\n    }\n\n    pub fn add(\u0026mut self, filter: FilterType) {\n        self.filters.push(filter);\n    }\n\n    /// Decode data through the filter chain (in order)\n    pub fn decode(\u0026self, mut data: Vec\u003cu8\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        for filter in \u0026self.filters {\n            data = match filter {\n                FilterType::FlateDecode =\u003e decode_flate(\u0026data, None)?,\n                FilterType::LZWDecode =\u003e decode_lzw(\u0026data, None)?,\n                FilterType::ASCII85Decode =\u003e decode_ascii85(\u0026data)?,\n                FilterType::ASCIIHexDecode =\u003e decode_ascii_hex(\u0026data)?,\n                FilterType::RunLengthDecode =\u003e decode_run_length(\u0026data)?,\n                FilterType::CCITTFaxDecode =\u003e decode_ccitt_fax(\u0026data, \u0026CCITTFaxDecodeParams::default())?,\n                FilterType::DCTDecode =\u003e decode_dct(\u0026data, None)?,\n                FilterType::JPXDecode =\u003e decode_jpx(\u0026data)?,\n                FilterType::JBIG2Decode =\u003e decode_jbig2(\u0026data, None)?,\n                FilterType::Crypt =\u003e data, // Encryption handled separately\n            };\n        }\n        Ok(data)\n    }\n\n    /// Encode data through the filter chain (in reverse order)\n    pub fn encode(\u0026self, mut data: Vec\u003cu8\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        for filter in self.filters.iter().rev() {\n            data = match filter {\n                FilterType::FlateDecode =\u003e encode_flate(\u0026data, 6)?,\n                FilterType::LZWDecode =\u003e encode_lzw(\u0026data)?,\n                FilterType::ASCII85Decode =\u003e encode_ascii85(\u0026data)?,\n                FilterType::ASCIIHexDecode =\u003e encode_ascii_hex(\u0026data)?,\n                FilterType::RunLengthDecode =\u003e encode_run_length(\u0026data)?,\n                FilterType::CCITTFaxDecode =\u003e {\n                    return Err(Error::Generic(\"CCITTFaxEncode not supported\".into()));\n                }\n                FilterType::DCTDecode =\u003e {\n                    return Err(Error::Generic(\"DCTEncode requires image dimensions\".into()));\n                }\n                FilterType::JPXDecode =\u003e {\n                    return Err(Error::Generic(\"JPXEncode not supported\".into()));\n                }\n                FilterType::JBIG2Decode =\u003e {\n                    return Err(Error::Generic(\"JBIG2Encode not supported\".into()));\n                }\n                FilterType::Crypt =\u003e data,\n            };\n        }\n        Ok(data)\n    }\n}\n\nimpl Default for FilterChain {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // FilterType Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_type_from_name() {\n        // Full names\n        assert_eq!(FilterType::from_name(\"FlateDecode\"), Some(FilterType::FlateDecode));\n        assert_eq!(FilterType::from_name(\"LZWDecode\"), Some(FilterType::LZWDecode));\n        assert_eq!(FilterType::from_name(\"ASCII85Decode\"), Some(FilterType::ASCII85Decode));\n        assert_eq!(FilterType::from_name(\"ASCIIHexDecode\"), Some(FilterType::ASCIIHexDecode));\n        assert_eq!(FilterType::from_name(\"RunLengthDecode\"), Some(FilterType::RunLengthDecode));\n        assert_eq!(FilterType::from_name(\"CCITTFaxDecode\"), Some(FilterType::CCITTFaxDecode));\n        assert_eq!(FilterType::from_name(\"DCTDecode\"), Some(FilterType::DCTDecode));\n        assert_eq!(FilterType::from_name(\"JPXDecode\"), Some(FilterType::JPXDecode));\n        assert_eq!(FilterType::from_name(\"JBIG2Decode\"), Some(FilterType::JBIG2Decode));\n        assert_eq!(FilterType::from_name(\"Crypt\"), Some(FilterType::Crypt));\n\n        // Abbreviated names\n        assert_eq!(FilterType::from_name(\"Fl\"), Some(FilterType::FlateDecode));\n        assert_eq!(FilterType::from_name(\"LZW\"), Some(FilterType::LZWDecode));\n        assert_eq!(FilterType::from_name(\"A85\"), Some(FilterType::ASCII85Decode));\n        assert_eq!(FilterType::from_name(\"AHx\"), Some(FilterType::ASCIIHexDecode));\n        assert_eq!(FilterType::from_name(\"RL\"), Some(FilterType::RunLengthDecode));\n        assert_eq!(FilterType::from_name(\"CCF\"), Some(FilterType::CCITTFaxDecode));\n        assert_eq!(FilterType::from_name(\"DCT\"), Some(FilterType::DCTDecode));\n\n        // Invalid\n        assert_eq!(FilterType::from_name(\"Invalid\"), None);\n        assert_eq!(FilterType::from_name(\"\"), None);\n    }\n\n    #[test]\n    fn test_filter_type_to_name() {\n        assert_eq!(FilterType::FlateDecode.to_name(), \"FlateDecode\");\n        assert_eq!(FilterType::LZWDecode.to_name(), \"LZWDecode\");\n        assert_eq!(FilterType::ASCII85Decode.to_name(), \"ASCII85Decode\");\n        assert_eq!(FilterType::ASCIIHexDecode.to_name(), \"ASCIIHexDecode\");\n        assert_eq!(FilterType::RunLengthDecode.to_name(), \"RunLengthDecode\");\n        assert_eq!(FilterType::CCITTFaxDecode.to_name(), \"CCITTFaxDecode\");\n        assert_eq!(FilterType::DCTDecode.to_name(), \"DCTDecode\");\n        assert_eq!(FilterType::JPXDecode.to_name(), \"JPXDecode\");\n        assert_eq!(FilterType::JBIG2Decode.to_name(), \"JBIG2Decode\");\n        assert_eq!(FilterType::Crypt.to_name(), \"Crypt\");\n    }\n\n    // ============================================================================\n    // FlateDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_roundtrip() {\n        let original = b\"Hello, World! This is a test of FlateDecode compression.\";\n        let compressed = encode_flate(original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_flate_empty() {\n        let original = b\"\";\n        let compressed = encode_flate(original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_flate_compression_levels() {\n        let data = b\"Test data for different compression levels\";\n\n        // Level 0 (no compression)\n        let comp0 = encode_flate(data, 0).unwrap();\n        let dec0 = decode_flate(\u0026comp0, None).unwrap();\n        assert_eq!(\u0026dec0, data);\n\n        // Level 1 (fast)\n        let comp1 = encode_flate(data, 1).unwrap();\n        let dec1 = decode_flate(\u0026comp1, None).unwrap();\n        assert_eq!(\u0026dec1, data);\n\n        // Level 9 (best)\n        let comp9 = encode_flate(data, 9).unwrap();\n        let dec9 = decode_flate(\u0026comp9, None).unwrap();\n        assert_eq!(\u0026dec9, data);\n    }\n\n    #[test]\n    fn test_flate_large_data() {\n        let original: Vec\u003cu8\u003e = (0..10000).map(|i| (i % 256) as u8).collect();\n        let compressed = encode_flate(\u0026original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(decompressed, original);\n    }\n\n    // ============================================================================\n    // LZWDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_lzw_roundtrip() {\n        let original = b\"AAAAABBBBBCCCCC\";\n        let compressed = encode_lzw(original).unwrap();\n        let decompressed = decode_lzw(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_lzw_longer_data() {\n        let original = b\"The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog.\";\n        let compressed = encode_lzw(original).unwrap();\n        let decompressed = decode_lzw(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    // ============================================================================\n    // ASCII85Decode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ascii85_roundtrip() {\n        let original = b\"Hello, World!\";\n        let encoded = encode_ascii85(original).unwrap();\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_empty() {\n        let original = b\"\";\n        let encoded = encode_ascii85(original).unwrap();\n        assert_eq!(\u0026encoded, b\"~\u003e\");\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_zeros() {\n        // Four zeros should encode to 'z'\n        let original = b\"\\x00\\x00\\x00\\x00\";\n        let encoded = encode_ascii85(original).unwrap();\n        assert!(encoded.starts_with(b\"z\"));\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_with_whitespace() {\n        // Whitespace should be ignored during decoding\n        let encoded = b\"87cURD]j  \\n\\t  7BEbo~\u003e\";\n        let decoded = decode_ascii85(encoded).unwrap();\n        // The encoded value decodes to \"Hello worl\" (what the input encodes to)\n        assert_eq!(\u0026decoded, b\"Hello worl\");\n    }\n\n    #[test]\n    fn test_ascii85_partial_group() {\n        // Test non-multiple of 4 bytes\n        let original = b\"ABC\"; // 3 bytes\n        let encoded = encode_ascii85(original).unwrap();\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_invalid_char() {\n        let encoded = b\"Hello{World~\u003e\";\n        let result = decode_ascii85(encoded);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ascii85_invalid_z_position() {\n        // 'z' should only appear at the start of a group\n        let encoded = b\"abcz~\u003e\";\n        let result = decode_ascii85(encoded);\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // ASCIIHexDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ascii_hex_roundtrip() {\n        let original = b\"\\x00\\x11\\x22\\x33\\x44\\x55\";\n        let encoded = encode_ascii_hex(original).unwrap();\n        let decoded = decode_ascii_hex(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii_hex_empty() {\n        let original = b\"\";\n        let encoded = encode_ascii_hex(original).unwrap();\n        assert_eq!(\u0026encoded, b\"\u003e\");\n        let decoded = decode_ascii_hex(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii_hex_lowercase() {\n        let encoded = b\"48656c6c6f\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_uppercase() {\n        let encoded = b\"48656C6C6F\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_with_whitespace() {\n        let encoded = b\"48 65 6C  \\n  6C 6F\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_odd_digits() {\n        // Odd number of digits - last nibble padded with 0\n        let encoded = b\"123\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(decoded, vec![0x12, 0x30]);\n    }\n\n    #[test]\n    fn test_ascii_hex_invalid_char() {\n        let encoded = b\"48GG\u003e\";\n        let result = decode_ascii_hex(encoded);\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // RunLengthDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_run_length_roundtrip() {\n        let original = b\"AAAAAABBBCCCCCCCC\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_literal() {\n        // Data with no repeated bytes\n        let original = b\"ABCDEFGH\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_empty() {\n        let original = b\"\";\n        let encoded = encode_run_length(original).unwrap();\n        // Should just be EOD marker (128)\n        assert_eq!(encoded, vec![128]);\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_long_run() {\n        // Long run of identical bytes\n        let original = vec![0x42u8; 200];\n        let encoded = encode_run_length(\u0026original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_mixed() {\n        // Mix of runs and literals\n        let original = b\"AAABBBBCCCCCDDDDDDEEEEEEE\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_eod() {\n        // Just the EOD marker\n        let encoded = vec![128u8];\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert!(decoded.is_empty());\n    }\n\n    // ============================================================================\n    // DCTDecode Tests (JPEG)\n    // ============================================================================\n\n    // Note: DCT encoding requires image dimensions, so we test decoding with valid JPEG\n\n    // ============================================================================\n    // CCITTFaxDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ccitt_default_params() {\n        let params = CCITTFaxDecodeParams::default();\n        assert_eq!(params.k, 0);\n        assert!(!params.end_of_line);\n        assert!(!params.encoded_byte_align);\n        assert_eq!(params.columns, 1728);\n        assert_eq!(params.rows, 0);\n        assert!(params.end_of_block);\n        assert!(!params.black_is_1);\n        assert_eq!(params.damaged_rows_before_error, 0);\n    }\n\n    // ============================================================================\n    // FlateDecodeParams Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_decode_params_default() {\n        let params = FlateDecodeParams::default();\n        assert_eq!(params.predictor, 0);\n        assert_eq!(params.colors, 0);\n        assert_eq!(params.bits_per_component, 0);\n        assert_eq!(params.columns, 0);\n    }\n\n    // ============================================================================\n    // LZWDecodeParams Tests\n    // ============================================================================\n\n    #[test]\n    fn test_lzw_decode_params_default() {\n        let params = LZWDecodeParams::default();\n        assert_eq!(params.predictor, 0);\n        assert_eq!(params.colors, 0);\n        assert_eq!(params.bits_per_component, 0);\n        assert_eq!(params.columns, 0);\n        assert_eq!(params.early_change, 0);\n    }\n\n    // ============================================================================\n    // FilterChain Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_chain_single() {\n        let original = b\"Test data for single filter\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::FlateDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_multiple() {\n        let original = b\"Test data for multiple filters\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::FlateDecode);\n        chain.add(FilterType::ASCII85Decode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_all_text() {\n        let original = b\"Test data for text filter chain\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::ASCIIHexDecode);\n        chain.add(FilterType::ASCII85Decode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_empty() {\n        let original = b\"No filters applied\";\n\n        let chain = FilterChain::new();\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_default() {\n        let chain: FilterChain = Default::default();\n        let data = b\"Test\";\n        let result = chain.decode(data.to_vec()).unwrap();\n        assert_eq!(\u0026result, data);\n    }\n\n    #[test]\n    fn test_filter_chain_with_lzw() {\n        let original = b\"LZW compressed data test with repeated patterns AAAAAABBBBBB\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::LZWDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_with_run_length() {\n        let original = b\"AAAAAABBBBBBCCCCCC run length test\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::RunLengthDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    // ============================================================================\n    // Predictor Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_with_predictor_none() {\n        let params = FlateDecodeParams {\n            predictor: 1,\n            colors: 3,\n            bits_per_component: 8,\n            columns: 10,\n        };\n\n        let original = vec![0u8; 30];\n        let compressed = encode_flate(\u0026original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, Some(\u0026params)).unwrap();\n        assert_eq!(decompressed, original);\n    }\n\n    // ============================================================================\n    // Unsupported Filter Tests\n    // ============================================================================\n\n    #[test]\n    fn test_jpx_decode_without_feature() {\n        #[cfg(not(feature = \"jpeg2000\"))]\n        {\n            let result = decode_jpx(\u0026[]);\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_jbig2_decode_without_feature() {\n        #[cfg(not(feature = \"jbig2\"))]\n        {\n            let result = decode_jbig2(\u0026[], None);\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_filter_chain_unsupported_encode() {\n        let original = b\"Test\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::CCITTFaxDecode);\n\n        let result = chain.encode(original.to_vec());\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // BitReader Tests\n    // ============================================================================\n\n    #[test]\n    fn test_bit_reader() {\n        let data = [0b10110100, 0b11001010];\n        let mut reader = BitReader::new(\u0026data);\n\n        // Read individual bits\n        assert_eq!(reader.read_bit(), Some(true));\n        assert_eq!(reader.read_bit(), Some(false));\n        assert_eq!(reader.read_bit(), Some(true));\n        assert_eq!(reader.read_bit(), Some(true));\n\n        // Read multiple bits at once\n        assert_eq!(reader.read_bits(4), Some(0b0100));\n        assert_eq!(reader.read_bits(8), Some(0b11001010));\n\n        // Read past end\n        assert_eq!(reader.read_bit(), None);\n    }\n\n    #[test]\n    fn test_bit_reader_empty() {\n        let data: \u0026[u8] = \u0026[];\n        let mut reader = BitReader::new(data);\n        assert_eq!(reader.read_bit(), None);\n        assert_eq!(reader.read_bits(8), None);\n    }\n\n    // ============================================================================\n    // Crypt Filter Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_chain_crypt_passthrough() {\n        let original = b\"Encrypted data passthrough\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::Crypt);\n\n        // Crypt is a passthrough in the filter chain\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        assert_eq!(\u0026encoded, original);\n\n        let decoded = chain.decode(original.to_vec()).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n}\n","traces":[{"line":39,"address":[2638688],"length":1,"stats":{"Line":1}},{"line":41,"address":[1756504],"length":1,"stats":{"Line":1}},{"line":42,"address":[2638794],"length":1,"stats":{"Line":1}},{"line":43,"address":[2638876],"length":1,"stats":{"Line":1}},{"line":44,"address":[1756750],"length":1,"stats":{"Line":1}},{"line":45,"address":[1756832],"length":1,"stats":{"Line":1}},{"line":46,"address":[2639122],"length":1,"stats":{"Line":1}},{"line":47,"address":[1756996],"length":1,"stats":{"Line":1}},{"line":48,"address":[2639340,2639286],"length":1,"stats":{"Line":2}},{"line":49,"address":[1757180,1757109],"length":1,"stats":{"Line":2}},{"line":50,"address":[1757202,1757157],"length":1,"stats":{"Line":2}},{"line":51,"address":[2639403],"length":1,"stats":{"Line":1}},{"line":56,"address":[1757232],"length":1,"stats":{"Line":1}},{"line":57,"address":[1757237],"length":1,"stats":{"Line":1}},{"line":58,"address":[2639476],"length":1,"stats":{"Line":1}},{"line":59,"address":[1757294],"length":1,"stats":{"Line":1}},{"line":60,"address":[1757320],"length":1,"stats":{"Line":1}},{"line":61,"address":[1757346],"length":1,"stats":{"Line":1}},{"line":62,"address":[1757372],"length":1,"stats":{"Line":1}},{"line":63,"address":[2639603],"length":1,"stats":{"Line":1}},{"line":64,"address":[1757418],"length":1,"stats":{"Line":1}},{"line":65,"address":[2639649],"length":1,"stats":{"Line":1}},{"line":66,"address":[1757464],"length":1,"stats":{"Line":1}},{"line":67,"address":[1757487],"length":1,"stats":{"Line":1}},{"line":122,"address":[1757520],"length":1,"stats":{"Line":1}},{"line":155,"address":[1758496,1758490,1757568],"length":1,"stats":{"Line":2}},{"line":156,"address":[1757606],"length":1,"stats":{"Line":2}},{"line":157,"address":[1757620],"length":1,"stats":{"Line":1}},{"line":158,"address":[1757765,1757876,1758475,1757680],"length":1,"stats":{"Line":7}},{"line":159,"address":[1757844],"length":1,"stats":{"Line":0}},{"line":162,"address":[1757921],"length":1,"stats":{"Line":5}},{"line":163,"address":[1757967,1758436],"length":1,"stats":{"Line":1}},{"line":164,"address":[1758084,1758441,1758313],"length":1,"stats":{"Line":0}},{"line":168,"address":[1757977],"length":1,"stats":{"Line":2}},{"line":172,"address":[2641302,2640688,2641296],"length":1,"stats":{"Line":1}},{"line":173,"address":[1758566],"length":1,"stats":{"Line":1}},{"line":174,"address":[1758571],"length":1,"stats":{"Line":1}},{"line":175,"address":[1758664,1758587],"length":1,"stats":{"Line":3}},{"line":176,"address":[1758649,1758697],"length":1,"stats":{"Line":3}},{"line":177,"address":[1758681],"length":1,"stats":{"Line":1}},{"line":180,"address":[1758608],"length":1,"stats":{"Line":1}},{"line":181,"address":[1758626],"length":1,"stats":{"Line":1}},{"line":182,"address":[1758949,1758755,1758838],"length":1,"stats":{"Line":6}},{"line":183,"address":[1758917],"length":1,"stats":{"Line":0}},{"line":185,"address":[1758999],"length":1,"stats":{"Line":1}},{"line":193,"address":[1760371,1760411,1759168],"length":1,"stats":{"Line":1}},{"line":194,"address":[1705013,1705008],"length":1,"stats":{"Line":1}},{"line":197,"address":[1759261],"length":1,"stats":{"Line":1}},{"line":198,"address":[2641425],"length":1,"stats":{"Line":1}},{"line":201,"address":[1760409,1759392,1759327,1759502],"length":1,"stats":{"Line":2}},{"line":202,"address":[1759473],"length":1,"stats":{"Line":0}},{"line":205,"address":[1759626],"length":1,"stats":{"Line":1}},{"line":206,"address":[1759673],"length":1,"stats":{"Line":1}},{"line":207,"address":[2642428,2641866],"length":1,"stats":{"Line":0}},{"line":209,"address":[1759849],"length":1,"stats":{"Line":0}},{"line":210,"address":[1759851],"length":1,"stats":{"Line":0}},{"line":211,"address":[1759854],"length":1,"stats":{"Line":0}},{"line":212,"address":[1759857],"length":1,"stats":{"Line":0}},{"line":214,"address":[1759987,1760166,1759888],"length":1,"stats":{"Line":0}},{"line":218,"address":[1759729],"length":1,"stats":{"Line":1}},{"line":222,"address":[1760617,1760611,1760432],"length":1,"stats":{"Line":1}},{"line":223,"address":[1760466],"length":1,"stats":{"Line":1}},{"line":224,"address":[1760516,1760574],"length":1,"stats":{"Line":2}},{"line":225,"address":[2278272,2278289],"length":1,"stats":{"Line":0}},{"line":233,"address":[1760640,1762640,1762646],"length":1,"stats":{"Line":1}},{"line":234,"address":[1760818,1760692],"length":1,"stats":{"Line":2}},{"line":235,"address":[1760775],"length":1,"stats":{"Line":1}},{"line":236,"address":[1760786],"length":1,"stats":{"Line":2}},{"line":238,"address":[1760797,1760885],"length":1,"stats":{"Line":3}},{"line":240,"address":[1760994,1761025],"length":1,"stats":{"Line":3}},{"line":245,"address":[1761031],"length":1,"stats":{"Line":1}},{"line":250,"address":[1761041],"length":1,"stats":{"Line":2}},{"line":251,"address":[1761714],"length":1,"stats":{"Line":1}},{"line":252,"address":[1761848,1761797],"length":1,"stats":{"Line":2}},{"line":254,"address":[1761759,1761835],"length":1,"stats":{"Line":2}},{"line":259,"address":[1761726,1761978],"length":1,"stats":{"Line":3}},{"line":260,"address":[1761984,1762043],"length":1,"stats":{"Line":2}},{"line":263,"address":[1762011,1762263,1762382],"length":1,"stats":{"Line":3}},{"line":264,"address":[1762429,1762362,1762407],"length":1,"stats":{"Line":3}},{"line":266,"address":[2644759,2644538],"length":1,"stats":{"Line":2}},{"line":267,"address":[1762450],"length":1,"stats":{"Line":1}},{"line":268,"address":[1762494],"length":1,"stats":{"Line":1}},{"line":269,"address":[1762538],"length":1,"stats":{"Line":1}},{"line":270,"address":[2644704],"length":1,"stats":{"Line":1}},{"line":271,"address":[1762613],"length":1,"stats":{"Line":1}},{"line":272,"address":[2644748],"length":1,"stats":{"Line":1}},{"line":277,"address":[1761005],"length":1,"stats":{"Line":1}},{"line":279,"address":[1761688,1761164],"length":1,"stats":{"Line":4}},{"line":280,"address":[1761693,1761254,1761642],"length":1,"stats":{"Line":4}},{"line":283,"address":[1761286],"length":1,"stats":{"Line":3}},{"line":284,"address":[1761453,1761503],"length":1,"stats":{"Line":8}},{"line":288,"address":[1761068],"length":1,"stats":{"Line":1}},{"line":292,"address":[1764510,1764504,1762672],"length":1,"stats":{"Line":1}},{"line":293,"address":[2644842,2644950],"length":1,"stats":{"Line":2}},{"line":295,"address":[1762824],"length":1,"stats":{"Line":2}},{"line":296,"address":[1762859,1764199,1762836],"length":1,"stats":{"Line":5}},{"line":297,"address":[1762915,1763118],"length":1,"stats":{"Line":3}},{"line":298,"address":[1763178],"length":1,"stats":{"Line":2}},{"line":300,"address":[1763334],"length":1,"stats":{"Line":1}},{"line":301,"address":[1763345,1764478],"length":1,"stats":{"Line":3}},{"line":302,"address":[1763613,1764372,1764483],"length":1,"stats":{"Line":3}},{"line":306,"address":[1763650],"length":1,"stats":{"Line":2}},{"line":307,"address":[1763737],"length":1,"stats":{"Line":1}},{"line":308,"address":[1763768],"length":1,"stats":{"Line":1}},{"line":312,"address":[1763674],"length":1,"stats":{"Line":2}},{"line":313,"address":[1763693],"length":1,"stats":{"Line":2}},{"line":314,"address":[1764359,1763839,1763707],"length":1,"stats":{"Line":5}},{"line":315,"address":[1764229,1764310,1763976],"length":1,"stats":{"Line":4}},{"line":316,"address":[1764303,1764336],"length":1,"stats":{"Line":4}},{"line":320,"address":[1764000,1764093],"length":1,"stats":{"Line":2}},{"line":321,"address":[1764134,1764044],"length":1,"stats":{"Line":3}},{"line":323,"address":[2646276,2646312],"length":1,"stats":{"Line":2}},{"line":327,"address":[1762869],"length":1,"stats":{"Line":1}},{"line":329,"address":[2645123],"length":1,"stats":{"Line":1}},{"line":337,"address":[1764528,1765693,1765687],"length":1,"stats":{"Line":1}},{"line":338,"address":[1764579],"length":1,"stats":{"Line":1}},{"line":339,"address":[1764613],"length":1,"stats":{"Line":1}},{"line":341,"address":[1764690,1764618],"length":1,"stats":{"Line":2}},{"line":343,"address":[1764775,1764809],"length":1,"stats":{"Line":4}},{"line":348,"address":[2646927],"length":1,"stats":{"Line":2}},{"line":353,"address":[1764822,1765003,1765519],"length":1,"stats":{"Line":8}},{"line":354,"address":[2647105,2647158,2647566],"length":1,"stats":{"Line":8}},{"line":355,"address":[1765036,1765103,1765368],"length":1,"stats":{"Line":3}},{"line":356,"address":[1765136,1765079],"length":1,"stats":{"Line":2}},{"line":359,"address":[1765431],"length":1,"stats":{"Line":2}},{"line":360,"address":[1765562],"length":1,"stats":{"Line":3}},{"line":361,"address":[1765546],"length":1,"stats":{"Line":2}},{"line":362,"address":[1765614,1765560],"length":1,"stats":{"Line":6}},{"line":363,"address":[1765649],"length":1,"stats":{"Line":3}},{"line":369,"address":[1764839,1764786],"length":1,"stats":{"Line":2}},{"line":370,"address":[1764949,1764854],"length":1,"stats":{"Line":2}},{"line":373,"address":[1764861],"length":1,"stats":{"Line":1}},{"line":377,"address":[1765712,1766569,1766563],"length":1,"stats":{"Line":1}},{"line":378,"address":[1765758,1765867],"length":1,"stats":{"Line":1}},{"line":380,"address":[1765931,1765846],"length":1,"stats":{"Line":2}},{"line":381,"address":[1766030,1766167],"length":1,"stats":{"Line":2}},{"line":382,"address":[1766185],"length":1,"stats":{"Line":1}},{"line":384,"address":[1766199],"length":1,"stats":{"Line":1}},{"line":385,"address":[1766377],"length":1,"stats":{"Line":1}},{"line":388,"address":[1766035],"length":1,"stats":{"Line":1}},{"line":390,"address":[1766073],"length":1,"stats":{"Line":1}},{"line":398,"address":[1768036,1766592,1768042],"length":1,"stats":{"Line":1}},{"line":399,"address":[1766647],"length":1,"stats":{"Line":1}},{"line":400,"address":[2648773],"length":1,"stats":{"Line":1}},{"line":402,"address":[1766681],"length":1,"stats":{"Line":1}},{"line":403,"address":[2648915,2648997],"length":1,"stats":{"Line":1}},{"line":404,"address":[1766848,1766958,1766976],"length":1,"stats":{"Line":3}},{"line":406,"address":[1766966],"length":1,"stats":{"Line":2}},{"line":409,"address":[1767890,1766998],"length":1,"stats":{"Line":5}},{"line":411,"address":[1767576,1767058,1767604],"length":1,"stats":{"Line":2}},{"line":412,"address":[1767584,1767638],"length":1,"stats":{"Line":4}},{"line":413,"address":[1767704,1767924],"length":1,"stats":{"Line":0}},{"line":415,"address":[1767671,1767771],"length":1,"stats":{"Line":4}},{"line":416,"address":[1767861,1767895],"length":1,"stats":{"Line":2}},{"line":419,"address":[1767117,1767024,1767097],"length":1,"stats":{"Line":6}},{"line":420,"address":[1767105],"length":1,"stats":{"Line":3}},{"line":421,"address":[1767445,1767166],"length":1,"stats":{"Line":0}},{"line":423,"address":[1767220,1767271,1767146],"length":1,"stats":{"Line":6}},{"line":424,"address":[1767234,1767329,1767297],"length":1,"stats":{"Line":6}},{"line":425,"address":[1767360,1767305],"length":1,"stats":{"Line":6}},{"line":429,"address":[2648811],"length":1,"stats":{"Line":2}},{"line":433,"address":[1769916,1769910,1768064],"length":1,"stats":{"Line":1}},{"line":434,"address":[1768119],"length":1,"stats":{"Line":1}},{"line":435,"address":[2650245],"length":1,"stats":{"Line":1}},{"line":437,"address":[2650265],"length":1,"stats":{"Line":1}},{"line":439,"address":[1768202],"length":1,"stats":{"Line":1}},{"line":440,"address":[2650543,2650578,2650338],"length":1,"stats":{"Line":3}},{"line":441,"address":[1768556,1768494,1768448,1769884],"length":1,"stats":{"Line":7}},{"line":442,"address":[1768721,1769876,1769889],"length":1,"stats":{"Line":5}},{"line":444,"address":[1768512,1768763,1768779],"length":1,"stats":{"Line":4}},{"line":446,"address":[1768771],"length":1,"stats":{"Line":1}},{"line":448,"address":[2651890,2650959],"length":1,"stats":{"Line":6}},{"line":449,"address":[1769834],"length":1,"stats":{"Line":3}},{"line":452,"address":[2650920],"length":1,"stats":{"Line":1}},{"line":453,"address":[1768816],"length":1,"stats":{"Line":1}},{"line":455,"address":[2650949,2650999],"length":1,"stats":{"Line":2}},{"line":457,"address":[2651047,2651149],"length":1,"stats":{"Line":3}},{"line":460,"address":[2651110,2651567,2651601],"length":1,"stats":{"Line":4}},{"line":461,"address":[2651575,2651627],"length":1,"stats":{"Line":3}},{"line":466,"address":[1768902,1769558,1769577],"length":1,"stats":{"Line":4}},{"line":467,"address":[2651678],"length":1,"stats":{"Line":1}},{"line":468,"address":[2651715],"length":1,"stats":{"Line":2}},{"line":469,"address":[2651808],"length":1,"stats":{"Line":2}},{"line":475,"address":[1768163],"length":1,"stats":{"Line":1}},{"line":477,"address":[2650428],"length":1,"stats":{"Line":1}},{"line":485,"address":[2652048,2653159,2653165],"length":1,"stats":{"Line":0}},{"line":489,"address":[2652104],"length":1,"stats":{"Line":0}},{"line":490,"address":[2652121],"length":1,"stats":{"Line":0}},{"line":497,"address":[2652157,2652203],"length":1,"stats":{"Line":0}},{"line":498,"address":[2652193,2652221],"length":1,"stats":{"Line":0}},{"line":500,"address":[1770229,1770298],"length":1,"stats":{"Line":0}},{"line":504,"address":[2652433,2652390],"length":1,"stats":{"Line":0}},{"line":505,"address":[2652910,2652554],"length":1,"stats":{"Line":0}},{"line":508,"address":[1770471,1770643,1770412],"length":1,"stats":{"Line":0}},{"line":512,"address":[1770771],"length":1,"stats":{"Line":0}},{"line":513,"address":[2653048,2652920,2653157],"length":1,"stats":{"Line":0}},{"line":514,"address":[2653150],"length":1,"stats":{"Line":0}},{"line":518,"address":[1770842],"length":1,"stats":{"Line":0}},{"line":522,"address":[2654231,2653184,2654280],"length":1,"stats":{"Line":0}},{"line":526,"address":[1771240,1771177],"length":1,"stats":{"Line":0}},{"line":527,"address":[1771232,1771253],"length":1,"stats":{"Line":0}},{"line":529,"address":[2653469,2653381],"length":1,"stats":{"Line":0}},{"line":530,"address":[1771345],"length":1,"stats":{"Line":0}},{"line":531,"address":[1771432],"length":1,"stats":{"Line":0}},{"line":533,"address":[2653621],"length":1,"stats":{"Line":0}},{"line":534,"address":[1771573],"length":1,"stats":{"Line":0}},{"line":536,"address":[1771585],"length":1,"stats":{"Line":0}},{"line":538,"address":[2653800],"length":1,"stats":{"Line":0}},{"line":540,"address":[2654057,2653978],"length":1,"stats":{"Line":0}},{"line":541,"address":[2654099],"length":1,"stats":{"Line":0}},{"line":542,"address":[2654106],"length":1,"stats":{"Line":0}},{"line":543,"address":[2654211,2654158],"length":1,"stats":{"Line":0}},{"line":549,"address":[1771611],"length":1,"stats":{"Line":0}},{"line":560,"address":[1772240],"length":1,"stats":{"Line":1}},{"line":568,"address":[2654368],"length":1,"stats":{"Line":2}},{"line":569,"address":[1772302],"length":1,"stats":{"Line":2}},{"line":570,"address":[1772342],"length":1,"stats":{"Line":1}},{"line":573,"address":[1772362,1772486,1772317],"length":1,"stats":{"Line":2}},{"line":574,"address":[2654588,2654599,2654548],"length":1,"stats":{"Line":2}},{"line":575,"address":[2654670,2654591],"length":1,"stats":{"Line":2}},{"line":576,"address":[1772554],"length":1,"stats":{"Line":1}},{"line":577,"address":[1772558,1772592],"length":1,"stats":{"Line":1}},{"line":580,"address":[2654616],"length":1,"stats":{"Line":1}},{"line":583,"address":[2654704],"length":1,"stats":{"Line":1}},{"line":584,"address":[1772643],"length":1,"stats":{"Line":1}},{"line":585,"address":[1772651,1772823],"length":1,"stats":{"Line":2}},{"line":586,"address":[2654857,2654775],"length":1,"stats":{"Line":2}},{"line":588,"address":[2654828],"length":1,"stats":{"Line":1}},{"line":593,"address":[2654912],"length":1,"stats":{"Line":0}},{"line":601,"address":[2654980],"length":1,"stats":{"Line":0}},{"line":602,"address":[2654998],"length":1,"stats":{"Line":0}},{"line":610,"address":[1772944,1773511,1773543],"length":1,"stats":{"Line":0}},{"line":615,"address":[1772992],"length":1,"stats":{"Line":0}},{"line":616,"address":[2655083],"length":1,"stats":{"Line":0}},{"line":619,"address":[2655108,2655265,2655298],"length":1,"stats":{"Line":0}},{"line":620,"address":[1773124],"length":1,"stats":{"Line":0}},{"line":622,"address":[1773326,1773447],"length":1,"stats":{"Line":0}},{"line":626,"address":[1774442,1774448,1773552],"length":1,"stats":{"Line":0}},{"line":631,"address":[1773619,1773797],"length":1,"stats":{"Line":0}},{"line":632,"address":[1705664,1705678],"length":1,"stats":{"Line":0}},{"line":634,"address":[2655978,2656038],"length":1,"stats":{"Line":0}},{"line":635,"address":[1773996,1774204,1774085],"length":1,"stats":{"Line":0}},{"line":636,"address":[1774172],"length":1,"stats":{"Line":0}},{"line":640,"address":[2656294],"length":1,"stats":{"Line":0}},{"line":686,"address":[2656528],"length":1,"stats":{"Line":1}},{"line":687,"address":[1774487],"length":1,"stats":{"Line":1}},{"line":695,"address":[1774608],"length":1,"stats":{"Line":1}},{"line":709,"address":[1774637],"length":1,"stats":{"Line":1}},{"line":718,"address":[2656832],"length":1,"stats":{"Line":0}},{"line":719,"address":[2656888],"length":1,"stats":{"Line":0}},{"line":720,"address":[2656897],"length":1,"stats":{"Line":0}},{"line":721,"address":[2656931],"length":1,"stats":{"Line":0}},{"line":722,"address":[1774901],"length":1,"stats":{"Line":0}},{"line":725,"address":[1775043,1774943],"length":1,"stats":{"Line":0}},{"line":726,"address":[1775028,1775066,1775179],"length":1,"stats":{"Line":0}},{"line":728,"address":[1775150],"length":1,"stats":{"Line":0}},{"line":729,"address":[2657286],"length":1,"stats":{"Line":0}},{"line":730,"address":[2657375],"length":1,"stats":{"Line":0}},{"line":731,"address":[1775192,1775572],"length":1,"stats":{"Line":0}},{"line":732,"address":[1775329],"length":1,"stats":{"Line":0}},{"line":737,"address":[2657696,2658956,2658962],"length":1,"stats":{"Line":0}},{"line":738,"address":[2657791],"length":1,"stats":{"Line":0}},{"line":740,"address":[1775775,1775845],"length":1,"stats":{"Line":0}},{"line":741,"address":[2658113],"length":1,"stats":{"Line":0}},{"line":743,"address":[2658271,2658341],"length":1,"stats":{"Line":0}},{"line":744,"address":[2658530,2658583,2658951],"length":1,"stats":{"Line":0}},{"line":745,"address":[2658809],"length":1,"stats":{"Line":0}},{"line":746,"address":[2658877],"length":1,"stats":{"Line":0}},{"line":747,"address":[2658911],"length":1,"stats":{"Line":0}},{"line":752,"address":[1776097],"length":1,"stats":{"Line":0}},{"line":756,"address":[2660865,2658976,2660871],"length":1,"stats":{"Line":0}},{"line":758,"address":[2659063,2659180],"length":1,"stats":{"Line":0}},{"line":759,"address":[2659112],"length":1,"stats":{"Line":0}},{"line":760,"address":[1777104],"length":1,"stats":{"Line":0}},{"line":762,"address":[2659325,2659258],"length":1,"stats":{"Line":0}},{"line":763,"address":[1777498,1777645],"length":1,"stats":{"Line":0}},{"line":767,"address":[1777749,1777663],"length":1,"stats":{"Line":0}},{"line":768,"address":[1777797,1777702],"length":1,"stats":{"Line":0}},{"line":770,"address":[1777813],"length":1,"stats":{"Line":0}},{"line":772,"address":[1777892],"length":1,"stats":{"Line":0}},{"line":773,"address":[2660283],"length":1,"stats":{"Line":0}},{"line":774,"address":[1778319],"length":1,"stats":{"Line":0}},{"line":776,"address":[1777946,1777842,1778215],"length":1,"stats":{"Line":0}},{"line":780,"address":[1778185,1778630],"length":1,"stats":{"Line":0}},{"line":781,"address":[2660683],"length":1,"stats":{"Line":0}},{"line":784,"address":[2659568],"length":1,"stats":{"Line":0}},{"line":788,"address":[1778880],"length":1,"stats":{"Line":0}},{"line":795,"address":[2661026],"length":1,"stats":{"Line":0}},{"line":798,"address":[1779301],"length":1,"stats":{"Line":0}},{"line":802,"address":[1779768,1779329],"length":1,"stats":{"Line":0}},{"line":803,"address":[2661919,2661906,2662045],"length":1,"stats":{"Line":0}},{"line":804,"address":[2661929,2662023,2662047],"length":1,"stats":{"Line":0}},{"line":806,"address":[1779879],"length":1,"stats":{"Line":0}},{"line":808,"address":[1779933],"length":1,"stats":{"Line":0}},{"line":813,"address":[2661469,2662060],"length":1,"stats":{"Line":0}},{"line":814,"address":[2662172],"length":1,"stats":{"Line":0}},{"line":815,"address":[2662217],"length":1,"stats":{"Line":0}},{"line":820,"address":[1779545,1780226],"length":1,"stats":{"Line":0}},{"line":821,"address":[2662543,2662372,2662388],"length":1,"stats":{"Line":0}},{"line":822,"address":[1780490,1780515,1780367],"length":1,"stats":{"Line":0}},{"line":824,"address":[2662377],"length":1,"stats":{"Line":0}},{"line":826,"address":[2662445],"length":1,"stats":{"Line":0}},{"line":827,"address":[2662489,2662615,2662566],"length":1,"stats":{"Line":0}},{"line":828,"address":[1780545],"length":1,"stats":{"Line":0}},{"line":833,"address":[1780598,1779653],"length":1,"stats":{"Line":0}},{"line":834,"address":[2662774,2662933,2662743],"length":1,"stats":{"Line":0}},{"line":835,"address":[1780754,1780882,1780906],"length":1,"stats":{"Line":0}},{"line":837,"address":[1780736],"length":1,"stats":{"Line":0}},{"line":839,"address":[2662831],"length":1,"stats":{"Line":0}},{"line":840,"address":[1780862,1780927],"length":1,"stats":{"Line":0}},{"line":841,"address":[2663089,2662971],"length":1,"stats":{"Line":0}},{"line":843,"address":[2662948],"length":1,"stats":{"Line":0}},{"line":845,"address":[1780968],"length":1,"stats":{"Line":0}},{"line":846,"address":[2663034],"length":1,"stats":{"Line":0}},{"line":850,"address":[2661072],"length":1,"stats":{"Line":0}},{"line":854,"address":[1779756],"length":1,"stats":{"Line":0}},{"line":858,"address":[2663152],"length":1,"stats":{"Line":0}},{"line":859,"address":[2663174],"length":1,"stats":{"Line":0}},{"line":860,"address":[2663185],"length":1,"stats":{"Line":0}},{"line":861,"address":[1781164],"length":1,"stats":{"Line":0}},{"line":863,"address":[2663277,2663207],"length":1,"stats":{"Line":0}},{"line":864,"address":[1781262,1781298,1781232],"length":1,"stats":{"Line":0}},{"line":865,"address":[1781351,1781285,1781315],"length":1,"stats":{"Line":0}},{"line":866,"address":[1781397,1781338,1781368],"length":1,"stats":{"Line":0}},{"line":868,"address":[1781391,1781432,1781444],"length":1,"stats":{"Line":0}},{"line":869,"address":[2663472],"length":1,"stats":{"Line":0}},{"line":870,"address":[1781418,1781454],"length":1,"stats":{"Line":0}},{"line":871,"address":[1781460],"length":1,"stats":{"Line":0}},{"line":873,"address":[1781450],"length":1,"stats":{"Line":0}},{"line":888,"address":[1781488],"length":1,"stats":{"Line":1}},{"line":889,"address":[2663533],"length":1,"stats":{"Line":1}},{"line":892,"address":[2663584],"length":1,"stats":{"Line":2}},{"line":893,"address":[2663600],"length":1,"stats":{"Line":3}},{"line":897,"address":[1781600,1785010],"length":1,"stats":{"Line":1}},{"line":898,"address":[2663690,2663789,2666820],"length":1,"stats":{"Line":4}},{"line":899,"address":[1784921,1784865,1781867,1782653],"length":1,"stats":{"Line":4}},{"line":900,"address":[1782030,1782397,1782672],"length":1,"stats":{"Line":2}},{"line":901,"address":[1782068,1782709],"length":1,"stats":{"Line":2}},{"line":902,"address":[1782106,1782988],"length":1,"stats":{"Line":2}},{"line":903,"address":[2664165,2665240],"length":1,"stats":{"Line":2}},{"line":904,"address":[1782173,1783500],"length":1,"stats":{"Line":2}},{"line":905,"address":[1782205,1783766],"length":1,"stats":{"Line":0}},{"line":906,"address":[1784059,1782237],"length":1,"stats":{"Line":0}},{"line":907,"address":[1782269,1784335],"length":1,"stats":{"Line":0}},{"line":908,"address":[1782301,1784591],"length":1,"stats":{"Line":0}},{"line":909,"address":[2664357],"length":1,"stats":{"Line":1}},{"line":912,"address":[1781918],"length":1,"stats":{"Line":2}},{"line":916,"address":[1787881,1785040],"length":1,"stats":{"Line":1}},{"line":917,"address":[1785201,1785098,1787779],"length":1,"stats":{"Line":6}},{"line":918,"address":[1787792,1787736,1785406,1786185],"length":1,"stats":{"Line":4}},{"line":919,"address":[1785563,1786204,1785944],"length":1,"stats":{"Line":2}},{"line":920,"address":[1785595,1786235],"length":1,"stats":{"Line":2}},{"line":921,"address":[1785627,1786491],"length":1,"stats":{"Line":4}},{"line":922,"address":[1786747,1785659],"length":1,"stats":{"Line":2}},{"line":923,"address":[1787002,1785691],"length":1,"stats":{"Line":2}},{"line":925,"address":[2667598,2669080],"length":1,"stats":{"Line":2}},{"line":928,"address":[1787376,1785755],"length":1,"stats":{"Line":0}},{"line":931,"address":[1787496,1785796],"length":1,"stats":{"Line":0}},{"line":934,"address":[1785837,1787616],"length":1,"stats":{"Line":0}},{"line":936,"address":[1785886],"length":1,"stats":{"Line":1}},{"line":939,"address":[1785451],"length":1,"stats":{"Line":1}},{"line":944,"address":[1787904],"length":1,"stats":{"Line":1}},{"line":945,"address":[1787912],"length":1,"stats":{"Line":1}}],"covered":218,"coverable":363},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","font.rs"],"content":"//! PDF font module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","form.rs"],"content":"//! PDF form module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","image.rs"],"content":"//! PDF image module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","interpret.rs"],"content":"//! PDF interpret module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","lexer.rs"],"content":"//! PDF tokenizer\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","mod.rs"],"content":"//! PDF-specific parsing and document handling\n\npub mod object;\npub mod lexer;\npub mod parser;\npub mod xref;\npub mod document;\npub mod crypt;\npub mod page;\npub mod font;\npub mod cmap;\npub mod colorspace;\npub mod image;\npub mod annot;\npub mod form;\npub mod filter;\npub mod interpret;\npub mod write;\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","object.rs"],"content":"//! PDF object types\nuse std::collections::HashMap;\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct Name(pub String);\nimpl Name { pub fn new(s: \u0026str) -\u003e Self { Self(s.to_string()) } }\nimpl fmt::Display for Name { fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result { write!(f, \"/{}\", self.0) } }\n\n#[derive(Debug, Clone)]\npub struct PdfString(Vec\u003cu8\u003e);\nimpl PdfString {\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self { Self(data) }\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] { \u0026self.0 }\n    pub fn as_str(\u0026self) -\u003e Option\u003c\u0026str\u003e { std::str::from_utf8(\u0026self.0).ok() }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ObjRef { pub num: i32, pub generation: i32 }\nimpl ObjRef { pub fn new(num: i32, generation: i32) -\u003e Self { Self { num, generation } } }\n\npub type Dict = HashMap\u003cName, Object\u003e;\npub type Array = Vec\u003cObject\u003e;\n\n#[derive(Debug, Clone)]\npub enum Object {\n    Null,\n    Bool(bool),\n    Int(i64),\n    Real(f64),\n    String(PdfString),\n    Name(Name),\n    Array(Array),\n    Dict(Dict),\n    Stream { dict: Dict, data: Vec\u003cu8\u003e },\n    Ref(ObjRef),\n}\n\nimpl Object {\n    pub fn is_null(\u0026self) -\u003e bool { matches!(self, Object::Null) }\n    pub fn as_bool(\u0026self) -\u003e Option\u003cbool\u003e { if let Object::Bool(b) = self { Some(*b) } else { None } }\n    pub fn as_int(\u0026self) -\u003e Option\u003ci64\u003e { if let Object::Int(i) = self { Some(*i) } else { None } }\n    pub fn as_real(\u0026self) -\u003e Option\u003cf64\u003e {\n        match self { Object::Real(r) =\u003e Some(*r), Object::Int(i) =\u003e Some(*i as f64), _ =\u003e None }\n    }\n    pub fn as_name(\u0026self) -\u003e Option\u003c\u0026Name\u003e { if let Object::Name(n) = self { Some(n) } else { None } }\n    pub fn as_string(\u0026self) -\u003e Option\u003c\u0026PdfString\u003e { if let Object::String(s) = self { Some(s) } else { None } }\n    pub fn as_array(\u0026self) -\u003e Option\u003c\u0026Array\u003e { if let Object::Array(a) = self { Some(a) } else { None } }\n    pub fn as_dict(\u0026self) -\u003e Option\u003c\u0026Dict\u003e { if let Object::Dict(d) = self { Some(d) } else { None } }\n}\n\nimpl Default for Object { fn default() -\u003e Self { Object::Null } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Name tests\n    #[test]\n    fn test_name_new() {\n        let name = Name::new(\"Type\");\n        assert_eq!(name.0, \"Type\");\n    }\n\n    #[test]\n    fn test_name_display() {\n        let name = Name::new(\"Page\");\n        assert_eq!(format!(\"{}\", name), \"/Page\");\n    }\n\n    #[test]\n    fn test_name_eq() {\n        let n1 = Name::new(\"Test\");\n        let n2 = Name::new(\"Test\");\n        let n3 = Name::new(\"Other\");\n        assert_eq!(n1, n2);\n        assert_ne!(n1, n3);\n    }\n\n    #[test]\n    fn test_name_hash() {\n        use std::collections::HashSet;\n        let mut set = HashSet::new();\n        set.insert(Name::new(\"A\"));\n        set.insert(Name::new(\"B\"));\n        set.insert(Name::new(\"A\")); // duplicate\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_name_clone() {\n        let n1 = Name::new(\"Clone\");\n        let n2 = n1.clone();\n        assert_eq!(n1, n2);\n    }\n\n    // PdfString tests\n    #[test]\n    fn test_pdf_string_new() {\n        let s = PdfString::new(vec![72, 101, 108, 108, 111]);\n        assert_eq!(s.as_bytes(), b\"Hello\");\n    }\n\n    #[test]\n    fn test_pdf_string_as_str() {\n        let s = PdfString::new(b\"Hello World\".to_vec());\n        assert_eq!(s.as_str(), Some(\"Hello World\"));\n    }\n\n    #[test]\n    fn test_pdf_string_as_str_invalid_utf8() {\n        let s = PdfString::new(vec![0xFF, 0xFE]);\n        assert_eq!(s.as_str(), None);\n    }\n\n    #[test]\n    fn test_pdf_string_clone() {\n        let s1 = PdfString::new(b\"Test\".to_vec());\n        let s2 = s1.clone();\n        assert_eq!(s1.as_bytes(), s2.as_bytes());\n    }\n\n    // ObjRef tests\n    #[test]\n    fn test_obj_ref_new() {\n        let r = ObjRef::new(10, 0);\n        assert_eq!(r.num, 10);\n        assert_eq!(r.generation, 0);\n    }\n\n    #[test]\n    fn test_obj_ref_eq() {\n        let r1 = ObjRef::new(5, 0);\n        let r2 = ObjRef::new(5, 0);\n        let r3 = ObjRef::new(5, 1);\n        assert_eq!(r1, r2);\n        assert_ne!(r1, r3);\n    }\n\n    #[test]\n    fn test_obj_ref_hash() {\n        use std::collections::HashSet;\n        let mut set = HashSet::new();\n        set.insert(ObjRef::new(1, 0));\n        set.insert(ObjRef::new(2, 0));\n        set.insert(ObjRef::new(1, 0)); // duplicate\n        assert_eq!(set.len(), 2);\n    }\n\n    // Object tests\n    #[test]\n    fn test_object_null() {\n        let obj = Object::Null;\n        assert!(obj.is_null());\n        assert_eq!(obj.as_bool(), None);\n        assert_eq!(obj.as_int(), None);\n    }\n\n    #[test]\n    fn test_object_bool() {\n        let obj_true = Object::Bool(true);\n        let obj_false = Object::Bool(false);\n\n        assert!(!obj_true.is_null());\n        assert_eq!(obj_true.as_bool(), Some(true));\n        assert_eq!(obj_false.as_bool(), Some(false));\n    }\n\n    #[test]\n    fn test_object_int() {\n        let obj = Object::Int(42);\n        assert_eq!(obj.as_int(), Some(42));\n        assert_eq!(obj.as_real(), Some(42.0));\n    }\n\n    #[test]\n    fn test_object_real() {\n        let obj = Object::Real(3.14);\n        assert_eq!(obj.as_real(), Some(3.14));\n        assert_eq!(obj.as_int(), None);\n    }\n\n    #[test]\n    fn test_object_string() {\n        let obj = Object::String(PdfString::new(b\"Hello\".to_vec()));\n        let s = obj.as_string().unwrap();\n        assert_eq!(s.as_bytes(), b\"Hello\");\n    }\n\n    #[test]\n    fn test_object_name() {\n        let obj = Object::Name(Name::new(\"Type\"));\n        let n = obj.as_name().unwrap();\n        assert_eq!(n.0, \"Type\");\n    }\n\n    #[test]\n    fn test_object_array() {\n        let arr = vec![Object::Int(1), Object::Int(2), Object::Int(3)];\n        let obj = Object::Array(arr);\n        let a = obj.as_array().unwrap();\n        assert_eq!(a.len(), 3);\n    }\n\n    #[test]\n    fn test_object_dict() {\n        let mut dict = HashMap::new();\n        dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n        let obj = Object::Dict(dict);\n        let d = obj.as_dict().unwrap();\n        assert_eq!(d.len(), 1);\n    }\n\n    #[test]\n    fn test_object_stream() {\n        let mut dict = HashMap::new();\n        dict.insert(Name::new(\"Length\"), Object::Int(5));\n        let obj = Object::Stream { dict, data: b\"Hello\".to_vec() };\n\n        if let Object::Stream { dict, data } = obj {\n            assert_eq!(data, b\"Hello\");\n            assert!(dict.contains_key(\u0026Name::new(\"Length\")));\n        } else {\n            panic!(\"Expected Stream\");\n        }\n    }\n\n    #[test]\n    fn test_object_ref() {\n        let obj = Object::Ref(ObjRef::new(10, 0));\n        if let Object::Ref(r) = obj {\n            assert_eq!(r.num, 10);\n            assert_eq!(r.generation, 0);\n        } else {\n            panic!(\"Expected Ref\");\n        }\n    }\n\n    #[test]\n    fn test_object_default() {\n        let obj: Object = Default::default();\n        assert!(obj.is_null());\n    }\n\n    #[test]\n    fn test_object_clone() {\n        let obj = Object::Int(123);\n        let cloned = obj.clone();\n        assert_eq!(cloned.as_int(), Some(123));\n    }\n\n    #[test]\n    fn test_object_debug() {\n        let obj = Object::Int(42);\n        let debug = format!(\"{:?}\", obj);\n        assert!(debug.contains(\"Int\"));\n        assert!(debug.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_complex_nested_structure() {\n        let mut inner_dict = HashMap::new();\n        inner_dict.insert(Name::new(\"Key\"), Object::String(PdfString::new(b\"Value\".to_vec())));\n\n        let arr = vec![\n            Object::Int(1),\n            Object::Real(2.5),\n            Object::Dict(inner_dict),\n        ];\n\n        let mut outer_dict = HashMap::new();\n        outer_dict.insert(Name::new(\"Array\"), Object::Array(arr));\n\n        let obj = Object::Dict(outer_dict);\n        let d = obj.as_dict().unwrap();\n        let arr_obj = d.get(\u0026Name::new(\"Array\")).unwrap();\n        let inner_arr = arr_obj.as_array().unwrap();\n\n        assert_eq!(inner_arr.len(), 3);\n        assert_eq!(inner_arr[0].as_int(), Some(1));\n        assert_eq!(inner_arr[1].as_real(), Some(2.5));\n    }\n}\n\n","traces":[{"line":7,"address":[1678032,1678055],"length":1,"stats":{"Line":2}},{"line":8,"address":[1524648,1524624],"length":1,"stats":{"Line":2}},{"line":13,"address":[1524739,1524736],"length":1,"stats":{"Line":2}},{"line":14,"address":[1524768,1524773],"length":1,"stats":{"Line":2}},{"line":15,"address":[1524793,1524784],"length":1,"stats":{"Line":2}},{"line":20,"address":[1524860,1524848],"length":1,"stats":{"Line":2}},{"line":40,"address":[1524864,1524869],"length":1,"stats":{"Line":2}},{"line":41,"address":[1524922,1524912],"length":1,"stats":{"Line":3}},{"line":42,"address":[1525008,1525018],"length":1,"stats":{"Line":3}},{"line":43,"address":[1525120],"length":1,"stats":{"Line":1}},{"line":44,"address":[1525130],"length":1,"stats":{"Line":1}},{"line":46,"address":[1525296,1525306],"length":1,"stats":{"Line":2}},{"line":47,"address":[1525392,1525402],"length":1,"stats":{"Line":2}},{"line":48,"address":[1525488,1525498],"length":1,"stats":{"Line":2}},{"line":49,"address":[1525594,1525584],"length":1,"stats":{"Line":2}},{"line":52,"address":[1525683,1525680],"length":1,"stats":{"Line":2}}],"covered":16,"coverable":16},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","page.rs"],"content":"//! PDF page implementation\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","parser.rs"],"content":"//! PDF parser\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","write.rs"],"content":"//! PDF write module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","xref.rs"],"content":"//! Cross-reference tables\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","tests","integration_tests.rs"],"content":"//! Integration tests for MicroPDF\n//!\n//! These tests verify that the library can correctly parse and handle\n//! various PDF document types and content.\n\nuse std::path::PathBuf;\n\n/// Get the path to a test fixture\nfn fixture_path(name: \u0026str) -\u003e PathBuf {\n    let mut path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    path.push(\"tests\");\n    path.push(\"fixtures\");\n    path.push(name);\n    path\n}\n\n/// Read a fixture file as bytes\nfn read_fixture(name: \u0026str) -\u003e Vec\u003cu8\u003e {\n    std::fs::read(fixture_path(name)).expect(\u0026format!(\"Failed to read fixture: {}\", name))\n}\n\nmod pdf_header {\n    use super::*;\n\n    #[test]\n    fn test_minimal_pdf_header() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.\"));\n        assert!(data.len() \u003e 100); // Minimal PDF should be at least this size\n    }\n\n    #[test]\n    fn test_comprehensive_pdf_header() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.7\"));\n    }\n\n    #[test]\n    fn test_multipage_pdf_header() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.4\"));\n    }\n}\n\nmod pdf_structure {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    fn count_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e usize {\n        data.windows(pattern.len()).filter(|w| *w == pattern).count()\n    }\n\n    #[test]\n    fn test_minimal_has_catalog() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Catalog\"));\n    }\n\n    #[test]\n    fn test_minimal_has_pages() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Pages\"));\n    }\n\n    #[test]\n    fn test_minimal_has_one_page() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Page \"));\n        assert!(find_pattern(\u0026data, b\"/Count 1\"));\n    }\n\n    #[test]\n    fn test_minimal_has_font() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Font\"));\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Helvetica\"));\n    }\n\n    #[test]\n    fn test_minimal_has_content_stream() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Contents\"));\n        assert!(find_pattern(\u0026data, b\"stream\"));\n        assert!(find_pattern(\u0026data, b\"endstream\"));\n    }\n\n    #[test]\n    fn test_minimal_has_xref() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"xref\"));\n        assert!(find_pattern(\u0026data, b\"trailer\"));\n        assert!(find_pattern(\u0026data, b\"startxref\"));\n        assert!(find_pattern(\u0026data, b\"%%EOF\"));\n    }\n\n    #[test]\n    fn test_multipage_has_five_pages() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Count 5\"));\n\n        // Count individual page objects (use /Page followed by space to avoid matching /Pages)\n        let page_count = count_pattern(\u0026data, b\"/Type /Page \");\n        assert_eq!(page_count, 5, \"Expected 5 page objects\");\n    }\n\n    #[test]\n    fn test_comprehensive_has_three_pages() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Count 3\"));\n    }\n}\n\nmod pdf_content_types {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_comprehensive_has_outlines() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Outlines\"));\n        assert!(find_pattern(\u0026data, b\"/Title (Chapter 1\"));\n        assert!(find_pattern(\u0026data, b\"/Title (Chapter 2\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_metadata() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Metadata\"));\n        assert!(find_pattern(\u0026data, b\"\u003cx:xmpmeta\"));\n        assert!(find_pattern(\u0026data, b\"MicroPDF Comprehensive Test Document\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_annotations() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        // Link annotation\n        assert!(find_pattern(\u0026data, b\"/Subtype /Link\"));\n        // Text annotation (sticky note)\n        assert!(find_pattern(\u0026data, b\"/Subtype /Text\"));\n        // Highlight annotation\n        assert!(find_pattern(\u0026data, b\"/Subtype /Highlight\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_form_fields() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/AcroForm\"));\n        // Text field\n        assert!(find_pattern(\u0026data, b\"/FT /Tx\"));\n        // Button (checkbox)\n        assert!(find_pattern(\u0026data, b\"/FT /Btn\"));\n        // Choice (dropdown)\n        assert!(find_pattern(\u0026data, b\"/FT /Ch\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_image() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Subtype /Image\"));\n        assert!(find_pattern(\u0026data, b\"/ColorSpace /DeviceRGB\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_multiple_fonts() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Helvetica\"));\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Times-Roman\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_named_destinations() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Names\"));\n        assert!(find_pattern(\u0026data, b\"/Dests\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_graphics_state() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /ExtGState\"));\n        assert!(find_pattern(\u0026data, b\"/CA \"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_pattern() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Pattern\"));\n        assert!(find_pattern(\u0026data, b\"/PatternType 1\"));\n    }\n}\n\nmod pdf_text_content {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_minimal_has_hello_world() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"Hello, World!\"));\n    }\n\n    #[test]\n    fn test_multipage_has_page_numbers() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(find_pattern(\u0026data, b\"Page 1\"));\n        assert!(find_pattern(\u0026data, b\"Page 2\"));\n        assert!(find_pattern(\u0026data, b\"Page 3\"));\n        assert!(find_pattern(\u0026data, b\"Page 4\"));\n        assert!(find_pattern(\u0026data, b\"Page 5\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_feature_list() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"Multiple fonts\"));\n        assert!(find_pattern(\u0026data, b\"Images\"));\n        assert!(find_pattern(\u0026data, b\"Annotations\"));\n        assert!(find_pattern(\u0026data, b\"Bookmarks/Outlines\"));\n    }\n}\n\nmod pdf_encryption {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_encrypted_has_encrypt_dict() {\n        let data = read_fixture(\"encrypted_empty_password.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Encrypt\"));\n        assert!(find_pattern(\u0026data, b\"/Filter /Standard\"));\n    }\n\n    #[test]\n    fn test_encrypted_has_id() {\n        let data = read_fixture(\"encrypted_empty_password.pdf\");\n        assert!(find_pattern(\u0026data, b\"/ID\"));\n    }\n}\n\nmod pdf_geometry {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_all_pdfs_have_mediabox() {\n        for fixture in [\"minimal.pdf\", \"multipage.pdf\", \"comprehensive_test.pdf\"] {\n            let data = read_fixture(fixture);\n            assert!(find_pattern(\u0026data, b\"/MediaBox\"), \"Missing MediaBox in {}\", fixture);\n        }\n    }\n\n    #[test]\n    fn test_comprehensive_has_cropbox() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/CropBox\"));\n    }\n\n    #[test]\n    fn test_standard_page_size() {\n        // US Letter: 612 x 792 points\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"[0 0 612 792]\"));\n    }\n}\n\nmod ffi_integration {\n    use micropdf::ffi::geometry::*;\n    use micropdf::ffi::buffer::*;\n    use micropdf::ffi::context::*;\n\n    #[test]\n    fn test_ffi_context_lifecycle() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        assert_ne!(ctx, 0);\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_ffi_buffer_lifecycle() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let buf = fz_new_buffer(ctx, 1024);\n        assert_ne!(buf, 0);\n\n        fz_append_byte(ctx, buf, b'H' as i32);\n        fz_append_byte(ctx, buf, b'i' as i32);\n\n        assert_eq!(fz_buffer_len(ctx, buf), 2);\n\n        fz_drop_buffer(ctx, buf);\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_ffi_matrix_operations() {\n        // Test identity\n        let identity = fz_matrix::identity();\n        assert_eq!(identity.a, 1.0);\n        assert_eq!(identity.d, 1.0);\n\n        // Test translation\n        let translate = fz_translate(100.0, 200.0);\n        assert_eq!(translate.e, 100.0);\n        assert_eq!(translate.f, 200.0);\n\n        // Test scale\n        let scale = fz_scale(2.0, 3.0);\n        assert_eq!(scale.a, 2.0);\n        assert_eq!(scale.d, 3.0);\n\n        // Test point transformation\n        let point = fz_point { x: 10.0, y: 20.0 };\n        let transformed = fz_transform_point(point, translate);\n        assert_eq!(transformed.x, 110.0);\n        assert_eq!(transformed.y, 220.0);\n    }\n\n    #[test]\n    fn test_ffi_rect_operations() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let r2 = fz_rect { x0: 50.0, y0: 50.0, x1: 150.0, y1: 150.0 };\n\n        // Test intersection\n        let intersection = fz_intersect_rect(r1, r2);\n        assert_eq!(intersection.x0, 50.0);\n        assert_eq!(intersection.y0, 50.0);\n        assert_eq!(intersection.x1, 100.0);\n        assert_eq!(intersection.y1, 100.0);\n\n        // Test union\n        let union = fz_union_rect(r1, r2);\n        assert_eq!(union.x0, 0.0);\n        assert_eq!(union.y0, 0.0);\n        assert_eq!(union.x1, 150.0);\n        assert_eq!(union.y1, 150.0);\n\n        // Test contains\n        assert_eq!(fz_contains_rect(r1, fz_rect { x0: 10.0, y0: 10.0, x1: 50.0, y1: 50.0 }), 1);\n        assert_eq!(fz_contains_rect(r1, r2), 0);\n    }\n\n    #[test]\n    fn test_ffi_quad_operations() {\n        let rect = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let quad = fz_quad_from_rect(rect);\n\n        assert_eq!(quad.ul.x, 0.0);\n        assert_eq!(quad.ul.y, 0.0);\n        assert_eq!(quad.lr.x, 100.0);\n        assert_eq!(quad.lr.y, 100.0);\n\n        // Test quad back to rect\n        let back = fz_rect_from_quad(quad);\n        assert_eq!(back.x0, rect.x0);\n        assert_eq!(back.y0, rect.y0);\n        assert_eq!(back.x1, rect.x1);\n        assert_eq!(back.y1, rect.y1);\n    }\n}\n\nmod colorspace_integration {\n    use micropdf::ffi::colorspace::*;\n\n    #[test]\n    fn test_device_colorspaces() {\n        let gray = fz_device_gray(0);\n        let rgb = fz_device_rgb(0);\n        let cmyk = fz_device_cmyk(0);\n\n        assert_eq!(fz_colorspace_n(0, gray), 1);\n        assert_eq!(fz_colorspace_n(0, rgb), 3);\n        assert_eq!(fz_colorspace_n(0, cmyk), 4);\n\n        assert_eq!(fz_colorspace_is_gray(0, gray), 1);\n        assert_eq!(fz_colorspace_is_rgb(0, rgb), 1);\n        assert_eq!(fz_colorspace_is_cmyk(0, cmyk), 1);\n    }\n\n    #[test]\n    fn test_color_conversion() {\n        let gray = fz_device_gray(0);\n        let rgb = fz_device_rgb(0);\n\n        let src = [0.5f32];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(0, gray, src.as_ptr(), rgb, dst.as_mut_ptr(), 0);\n\n        // Gray to RGB should produce equal components\n        assert!((dst[0] - 0.5).abs() \u003c 0.01);\n        assert!((dst[1] - 0.5).abs() \u003c 0.01);\n        assert!((dst[2] - 0.5).abs() \u003c 0.01);\n    }\n}\n\nmod pixmap_integration {\n    use micropdf::ffi::pixmap::*;\n    use micropdf::ffi::colorspace::*;\n\n    #[test]\n    fn test_pixmap_creation_and_manipulation() {\n        let rgb = fz_device_rgb(0);\n        let pix = fz_new_pixmap(0, rgb, 100, 100, 0, 1);\n\n        assert_ne!(pix, 0);\n        assert_eq!(fz_pixmap_width(0, pix), 100);\n        assert_eq!(fz_pixmap_height(0, pix), 100);\n        assert_eq!(fz_pixmap_alpha(0, pix), 1);\n        assert_eq!(fz_pixmap_components(0, pix), 4); // RGB + alpha\n\n        // Test clear\n        fz_clear_pixmap_with_value(0, pix, 128);\n        assert_eq!(fz_get_pixmap_sample(0, pix, 0, 0, 0), 128);\n\n        // Test set/get\n        fz_set_pixmap_sample(0, pix, 50, 50, 0, 255);\n        assert_eq!(fz_get_pixmap_sample(0, pix, 50, 50, 0), 255);\n\n        fz_drop_pixmap(0, pix);\n    }\n\n    #[test]\n    fn test_pixmap_bbox() {\n        use micropdf::ffi::geometry::fz_irect;\n\n        let rgb = fz_device_rgb(0);\n        let bbox = fz_irect { x0: 10, y0: 20, x1: 110, y1: 120 };\n        let pix = fz_new_pixmap_with_bbox(0, rgb, bbox, 0, 0);\n\n        assert_eq!(fz_pixmap_x(0, pix), 10);\n        assert_eq!(fz_pixmap_y(0, pix), 20);\n        assert_eq!(fz_pixmap_width(0, pix), 100);\n        assert_eq!(fz_pixmap_height(0, pix), 100);\n\n        fz_drop_pixmap(0, pix);\n    }\n}\n\nmod stream_integration {\n    use micropdf::ffi::stream::*;\n    use micropdf::ffi::context::*;\n\n    #[test]\n    fn test_stream_from_memory() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let data = b\"Hello, Stream!\";\n        let stm = fz_open_memory(ctx, data.as_ptr(), data.len());\n\n        assert_ne!(stm, 0);\n\n        // Read byte by byte\n        assert_eq!(fz_read_byte(ctx, stm), b'H' as i32);\n        assert_eq!(fz_read_byte(ctx, stm), b'e' as i32);\n        assert_eq!(fz_read_byte(ctx, stm), b'l' as i32);\n\n        // Check position\n        assert_eq!(fz_tell(ctx, stm), 3);\n\n        // Seek to beginning\n        fz_seek(ctx, stm, 0, 0);\n        assert_eq!(fz_tell(ctx, stm), 0);\n        assert_eq!(fz_read_byte(ctx, stm), b'H' as i32);\n\n        // Check EOF\n        fz_seek(ctx, stm, 0, 2); // SEEK_END\n        assert_eq!(fz_is_eof(ctx, stm), 1);\n\n        fz_drop_stream(ctx, stm);\n        fz_drop_context(ctx);\n    }\n}\n\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","buffer.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse micropdf::fitz::buffer::Buffer;\n\nfn bench_buffer_creation(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/create\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, \u0026size| {\n            b.iter(|| Buffer::new(black_box(size)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_from_data(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/from_slice\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026data, |b, data| {\n            b.iter(|| Buffer::from_slice(black_box(data)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_append(c: \u0026mut Criterion) {\n    let chunk: Vec\u003cu8\u003e = (0..256).map(|i| i as u8).collect();\n\n    let mut group = c.benchmark_group(\"buffer/append\");\n\n    for iterations in [10, 100, 1000].iter() {\n        group.throughput(Throughput::Bytes((256 * iterations) as u64));\n        group.bench_with_input(\n            BenchmarkId::from_parameter(iterations),\n            iterations,\n            |b, \u0026iterations| {\n                b.iter(|| {\n                    let mut buf = Buffer::new(0);\n                    for _ in 0..iterations {\n                        buf.append_data(black_box(\u0026chunk));\n                    }\n                    buf\n                })\n            },\n        );\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_base64(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/base64\");\n\n    for size in [64, 256, 1024, 4096].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::new(\"encode\", size), \u0026buf, |b, buf| {\n            b.iter(|| buf.to_base64())\n        });\n    }\n\n    // Decode benchmarks\n    for size in [64, 256, 1024, 4096].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n        let encoded = buf.to_base64();\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::new(\"decode\", size), \u0026encoded, |b, encoded| {\n            b.iter(|| Buffer::from_base64(black_box(encoded)))\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_md5(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/md5\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026buf, |b, buf| {\n            b.iter(|| buf.md5_digest())\n        });\n    }\n\n    group.finish();\n}\n\nfn bench_buffer_to_vec(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"buffer/to_vec\");\n\n    for size in [64, 256, 1024, 4096, 16384].iter() {\n        let data: Vec\u003cu8\u003e = (0..*size).map(|i| i as u8).collect();\n        let buf = Buffer::from_slice(\u0026data);\n\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026buf, |b, buf| {\n            b.iter(|| buf.to_vec())\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_buffer_creation,\n    bench_buffer_from_data,\n    bench_buffer_append,\n    bench_buffer_base64,\n    bench_buffer_md5,\n    bench_buffer_to_vec,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","geometry.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse micropdf::fitz::geometry::{Matrix, Point, Quad, Rect};\n\nfn bench_point_transform(c: \u0026mut Criterion) {\n    let point = Point::new(100.0, 200.0);\n    let matrix = Matrix::rotate(45.0);\n\n    c.bench_function(\"point/transform\", |b| {\n        b.iter(|| black_box(point).transform(black_box(\u0026matrix)))\n    });\n}\n\nfn bench_point_operations(c: \u0026mut Criterion) {\n    let p1 = Point::new(100.0, 200.0);\n    let p2 = Point::new(50.0, 75.0);\n\n    let mut group = c.benchmark_group(\"point\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Point::new(black_box(100.0), black_box(200.0)))\n    });\n\n    group.finish();\n}\n\nfn bench_matrix_operations(c: \u0026mut Criterion) {\n    let m1 = Matrix::translate(100.0, 200.0);\n    let m2 = Matrix::scale(2.0, 2.0);\n    let m3 = Matrix::rotate(45.0);\n\n    let mut group = c.benchmark_group(\"matrix\");\n\n    group.bench_function(\"translate\", |b| {\n        b.iter(|| Matrix::translate(black_box(100.0), black_box(200.0)))\n    });\n\n    group.bench_function(\"scale\", |b| {\n        b.iter(|| Matrix::scale(black_box(2.0), black_box(2.0)))\n    });\n\n    group.bench_function(\"rotate\", |b| {\n        b.iter(|| Matrix::rotate(black_box(45.0)))\n    });\n\n    group.bench_function(\"concat\", |b| {\n        b.iter(|| black_box(\u0026m1).concat(black_box(\u0026m2)))\n    });\n\n    group.bench_function(\"chain_3\", |b| {\n        b.iter(|| {\n            black_box(\u0026m1)\n                .concat(black_box(\u0026m2))\n                .concat(black_box(\u0026m3))\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_rect_operations(c: \u0026mut Criterion) {\n    let r1 = Rect::new(0.0, 0.0, 100.0, 100.0);\n    let r2 = Rect::new(50.0, 50.0, 150.0, 150.0);\n    let point = Point::new(75.0, 75.0);\n\n    let mut group = c.benchmark_group(\"rect\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Rect::new(black_box(0.0), black_box(0.0), black_box(100.0), black_box(100.0)))\n    });\n\n    group.bench_function(\"union\", |b| {\n        b.iter(|| black_box(\u0026r1).union(black_box(\u0026r2)))\n    });\n\n    group.bench_function(\"intersect\", |b| {\n        b.iter(|| black_box(\u0026r1).intersect(black_box(\u0026r2)))\n    });\n\n    group.bench_function(\"contains\", |b| {\n        b.iter(|| black_box(\u0026r1).contains(black_box(75.0), black_box(75.0)))\n    });\n\n    group.bench_function(\"width_height\", |b| {\n        b.iter(|| (black_box(\u0026r1).width(), black_box(\u0026r1).height()))\n    });\n\n    group.bench_function(\"is_empty\", |b| {\n        b.iter(|| black_box(\u0026r1).is_empty())\n    });\n\n    group.finish();\n}\n\nfn bench_quad_operations(c: \u0026mut Criterion) {\n    let rect = Rect::new(0.0, 0.0, 100.0, 100.0);\n    let quad = Quad::from_rect(\u0026rect);\n    let matrix = Matrix::rotate(45.0);\n\n    let mut group = c.benchmark_group(\"quad\");\n\n    group.bench_function(\"from_rect\", |b| {\n        b.iter(|| Quad::from_rect(black_box(\u0026rect)))\n    });\n\n    group.bench_function(\"transform\", |b| {\n        b.iter(|| black_box(\u0026quad).transform(black_box(\u0026matrix)))\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_point_transform,\n    bench_point_operations,\n    bench_matrix_operations,\n    bench_rect_operations,\n    bench_quad_operations,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","benches","pdf_objects.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse micropdf::pdf::object::{Name, Object, ObjRef, PdfString};\nuse std::collections::HashMap;\n\nfn bench_object_creation(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"pdf/object/create\");\n\n    group.bench_function(\"null\", |b| {\n        b.iter(|| Object::Null)\n    });\n\n    group.bench_function(\"bool\", |b| {\n        b.iter(|| Object::Bool(black_box(true)))\n    });\n\n    group.bench_function(\"int\", |b| {\n        b.iter(|| Object::Int(black_box(42)))\n    });\n\n    group.bench_function(\"real\", |b| {\n        b.iter(|| Object::Real(black_box(3.14159)))\n    });\n\n    group.bench_function(\"name\", |b| {\n        b.iter(|| Object::Name(Name::new(black_box(\"Type\"))))\n    });\n\n    group.bench_function(\"string\", |b| {\n        b.iter(|| Object::String(PdfString::new(black_box(b\"Hello, World!\".to_vec()))))\n    });\n\n    group.bench_function(\"ref\", |b| {\n        b.iter(|| Object::Ref(ObjRef::new(black_box(1), black_box(0))))\n    });\n\n    group.finish();\n}\n\nfn bench_name_operations(c: \u0026mut Criterion) {\n    let name1 = Name::new(\"Type\");\n    let name2 = Name::new(\"Type\");\n    let name3 = Name::new(\"Subtype\");\n\n    let mut group = c.benchmark_group(\"pdf/name\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| Name::new(black_box(\"FontDescriptor\")))\n    });\n\n    group.bench_function(\"eq_same\", |b| {\n        b.iter(|| black_box(\u0026name1) == black_box(\u0026name2))\n    });\n\n    group.bench_function(\"eq_diff\", |b| {\n        b.iter(|| black_box(\u0026name1) == black_box(\u0026name3))\n    });\n\n    group.bench_function(\"to_string\", |b| {\n        b.iter(|| black_box(\u0026name1).to_string())\n    });\n\n    group.finish();\n}\n\nfn bench_string_operations(c: \u0026mut Criterion) {\n    let literal = PdfString::new(b\"Hello, World!\".to_vec());\n\n    let mut group = c.benchmark_group(\"pdf/string\");\n\n    group.bench_function(\"new\", |b| {\n        b.iter(|| PdfString::new(black_box(b\"Test string content\".to_vec())))\n    });\n\n    group.bench_function(\"as_bytes\", |b| {\n        b.iter(|| black_box(\u0026literal).as_bytes())\n    });\n\n    group.finish();\n}\n\nfn bench_array_operations(c: \u0026mut Criterion) {\n    let small_array: Vec\u003cObject\u003e = (0..10).map(|i| Object::Int(i)).collect();\n    let large_array: Vec\u003cObject\u003e = (0..1000).map(|i| Object::Int(i)).collect();\n\n    let mut group = c.benchmark_group(\"pdf/array\");\n\n    group.bench_function(\"create_10\", |b| {\n        b.iter(|| {\n            Object::Array(\n                (0..10)\n                    .map(|i| Object::Int(black_box(i)))\n                    .collect()\n            )\n        })\n    });\n\n    group.bench_function(\"create_1000\", |b| {\n        b.iter(|| {\n            Object::Array(\n                (0..1000)\n                    .map(|i| Object::Int(black_box(i)))\n                    .collect()\n            )\n        })\n    });\n\n    group.bench_function(\"access_10\", |b| {\n        let arr = Object::Array(small_array.clone());\n        b.iter(|| {\n            if let Object::Array(ref a) = arr {\n                black_box(\u0026a[5])\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.bench_function(\"access_1000\", |b| {\n        let arr = Object::Array(large_array.clone());\n        b.iter(|| {\n            if let Object::Array(ref a) = arr {\n                black_box(\u0026a[500])\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_dict_operations(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"pdf/dict\");\n\n    // Small dictionary (typical PDF object)\n    let mut small_dict: HashMap\u003cName, Object\u003e = HashMap::new();\n    small_dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n    small_dict.insert(Name::new(\"Parent\"), Object::Ref(ObjRef::new(1, 0)));\n    small_dict.insert(Name::new(\"MediaBox\"), Object::Array(vec![\n        Object::Int(0), Object::Int(0), Object::Int(612), Object::Int(792)\n    ]));\n\n    group.bench_function(\"create_small\", |b| {\n        b.iter(|| {\n            let mut dict: HashMap\u003cName, Object\u003e = HashMap::new();\n            dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n            dict.insert(Name::new(\"Parent\"), Object::Ref(ObjRef::new(1, 0)));\n            Object::Dict(dict)\n        })\n    });\n\n    group.bench_function(\"lookup\", |b| {\n        let dict = Object::Dict(small_dict.clone());\n        let key = Name::new(\"Type\");\n        b.iter(|| {\n            if let Object::Dict(ref d) = dict {\n                black_box(d.get(black_box(\u0026key)))\n            } else {\n                panic!()\n            }\n        })\n    });\n\n    group.bench_function(\"insert\", |b| {\n        b.iter_batched(\n            || HashMap::new(),\n            |mut dict: HashMap\u003cName, Object\u003e| {\n                dict.insert(\n                    Name::new(black_box(\"NewKey\")),\n                    Object::Int(black_box(42))\n                );\n                dict\n            },\n            criterion::BatchSize::SmallInput\n        )\n    });\n\n    group.finish();\n}\n\nfn bench_object_type_checks(c: \u0026mut Criterion) {\n    let objects = vec![\n        Object::Null,\n        Object::Bool(true),\n        Object::Int(42),\n        Object::Real(3.14),\n        Object::Name(Name::new(\"Test\")),\n        Object::String(PdfString::new(b\"Hello\".to_vec())),\n        Object::Array(vec![Object::Int(1), Object::Int(2)]),\n        Object::Dict(HashMap::new()),\n        Object::Ref(ObjRef::new(1, 0)),\n    ];\n\n    let mut group = c.benchmark_group(\"pdf/object/type_check\");\n\n    group.bench_function(\"is_null\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.is_null());\n            }\n        })\n    });\n\n    group.bench_function(\"as_int\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.as_int());\n            }\n        })\n    });\n\n    group.bench_function(\"as_dict\", |b| {\n        b.iter(|| {\n            for obj in \u0026objects {\n                black_box(obj.as_dict());\n            }\n        })\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_object_creation,\n    bench_name_operations,\n    bench_string_operations,\n    bench_array_operations,\n    bench_dict_operations,\n    bench_object_type_checks,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","buffer.rs"],"content":"//! C FFI for buffer - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, BUFFERS};\nuse std::ffi::{c_char, c_int, c_void};\n\n/// Internal buffer state\npub struct Buffer {\n    data: Vec\u003cu8\u003e,\n}\n\nimpl Buffer {\n    pub fn new(capacity: usize) -\u003e Self {\n        Self {\n            data: Vec::with_capacity(capacity),\n        }\n    }\n\n    pub fn from_data(data: \u0026[u8]) -\u003e Self {\n        Self {\n            data: data.to_vec(),\n        }\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.data.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.data.is_empty()\n    }\n\n    pub fn data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.data\n    }\n\n    pub fn data_mut(\u0026mut self) -\u003e \u0026mut Vec\u003cu8\u003e {\n        \u0026mut self.data\n    }\n\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\n        self.data.extend_from_slice(data);\n    }\n\n    pub fn append_byte(\u0026mut self, byte: u8) {\n        self.data.push(byte);\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.data.clear();\n    }\n\n    pub fn resize(\u0026mut self, new_size: usize) {\n        self.data.resize(new_size, 0);\n    }\n\n    pub fn ensure_null_terminated(\u0026mut self) {\n        if self.data.is_empty() || self.data.last() != Some(\u00260) {\n            self.data.push(0);\n        }\n    }\n}\n\n/// Create a new buffer with given capacity\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_buffer(_ctx: Handle, capacity: usize) -\u003e Handle {\n    BUFFERS.insert(Buffer::new(capacity))\n}\n\n/// Create a buffer from copied data\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `size` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_buffer_from_copied_data(\n    _ctx: Handle,\n    data: *const u8,\n    size: usize,\n) -\u003e Handle {\n    if data.is_null() || size == 0 {\n        return BUFFERS.insert(Buffer::new(0));\n    }\n\n    // SAFETY: Caller guarantees data points to valid memory of `size` bytes\n    #[allow(unsafe_code)]\n    let data_slice = unsafe { std::slice::from_raw_parts(data, size) };\n\n    BUFFERS.insert(Buffer::from_data(data_slice))\n}\n\n/// Keep (increment ref) a buffer - returns same handle\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    BUFFERS.keep(buf)\n}\n\n/// Drop a buffer reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_buffer(_ctx: Handle, buf: Handle) {\n    let _ = BUFFERS.remove(buf);\n}\n\n/// Get buffer storage - returns length, optionally fills data pointer\n///\n/// Note: This function cannot safely return a pointer to internal data\n/// because the buffer may be moved or reallocated. For safe access,\n/// use fz_buffer_len and copy the data.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_buffer_storage(\n    _ctx: Handle,\n    buf: Handle,\n    datap: *mut *mut u8,\n) -\u003e usize {\n    let Some(buffer) = BUFFERS.get(buf) else {\n        if !datap.is_null() {\n            // SAFETY: Caller guarantees datap is valid if non-null\n            #[allow(unsafe_code)]\n            unsafe { *datap = std::ptr::null_mut(); }\n        }\n        return 0;\n    };\n\n    let guard = buffer.lock().unwrap();\n    let len = guard.len();\n\n    if !datap.is_null() {\n        // We can't safely return a pointer to internal data\n        // because the buffer may be reallocated\n        #[allow(unsafe_code)]\n        unsafe { *datap = std::ptr::null_mut(); }\n    }\n\n    len\n}\n\n/// Get buffer as null-terminated C string\n///\n/// Note: This function cannot safely return a pointer to internal buffer data\n/// because the data may be moved or reallocated. Returns empty string for now.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_string_from_buffer(_ctx: Handle, _buf: Handle) -\u003e *const c_char {\n    // Can't return internal pointer safely without stable address\n    // Return empty string for now\n    c\"\".as_ptr()\n}\n\n/// Resize buffer to new capacity\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_resize_buffer(_ctx: Handle, buf: Handle, capacity: usize) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.resize(capacity);\n        }\n    }\n}\n\n/// Grow buffer (double capacity or minimum 256)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_grow_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            let current_cap = guard.data.capacity();\n            let new_cap = (current_cap * 2).max(256);\n            guard.data.reserve(new_cap.saturating_sub(current_cap));\n        }\n    }\n}\n\n/// Trim buffer to fit contents\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_trim_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.data.shrink_to_fit();\n        }\n    }\n}\n\n/// Clear buffer contents\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.clear();\n        }\n    }\n}\n\n/// Append data to buffer\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_data(\n    _ctx: Handle,\n    buf: Handle,\n    data: *const c_void,\n    len: usize,\n) {\n    if data.is_null() || len == 0 {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            // SAFETY: Caller guarantees data points to valid memory of `len` bytes\n            #[allow(unsafe_code)]\n            let slice = unsafe { std::slice::from_raw_parts(data as *const u8, len) };\n            guard.append(slice);\n        }\n    }\n}\n\n/// Append C string to buffer\n///\n/// # Safety\n/// Caller must ensure `data` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_string(_ctx: Handle, buf: Handle, data: *const c_char) {\n    if data.is_null() {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            // SAFETY: Caller guarantees data is a valid null-terminated C string\n            #[allow(unsafe_code)]\n            let c_str = unsafe { std::ffi::CStr::from_ptr(data) };\n            guard.append(c_str.to_bytes());\n        }\n    }\n}\n\n/// Append single byte to buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_append_byte(_ctx: Handle, buf: Handle, c: c_int) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.append_byte(c as u8);\n        }\n    }\n}\n\n/// Null-terminate buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_terminate_buffer(_ctx: Handle, buf: Handle) {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(mut guard) = buffer.lock() {\n            guard.ensure_null_terminated();\n        }\n    }\n}\n\n/// Compute MD5 digest of buffer contents\n///\n/// # Safety\n/// Caller must ensure `digest` points to valid writable memory of 16 bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_md5_buffer(\n    _ctx: Handle,\n    buf: Handle,\n    digest: *mut [u8; 16],\n) {\n    if digest.is_null() {\n        return;\n    }\n\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            use md5::{Digest, Md5};\n            let mut hasher = Md5::new();\n            hasher.update(guard.data());\n            let result = hasher.finalize();\n\n            // SAFETY: Caller guarantees digest points to valid writable [u8; 16]\n            #[allow(unsafe_code)]\n            unsafe {\n                (*digest).copy_from_slice(\u0026result);\n            }\n        }\n    }\n}\n\n/// Clone a buffer\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clone_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return BUFFERS.insert(Buffer::from_data(guard.data()));\n        }\n    }\n    0\n}\n\n/// Get buffer length\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_buffer_len(_ctx: Handle, buf: Handle) -\u003e usize {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return guard.len();\n        }\n    }\n    0\n}\n\n// Note: Some functions that return raw pointers to internal data\n// cannot be implemented safely. They would require:\n// 1. A stable buffer address (Box::leak or similar)\n// 2. Unsafe blocks to convert to raw pointers\n//\n// For a fully safe API, consider returning handles or using\n// callback-based APIs instead.\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_buffer_create_and_drop() {\n        let handle = fz_new_buffer(0, 100);\n        assert_ne!(handle, 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_append_byte() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_append_byte(0, handle, b'B' as i32);\n\n        let len = fz_buffer_len(0, handle);\n        assert_eq!(len, 2);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_clear() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'X' as i32);\n        assert_eq!(fz_buffer_len(0, handle), 1);\n\n        fz_clear_buffer(0, handle);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_keep() {\n        let handle = fz_new_buffer(0, 0);\n        let kept = fz_keep_buffer(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_resize() {\n        let handle = fz_new_buffer(0, 10);\n        fz_resize_buffer(0, handle, 100);\n        // Resize should succeed\n        assert_eq!(fz_buffer_len(0, handle), 100);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_grow() {\n        let handle = fz_new_buffer(0, 10);\n        fz_grow_buffer(0, handle);\n        // Buffer should be able to accommodate growth\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_trim() {\n        let handle = fz_new_buffer(0, 100);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_trim_buffer(0, handle);\n        assert_eq!(fz_buffer_len(0, handle), 1);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_clone() {\n        let handle1 = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle1, b'X' as i32);\n        fz_append_byte(0, handle1, b'Y' as i32);\n\n        let handle2 = fz_clone_buffer(0, handle1);\n        assert_ne!(handle2, 0);\n        assert_eq!(fz_buffer_len(0, handle2), 2);\n\n        // Modify original, clone should be unchanged\n        fz_clear_buffer(0, handle1);\n        assert_eq!(fz_buffer_len(0, handle1), 0);\n        assert_eq!(fz_buffer_len(0, handle2), 2);\n\n        fz_drop_buffer(0, handle1);\n        fz_drop_buffer(0, handle2);\n    }\n\n    #[test]\n    fn test_buffer_len_invalid() {\n        let len = fz_buffer_len(0, 0);\n        assert_eq!(len, 0);\n    }\n\n    #[test]\n    fn test_buffer_append_multiple() {\n        let handle = fz_new_buffer(0, 0);\n        for i in 0..100 {\n            fz_append_byte(0, handle, i as i32);\n        }\n        assert_eq!(fz_buffer_len(0, handle), 100);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_append_byte(0, handle, b'i' as i32);\n\n        let mut datap: *mut u8 = std::ptr::null_mut();\n        let size = fz_buffer_storage(0, handle, \u0026mut datap);\n\n        // Size should be the length of the buffer\n        assert_eq!(size, 2);\n        // datap will be null because we can't safely return internal pointer\n        assert!(datap.is_null());\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_internal() {\n        let buf = Buffer::new(10);\n        assert_eq!(buf.len(), 0);\n        assert!(buf.data().is_empty());\n    }\n\n    #[test]\n    fn test_buffer_from_data() {\n        let data = [1u8, 2, 3, 4, 5];\n        let buf = Buffer::from_data(\u0026data);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.data(), \u0026data);\n    }\n\n    #[test]\n    fn test_buffer_append_internal() {\n        let mut buf = Buffer::new(0);\n        buf.append_byte(0x42);\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.data(), \u0026[0x42]);\n    }\n\n    #[test]\n    fn test_buffer_clear_internal() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.clear();\n        assert_eq!(buf.len(), 0);\n    }\n\n    // ============================================================================\n    // Additional tests for better coverage\n    // ============================================================================\n\n    #[test]\n    fn test_buffer_from_copied_data() {\n        let data = [1u8, 2, 3, 4, 5];\n        let handle = fz_new_buffer_from_copied_data(0, data.as_ptr(), data.len());\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_from_copied_data_null() {\n        let handle = fz_new_buffer_from_copied_data(0, std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_from_copied_data_null_with_size() {\n        // Even with non-zero size, null ptr should return empty buffer\n        let handle = fz_new_buffer_from_copied_data(0, std::ptr::null(), 100);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage_null_datap() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n\n        // Pass null pointer for datap\n        let size = fz_buffer_storage(0, handle, std::ptr::null_mut());\n        assert_eq!(size, 1);\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_storage_invalid_handle() {\n        let mut datap: *mut u8 = std::ptr::null_mut();\n        let size = fz_buffer_storage(0, 99999, \u0026mut datap);\n        assert_eq!(size, 0);\n        assert!(datap.is_null());\n    }\n\n    #[test]\n    fn test_fz_string_from_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n\n        let ptr = fz_string_from_buffer(0, handle);\n        assert!(!ptr.is_null());\n\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_buffer_resize_invalid_handle() {\n        // Should not panic\n        fz_resize_buffer(0, 99999, 100);\n    }\n\n    #[test]\n    fn test_buffer_grow_invalid_handle() {\n        // Should not panic\n        fz_grow_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_buffer_trim_invalid_handle() {\n        // Should not panic\n        fz_trim_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_buffer_clear_invalid_handle() {\n        // Should not panic\n        fz_clear_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_fz_append_data() {\n        let handle = fz_new_buffer(0, 0);\n        let data = [1u8, 2, 3, 4, 5];\n        fz_append_data(0, handle, data.as_ptr() as *const c_void, data.len());\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_data_null() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_data(0, handle, std::ptr::null(), 0);\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_data_invalid_handle() {\n        let data = [1u8, 2, 3];\n        // Should not panic\n        fz_append_data(0, 99999, data.as_ptr() as *const c_void, data.len());\n    }\n\n    #[test]\n    fn test_fz_append_string() {\n        let handle = fz_new_buffer(0, 0);\n        let s = std::ffi::CString::new(\"Hello\").unwrap();\n        fz_append_string(0, handle, s.as_ptr());\n        assert_eq!(fz_buffer_len(0, handle), 5);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_string_null() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_string(0, handle, std::ptr::null());\n        assert_eq!(fz_buffer_len(0, handle), 0);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_append_string_invalid_handle() {\n        let s = std::ffi::CString::new(\"Hello\").unwrap();\n        // Should not panic\n        fz_append_string(0, 99999, s.as_ptr());\n    }\n\n    #[test]\n    fn test_fz_append_byte_invalid_handle() {\n        // Should not panic\n        fz_append_byte(0, 99999, b'X' as i32);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_terminate_buffer(0, handle);\n        // After termination, buffer should have a null byte\n        assert_eq!(fz_buffer_len(0, handle), 2);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer_invalid_handle() {\n        // Should not panic\n        fz_terminate_buffer(0, 99999);\n    }\n\n    #[test]\n    fn test_fz_terminate_buffer_already_terminated() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'H' as i32);\n        fz_append_byte(0, handle, 0); // Already has null\n        fz_terminate_buffer(0, handle);\n        // Should not add another null\n        assert_eq!(fz_buffer_len(0, handle), 2);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        fz_append_byte(0, handle, b'B' as i32);\n        fz_append_byte(0, handle, b'C' as i32);\n\n        let mut digest = [0u8; 16];\n        fz_md5_buffer(0, handle, \u0026mut digest);\n\n        // MD5(\"ABC\") is known\n        assert_ne!(digest, [0u8; 16]);\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer_null_digest() {\n        let handle = fz_new_buffer(0, 0);\n        fz_append_byte(0, handle, b'A' as i32);\n        // Should not panic\n        fz_md5_buffer(0, handle, std::ptr::null_mut());\n        fz_drop_buffer(0, handle);\n    }\n\n    #[test]\n    fn test_fz_md5_buffer_invalid_handle() {\n        let mut digest = [0u8; 16];\n        // Should not panic\n        fz_md5_buffer(0, 99999, \u0026mut digest);\n    }\n\n    #[test]\n    fn test_fz_clone_buffer_invalid_handle() {\n        let handle = fz_clone_buffer(0, 99999);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_buffer_is_empty() {\n        let buf = Buffer::new(10);\n        assert!(buf.is_empty());\n\n        let buf2 = Buffer::from_data(\u0026[1, 2, 3]);\n        assert!(!buf2.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_data_mut() {\n        let mut buf = Buffer::new(0);\n        buf.data_mut().push(1);\n        buf.data_mut().push(2);\n        assert_eq!(buf.len(), 2);\n    }\n\n    #[test]\n    fn test_buffer_append() {\n        let mut buf = Buffer::new(0);\n        buf.append(\u0026[1, 2, 3]);\n        assert_eq!(buf.len(), 3);\n        buf.append(\u0026[4, 5]);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(buf.data(), \u0026[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_resize_internal() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.resize(5);\n        assert_eq!(buf.len(), 5);\n        assert_eq!(\u0026buf.data()[..3], \u0026[1, 2, 3]);\n        assert_eq!(\u0026buf.data()[3..], \u0026[0, 0]);\n    }\n\n    #[test]\n    fn test_buffer_ensure_null_terminated() {\n        let mut buf = Buffer::from_data(\u0026[1, 2, 3]);\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 4);\n        assert_eq!(buf.data().last(), Some(\u00260));\n\n        // Should not add another null\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 4);\n    }\n\n    #[test]\n    fn test_buffer_ensure_null_terminated_empty() {\n        let mut buf = Buffer::new(0);\n        buf.ensure_null_terminated();\n        assert_eq!(buf.len(), 1);\n        assert_eq!(buf.data(), \u0026[0]);\n    }\n}\n","traces":[{"line":13,"address":[1883808],"length":1,"stats":{"Line":7}},{"line":15,"address":[1458595],"length":1,"stats":{"Line":7}},{"line":19,"address":[1458656],"length":1,"stats":{"Line":4}},{"line":21,"address":[1458679],"length":1,"stats":{"Line":4}},{"line":25,"address":[1458736],"length":1,"stats":{"Line":3}},{"line":26,"address":[1458741],"length":1,"stats":{"Line":4}},{"line":29,"address":[1458752],"length":1,"stats":{"Line":1}},{"line":30,"address":[1458757],"length":1,"stats":{"Line":1}},{"line":33,"address":[1884000],"length":1,"stats":{"Line":5}},{"line":34,"address":[1458773],"length":1,"stats":{"Line":1}},{"line":37,"address":[1458784],"length":1,"stats":{"Line":1}},{"line":41,"address":[1458800],"length":1,"stats":{"Line":1}},{"line":42,"address":[1458818],"length":1,"stats":{"Line":1}},{"line":45,"address":[1458848],"length":1,"stats":{"Line":2}},{"line":46,"address":[1884096],"length":1,"stats":{"Line":2}},{"line":49,"address":[1458896],"length":1,"stats":{"Line":1}},{"line":50,"address":[1458901],"length":1,"stats":{"Line":1}},{"line":53,"address":[1458912],"length":1,"stats":{"Line":1}},{"line":54,"address":[1884158],"length":1,"stats":{"Line":1}},{"line":57,"address":[1458960],"length":1,"stats":{"Line":2}},{"line":58,"address":[1458973],"length":1,"stats":{"Line":2}},{"line":59,"address":[1459038],"length":1,"stats":{"Line":2}},{"line":66,"address":[1459114,1459167,1459072],"length":1,"stats":{"Line":13}},{"line":67,"address":[1459125,1459091],"length":1,"stats":{"Line":26}},{"line":75,"address":[1459269,1459200,1459476],"length":1,"stats":{"Line":3}},{"line":80,"address":[1459254,1459279],"length":1,"stats":{"Line":6}},{"line":81,"address":[1884528,1884752],"length":1,"stats":{"Line":4}},{"line":86,"address":[1459332],"length":1,"stats":{"Line":1}},{"line":88,"address":[1459395,1459509],"length":1,"stats":{"Line":2}},{"line":93,"address":[1459600,1459642],"length":1,"stats":{"Line":1}},{"line":94,"address":[1459619,1459658],"length":1,"stats":{"Line":2}},{"line":99,"address":[1459696,1459738,1459796],"length":1,"stats":{"Line":6}},{"line":100,"address":[1459754,1459715],"length":1,"stats":{"Line":13}},{"line":109,"address":[1459888,1460456,1460415,1460482,1459824],"length":1,"stats":{"Line":1}},{"line":114,"address":[1459865,1459904],"length":1,"stats":{"Line":2}},{"line":115,"address":[1460467,1460492,1460596],"length":1,"stats":{"Line":3}},{"line":118,"address":[1460529,1460498,1460598],"length":1,"stats":{"Line":2}},{"line":120,"address":[1460513],"length":1,"stats":{"Line":1}},{"line":123,"address":[1460054,1459968],"length":1,"stats":{"Line":3}},{"line":124,"address":[1460134,1460207],"length":1,"stats":{"Line":4}},{"line":126,"address":[1460384,1460241],"length":1,"stats":{"Line":3}},{"line":130,"address":[1460316,1460266,1460386],"length":1,"stats":{"Line":2}},{"line":133,"address":[1460287],"length":1,"stats":{"Line":1}},{"line":141,"address":[1460661,1460624],"length":1,"stats":{"Line":1}},{"line":144,"address":[1460638],"length":1,"stats":{"Line":1}},{"line":149,"address":[1460688,1460746,1461176,1461151],"length":1,"stats":{"Line":1}},{"line":150,"address":[1885878,1885843],"length":1,"stats":{"Line":2}},{"line":151,"address":[1460958,1460826,1460912],"length":1,"stats":{"Line":3}},{"line":152,"address":[1460976,1461045],"length":1,"stats":{"Line":2}},{"line":159,"address":[1461216,1461267,1461837,1461862],"length":1,"stats":{"Line":1}},{"line":160,"address":[1461283,1461244],"length":1,"stats":{"Line":2}},{"line":161,"address":[1461479,1461347,1461433],"length":1,"stats":{"Line":3}},{"line":162,"address":[1461567,1461500],"length":1,"stats":{"Line":2}},{"line":163,"address":[1461596],"length":1,"stats":{"Line":1}},{"line":164,"address":[1886714],"length":1,"stats":{"Line":1}},{"line":171,"address":[1461949,1461904,1462372,1462347],"length":1,"stats":{"Line":1}},{"line":172,"address":[1461965,1461926],"length":1,"stats":{"Line":2}},{"line":173,"address":[1462158,1462029,1462112],"length":1,"stats":{"Line":3}},{"line":174,"address":[1887177,1887225],"length":1,"stats":{"Line":2}},{"line":181,"address":[1462416,1462877,1462852,1462461],"length":1,"stats":{"Line":1}},{"line":182,"address":[1887414,1887449],"length":1,"stats":{"Line":2}},{"line":183,"address":[1462624,1462541,1462670],"length":1,"stats":{"Line":3}},{"line":184,"address":[1462749,1462688],"length":1,"stats":{"Line":2}},{"line":194,"address":[1462994,1463602,1463574,1462912],"length":1,"stats":{"Line":1}},{"line":200,"address":[1887928,1887907],"length":1,"stats":{"Line":2}},{"line":204,"address":[1463029],"length":1,"stats":{"Line":1}},{"line":205,"address":[1463212,1463277,1463126],"length":1,"stats":{"Line":3}},{"line":208,"address":[1888200,1888268],"length":1,"stats":{"Line":2}},{"line":209,"address":[1463414],"length":1,"stats":{"Line":1}},{"line":219,"address":[1463632,1464297,1463701,1464325],"length":1,"stats":{"Line":3}},{"line":220,"address":[1888550,1888571],"length":1,"stats":{"Line":6}},{"line":224,"address":[1888614,1888577],"length":1,"stats":{"Line":4}},{"line":225,"address":[1888806,1888685,1888762],"length":1,"stats":{"Line":3}},{"line":228,"address":[1464004,1464075],"length":1,"stats":{"Line":2}},{"line":229,"address":[1888943],"length":1,"stats":{"Line":1}},{"line":236,"address":[1889597,1889220,1889168,1889576],"length":1,"stats":{"Line":2}},{"line":237,"address":[1889201,1889236],"length":1,"stats":{"Line":4}},{"line":238,"address":[1464636,1464504,1464590],"length":1,"stats":{"Line":12}},{"line":239,"address":[1464722,1464654],"length":1,"stats":{"Line":8}},{"line":246,"address":[1465357,1464941,1465332,1464896],"length":1,"stats":{"Line":3}},{"line":247,"address":[1889670,1889705],"length":1,"stats":{"Line":6}},{"line":248,"address":[1889874,1889841,1889770],"length":1,"stats":{"Line":6}},{"line":249,"address":[1465168,1465229],"length":1,"stats":{"Line":4}},{"line":259,"address":[1466234,1466209,1465461,1465392],"length":1,"stats":{"Line":3}},{"line":264,"address":[1465471,1465446],"length":1,"stats":{"Line":6}},{"line":268,"address":[1465477,1465518],"length":1,"stats":{"Line":4}},{"line":269,"address":[1465582,1465665,1465711],"length":1,"stats":{"Line":3}},{"line":271,"address":[1465741],"length":1,"stats":{"Line":1}},{"line":272,"address":[1465804],"length":1,"stats":{"Line":1}},{"line":273,"address":[1465883],"length":1,"stats":{"Line":1}},{"line":278,"address":[1890659],"length":1,"stats":{"Line":1}},{"line":286,"address":[1466842,1466272,1466883,1466323],"length":1,"stats":{"Line":2}},{"line":287,"address":[1466339,1466300],"length":1,"stats":{"Line":3}},{"line":288,"address":[1466489,1466403,1466535],"length":1,"stats":{"Line":3}},{"line":289,"address":[1891222,1891155],"length":1,"stats":{"Line":2}},{"line":292,"address":[1466924],"length":1,"stats":{"Line":1}},{"line":297,"address":[1467407,1466944,1467448,1466992],"length":1,"stats":{"Line":2}},{"line":298,"address":[1467008,1466969],"length":1,"stats":{"Line":4}},{"line":299,"address":[1467158,1467204,1467072],"length":1,"stats":{"Line":6}},{"line":300,"address":[1467286,1467222],"length":1,"stats":{"Line":9}},{"line":303,"address":[1467489],"length":1,"stats":{"Line":1}}],"covered":101,"coverable":101},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","colorspace.rs"],"content":"//! C FFI for colorspace - MuPDF compatible\n//! Safe Rust implementation\n\nuse std::ffi::c_char;\n\n/// Colorspace type enumeration\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ColorspaceType {\n    None = 0,\n    Gray = 1,\n    Rgb = 2,\n    Bgr = 3,\n    Cmyk = 4,\n    Lab = 5,\n    Indexed = 6,\n    Separation = 7,\n}\n\n/// Colorspace handle - we use small integers for device colorspaces\n/// Handles 1-4 are reserved for device colorspaces\n/// 0 = invalid/null\npub type ColorspaceHandle = u64;\n\npub const FZ_COLORSPACE_GRAY: ColorspaceHandle = 1;\npub const FZ_COLORSPACE_RGB: ColorspaceHandle = 2;\npub const FZ_COLORSPACE_BGR: ColorspaceHandle = 3;\npub const FZ_COLORSPACE_CMYK: ColorspaceHandle = 4;\npub const FZ_COLORSPACE_LAB: ColorspaceHandle = 5;\n\n/// Get number of components for a colorspace\nfn colorspace_n(handle: ColorspaceHandle) -\u003e i32 {\n    match handle {\n        FZ_COLORSPACE_GRAY =\u003e 1,\n        FZ_COLORSPACE_RGB | FZ_COLORSPACE_BGR =\u003e 3,\n        FZ_COLORSPACE_CMYK =\u003e 4,\n        FZ_COLORSPACE_LAB =\u003e 3,\n        _ =\u003e 0,\n    }\n}\n\n/// Get colorspace type\nfn colorspace_type(handle: ColorspaceHandle) -\u003e ColorspaceType {\n    match handle {\n        FZ_COLORSPACE_GRAY =\u003e ColorspaceType::Gray,\n        FZ_COLORSPACE_RGB =\u003e ColorspaceType::Rgb,\n        FZ_COLORSPACE_BGR =\u003e ColorspaceType::Bgr,\n        FZ_COLORSPACE_CMYK =\u003e ColorspaceType::Cmyk,\n        FZ_COLORSPACE_LAB =\u003e ColorspaceType::Lab,\n        _ =\u003e ColorspaceType::None,\n    }\n}\n\n/// Get device gray colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_gray(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_GRAY\n}\n\n/// Get device RGB colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_rgb(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_RGB\n}\n\n/// Get device BGR colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_bgr(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_BGR\n}\n\n/// Get device CMYK colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_cmyk(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_CMYK\n}\n\n/// Get device Lab colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_device_lab(_ctx: super::Handle) -\u003e ColorspaceHandle {\n    FZ_COLORSPACE_LAB\n}\n\n/// Keep (increment ref) colorspace - device colorspaces are immortal\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_colorspace(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e ColorspaceHandle {\n    cs // Device colorspaces don't need ref counting\n}\n\n/// Drop colorspace reference - device colorspaces are immortal\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_colorspace(_ctx: super::Handle, _cs: ColorspaceHandle) {\n    // Device colorspaces are never freed\n}\n\n/// Get number of components in colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_n(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    colorspace_n(cs)\n}\n\n/// Check if colorspace is gray\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_gray(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Gray)\n}\n\n/// Check if colorspace is RGB\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_rgb(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Rgb)\n}\n\n/// Check if colorspace is CMYK\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_cmyk(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Cmyk)\n}\n\n/// Check if colorspace is Lab\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_lab(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(colorspace_type(cs) == ColorspaceType::Lab)\n}\n\n/// Check if colorspace is device colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_is_device(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e i32 {\n    i32::from(cs \u003e= FZ_COLORSPACE_GRAY \u0026\u0026 cs \u003c= FZ_COLORSPACE_LAB)\n}\n\n/// Get colorspace name\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_colorspace_name(_ctx: super::Handle, cs: ColorspaceHandle) -\u003e *const c_char {\n    match cs {\n        FZ_COLORSPACE_GRAY =\u003e c\"DeviceGray\".as_ptr(),\n        FZ_COLORSPACE_RGB =\u003e c\"DeviceRGB\".as_ptr(),\n        FZ_COLORSPACE_BGR =\u003e c\"DeviceBGR\".as_ptr(),\n        FZ_COLORSPACE_CMYK =\u003e c\"DeviceCMYK\".as_ptr(),\n        FZ_COLORSPACE_LAB =\u003e c\"Lab\".as_ptr(),\n        _ =\u003e c\"Unknown\".as_ptr(),\n    }\n}\n\n/// Convert color from one colorspace to another\n///\n/// # Safety\n/// Caller must ensure:\n/// - `src` points to valid memory of at least `src_cs.n` floats\n/// - `dst` points to writable memory of at least `dst_cs.n` floats\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_convert_color(\n    _ctx: super::Handle,\n    src_cs: ColorspaceHandle,\n    src: *const f32,\n    dst_cs: ColorspaceHandle,\n    dst: *mut f32,\n    _proof_cs: ColorspaceHandle,\n) {\n    if src.is_null() || dst.is_null() {\n        return;\n    }\n\n    let src_n = colorspace_n(src_cs) as usize;\n    let dst_n = colorspace_n(dst_cs) as usize;\n\n    if src_n == 0 || dst_n == 0 {\n        return;\n    }\n\n    // SAFETY: Caller guarantees src and dst point to valid memory\n    #[allow(unsafe_code)]\n    let (src_slice, dst_slice) = unsafe {\n        (\n            std::slice::from_raw_parts(src, src_n),\n            std::slice::from_raw_parts_mut(dst, dst_n),\n        )\n    };\n\n    // Simple color conversion (Gray -\u003e RGB, RGB -\u003e Gray, etc.)\n    match (colorspace_type(src_cs), colorspace_type(dst_cs)) {\n        (ColorspaceType::Gray, ColorspaceType::Rgb) =\u003e {\n            let g = src_slice[0];\n            dst_slice[0] = g;\n            dst_slice[1] = g;\n            dst_slice[2] = g;\n        }\n        (ColorspaceType::Rgb, ColorspaceType::Gray) =\u003e {\n            // Luminance formula\n            dst_slice[0] = src_slice[0] * 0.299 + src_slice[1] * 0.587 + src_slice[2] * 0.114;\n        }\n        (ColorspaceType::Rgb, ColorspaceType::Cmyk) =\u003e {\n            let r = src_slice[0];\n            let g = src_slice[1];\n            let b = src_slice[2];\n            let k = 1.0 - r.max(g).max(b);\n            if k \u003c 1.0 {\n                let inv_k = 1.0 / (1.0 - k);\n                dst_slice[0] = (1.0 - r - k) * inv_k;\n                dst_slice[1] = (1.0 - g - k) * inv_k;\n                dst_slice[2] = (1.0 - b - k) * inv_k;\n            } else {\n                dst_slice[0] = 0.0;\n                dst_slice[1] = 0.0;\n                dst_slice[2] = 0.0;\n            }\n            dst_slice[3] = k;\n        }\n        (ColorspaceType::Cmyk, ColorspaceType::Rgb) =\u003e {\n            let c = src_slice[0];\n            let m = src_slice[1];\n            let y = src_slice[2];\n            let k = src_slice[3];\n            dst_slice[0] = (1.0 - c) * (1.0 - k);\n            dst_slice[1] = (1.0 - m) * (1.0 - k);\n            dst_slice[2] = (1.0 - y) * (1.0 - k);\n        }\n        _ if src_cs == dst_cs =\u003e {\n            // Same colorspace, just copy\n            dst_slice[..src_n.min(dst_n)].copy_from_slice(\u0026src_slice[..src_n.min(dst_n)]);\n        }\n        _ =\u003e {\n            // Default: fill with zeros\n            dst_slice.fill(0.0);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_device_colorspaces() {\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_RGB), 3);\n        assert_eq!(fz_colorspace_n(0, FZ_COLORSPACE_CMYK), 4);\n    }\n\n    #[test]\n    fn test_colorspace_checks() {\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_RGB), 1);\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_CMYK), 1);\n    }\n\n    #[test]\n    fn test_colorspace_is_gray_negative() {\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_RGB), 0);\n        assert_eq!(fz_colorspace_is_gray(0, FZ_COLORSPACE_CMYK), 0);\n    }\n\n    #[test]\n    fn test_colorspace_is_rgb_negative() {\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_GRAY), 0);\n        assert_eq!(fz_colorspace_is_rgb(0, FZ_COLORSPACE_CMYK), 0);\n    }\n\n    #[test]\n    fn test_colorspace_is_cmyk_negative() {\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_GRAY), 0);\n        assert_eq!(fz_colorspace_is_cmyk(0, FZ_COLORSPACE_RGB), 0);\n    }\n\n    #[test]\n    fn test_colorspace_type() {\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_GRAY), ColorspaceType::Gray));\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_RGB), ColorspaceType::Rgb));\n        assert!(matches!(colorspace_type(FZ_COLORSPACE_CMYK), ColorspaceType::Cmyk));\n        assert!(matches!(colorspace_type(99), ColorspaceType::None));\n    }\n\n    #[test]\n    fn test_colorspace_n() {\n        assert_eq!(colorspace_n(FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(colorspace_n(FZ_COLORSPACE_RGB), 3);\n        assert_eq!(colorspace_n(FZ_COLORSPACE_CMYK), 4);\n        assert_eq!(colorspace_n(99), 0);\n    }\n\n    #[test]\n    fn test_device_gray_handle() {\n        let handle = fz_device_gray(0);\n        assert_eq!(handle, FZ_COLORSPACE_GRAY);\n    }\n\n    #[test]\n    fn test_device_rgb_handle() {\n        let handle = fz_device_rgb(0);\n        assert_eq!(handle, FZ_COLORSPACE_RGB);\n    }\n\n    #[test]\n    fn test_device_cmyk_handle() {\n        let handle = fz_device_cmyk(0);\n        assert_eq!(handle, FZ_COLORSPACE_CMYK);\n    }\n\n    #[test]\n    fn test_keep_drop_colorspace() {\n        // Keep and drop should not panic\n        let handle = fz_keep_colorspace(0, FZ_COLORSPACE_RGB);\n        assert_eq!(handle, FZ_COLORSPACE_RGB);\n        fz_drop_colorspace(0, handle);\n    }\n\n    #[test]\n    fn test_convert_color_gray_to_rgb() {\n        let src = [0.5f32];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_GRAY,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert!((dst[0] - 0.5).abs() \u003c 0.01);\n        assert!((dst[1] - 0.5).abs() \u003c 0.01);\n        assert!((dst[2] - 0.5).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_rgb_to_gray() {\n        let src = [1.0f32, 1.0, 1.0]; // White\n        let mut dst = [0.0f32];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_GRAY,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        // Luminance should be close to 1.0 for white\n        assert!((dst[0] - 1.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_rgb_to_cmyk() {\n        let src = [1.0f32, 0.0, 0.0]; // Red\n        let mut dst = [0.0f32; 4];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_CMYK,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        // Red in CMYK: C=0, M=1, Y=1, K=0\n        assert!(dst[0] \u003c 0.1); // Cyan should be low\n        assert_eq!(dst[3], 0.0); // Black should be 0\n    }\n\n    #[test]\n    fn test_convert_color_cmyk_to_rgb() {\n        let src = [0.0f32, 0.0, 0.0, 0.0]; // No ink = white\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_CMYK,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert!((dst[0] - 1.0).abs() \u003c 0.01);\n        assert!((dst[1] - 1.0).abs() \u003c 0.01);\n        assert!((dst[2] - 1.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_convert_color_same_colorspace() {\n        let src = [0.25f32, 0.5, 0.75];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(\n            0,\n            FZ_COLORSPACE_RGB,\n            src.as_ptr(),\n            FZ_COLORSPACE_RGB,\n            dst.as_mut_ptr(),\n            0,\n        );\n\n        assert_eq!(dst, src);\n    }\n\n    #[test]\n    fn test_convert_color_null_pointers() {\n        // Should not panic with null pointers\n        fz_convert_color(0, FZ_COLORSPACE_RGB, std::ptr::null(), FZ_COLORSPACE_GRAY, std::ptr::null_mut(), 0);\n    }\n\n    #[test]\n    fn test_convert_color_invalid_colorspace() {\n        let src = [0.5f32];\n        let mut dst = [1.0f32; 3];\n\n        // Invalid source colorspace - dst should be filled with zeros\n        fz_convert_color(0, 99, src.as_ptr(), FZ_COLORSPACE_RGB, dst.as_mut_ptr(), 0);\n        // Operation should not panic even with invalid colorspace\n    }\n\n    #[test]\n    fn test_colorspace_is_device() {\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_GRAY), 1);\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_RGB), 1);\n        assert_eq!(fz_colorspace_is_device(0, FZ_COLORSPACE_CMYK), 1);\n    }\n}\n","traces":[{"line":32,"address":[2128272],"length":1,"stats":{"Line":2}},{"line":33,"address":[1339528],"length":1,"stats":{"Line":3}},{"line":34,"address":[1339573],"length":1,"stats":{"Line":2}},{"line":35,"address":[1339583],"length":1,"stats":{"Line":6}},{"line":36,"address":[1339593],"length":1,"stats":{"Line":2}},{"line":37,"address":[1339603],"length":1,"stats":{"Line":0}},{"line":38,"address":[2128315],"length":1,"stats":{"Line":1}},{"line":43,"address":[1339616],"length":1,"stats":{"Line":2}},{"line":44,"address":[2128376],"length":1,"stats":{"Line":3}},{"line":45,"address":[1339669],"length":1,"stats":{"Line":3}},{"line":46,"address":[1339679],"length":1,"stats":{"Line":2}},{"line":47,"address":[1339689],"length":1,"stats":{"Line":0}},{"line":48,"address":[2128451],"length":1,"stats":{"Line":2}},{"line":49,"address":[1339709],"length":1,"stats":{"Line":0}},{"line":50,"address":[1339659],"length":1,"stats":{"Line":1}},{"line":56,"address":[1339728],"length":1,"stats":{"Line":3}},{"line":62,"address":[1339744],"length":1,"stats":{"Line":2}},{"line":68,"address":[1339760],"length":1,"stats":{"Line":0}},{"line":74,"address":[1339776],"length":1,"stats":{"Line":2}},{"line":80,"address":[1339792],"length":1,"stats":{"Line":0}},{"line":86,"address":[1339808],"length":1,"stats":{"Line":1}},{"line":92,"address":[1339824],"length":1,"stats":{"Line":1}},{"line":98,"address":[1339840,1339878],"length":1,"stats":{"Line":2}},{"line":99,"address":[1339867],"length":1,"stats":{"Line":2}},{"line":104,"address":[1339904,1339942],"length":1,"stats":{"Line":2}},{"line":105,"address":[1339952,1339931],"length":1,"stats":{"Line":4}},{"line":110,"address":[1340054,1340016],"length":1,"stats":{"Line":3}},{"line":111,"address":[1340043,1340064],"length":1,"stats":{"Line":5}},{"line":116,"address":[1340166,1340128],"length":1,"stats":{"Line":2}},{"line":117,"address":[1340155,1340176],"length":1,"stats":{"Line":4}},{"line":122,"address":[1340278,1340240],"length":1,"stats":{"Line":0}},{"line":123,"address":[1340267,1340288],"length":1,"stats":{"Line":0}},{"line":128,"address":[1340352,1340418],"length":1,"stats":{"Line":1}},{"line":129,"address":[1340371],"length":1,"stats":{"Line":1}},{"line":134,"address":[1340647,1340448],"length":1,"stats":{"Line":0}},{"line":135,"address":[1340465],"length":1,"stats":{"Line":0}},{"line":136,"address":[1340527,1340658],"length":1,"stats":{"Line":0}},{"line":137,"address":[1340678,1340551],"length":1,"stats":{"Line":0}},{"line":138,"address":[1340690,1340575],"length":1,"stats":{"Line":0}},{"line":139,"address":[1340702,1340599],"length":1,"stats":{"Line":0}},{"line":140,"address":[1340714,1340623],"length":1,"stats":{"Line":0}},{"line":141,"address":[1340500,1340726],"length":1,"stats":{"Line":0}},{"line":152,"address":[1340736,1340860],"length":1,"stats":{"Line":5}},{"line":160,"address":[2129664,2129621,2129594],"length":1,"stats":{"Line":19}},{"line":164,"address":[2129678],"length":1,"stats":{"Line":4}},{"line":165,"address":[2129725],"length":1,"stats":{"Line":2}},{"line":167,"address":[1341029],"length":1,"stats":{"Line":7}},{"line":175,"address":[1341073],"length":1,"stats":{"Line":6}},{"line":176,"address":[2129888],"length":1,"stats":{"Line":4}},{"line":181,"address":[1341492,1341343],"length":1,"stats":{"Line":8}},{"line":183,"address":[1341581,1341643],"length":1,"stats":{"Line":2}},{"line":184,"address":[2130452,2130362,2130428],"length":1,"stats":{"Line":4}},{"line":185,"address":[2130524,2130499,2130432],"length":1,"stats":{"Line":4}},{"line":186,"address":[1341849,1341768,1341831],"length":1,"stats":{"Line":4}},{"line":188,"address":[2130946],"length":1,"stats":{"Line":1}},{"line":190,"address":[1341932,1342223,1341883],"length":1,"stats":{"Line":2}},{"line":193,"address":[2131000,2131042,2130636],"length":1,"stats":{"Line":2}},{"line":194,"address":[1342390,1342286,1342347],"length":1,"stats":{"Line":2}},{"line":195,"address":[2131106,2131225,2131178],"length":1,"stats":{"Line":2}},{"line":196,"address":[1342533,1342465],"length":1,"stats":{"Line":2}},{"line":197,"address":[2131614,2131950,2131324],"length":1,"stats":{"Line":2}},{"line":198,"address":[1342647],"length":1,"stats":{"Line":1}},{"line":199,"address":[2131723,2131773,2131422],"length":1,"stats":{"Line":2}},{"line":200,"address":[1342995,1343159,1343108],"length":1,"stats":{"Line":2}},{"line":201,"address":[1343227,1343117,1343205],"length":1,"stats":{"Line":2}},{"line":203,"address":[1342740,1342767,1342609],"length":1,"stats":{"Line":0}},{"line":204,"address":[1342747,1342808,1342836],"length":1,"stats":{"Line":0}},{"line":205,"address":[1342816,1342888,1342870],"length":1,"stats":{"Line":0}},{"line":207,"address":[1343288,1343270,1342922],"length":1,"stats":{"Line":2}},{"line":210,"address":[1343322,1343384],"length":1,"stats":{"Line":1}},{"line":211,"address":[2132161,2132100,2132201],"length":1,"stats":{"Line":2}},{"line":212,"address":[1343445,1343507,1343547],"length":1,"stats":{"Line":2}},{"line":213,"address":[2132331,2132407,2132263],"length":1,"stats":{"Line":2}},{"line":214,"address":[1343804,1343737,1343615],"length":1,"stats":{"Line":2}},{"line":215,"address":[1343745,1343869,1343934],"length":1,"stats":{"Line":2}},{"line":216,"address":[1344002,1343980,1343878],"length":1,"stats":{"Line":2}},{"line":218,"address":[1341478],"length":1,"stats":{"Line":1}},{"line":220,"address":[1344116,1344074],"length":1,"stats":{"Line":2}},{"line":224,"address":[1344090,1344044],"length":1,"stats":{"Line":0}}],"covered":60,"coverable":79},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","context.rs"],"content":"//! C FFI for context - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, CONTEXTS};\nuse std::ffi::c_void;\n\n/// Internal context state\npub struct Context {\n    user_data: Option\u003cusize\u003e, // Store as usize to avoid raw pointers\n    error_code: i32,\n    error_message: String,\n}\n\nimpl Default for Context {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Context {\n    pub fn new() -\u003e Self {\n        Self {\n            user_data: None,\n            error_code: 0,\n            error_message: String::new(),\n        }\n    }\n\n    pub fn set_error(\u0026mut self, code: i32, message: \u0026str) {\n        self.error_code = code;\n        self.error_message = message.to_string();\n    }\n\n    pub fn clear_error(\u0026mut self) {\n        self.error_code = 0;\n        self.error_message.clear();\n    }\n}\n\n// Error codes matching MuPDF\npub const FZ_ERROR_NONE: i32 = 0;\npub const FZ_ERROR_MEMORY: i32 = 1;\npub const FZ_ERROR_GENERIC: i32 = 2;\npub const FZ_ERROR_SYNTAX: i32 = 3;\npub const FZ_ERROR_MINOR: i32 = 4;\npub const FZ_ERROR_TRYLATER: i32 = 5;\npub const FZ_ERROR_ABORT: i32 = 6;\npub const FZ_ERROR_SYSTEM: i32 = 7;\npub const FZ_ERROR_LIBRARY: i32 = 8;\npub const FZ_ERROR_FORMAT: i32 = 9;\npub const FZ_ERROR_LIMIT: i32 = 10;\npub const FZ_ERROR_UNSUPPORTED: i32 = 11;\npub const FZ_ERROR_ARGUMENT: i32 = 12;\n\n/// Create a new context\n/// Returns a handle (non-zero on success, 0 on failure)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_context(\n    _alloc: *const c_void,\n    _locks: *const c_void,\n    _max_store: usize,\n) -\u003e Handle {\n    CONTEXTS.insert(Context::new())\n}\n\n/// Clone a context (creates a new handle sharing state conceptually)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clone_context(ctx: Handle) -\u003e Handle {\n    if CONTEXTS.get(ctx).is_some() {\n        CONTEXTS.insert(Context::new())\n    } else {\n        0\n    }\n}\n\n/// Drop a context reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_context(ctx: Handle) {\n    let _ = CONTEXTS.remove(ctx);\n}\n\n/// Set user data on context\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_set_user_context(ctx: Handle, user: *mut c_void) {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(mut ctx) = context.lock() {\n            ctx.user_data = Some(user as usize);\n        }\n    }\n}\n\n/// Get user data from context\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_user_context(ctx: Handle) -\u003e *mut c_void {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(guard) = context.lock() {\n            if let Some(ud) = guard.user_data {\n                return ud as *mut c_void;\n            }\n        }\n    }\n    std::ptr::null_mut()\n}\n\n/// Get the error code from the last caught exception\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_caught(ctx: Handle) -\u003e i32 {\n    if let Some(context) = CONTEXTS.get(ctx) {\n        if let Ok(guard) = context.lock() {\n            return guard.error_code;\n        }\n    }\n    0\n}\n\n/// Get the error message from the last caught exception\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_caught_message(_ctx: Handle) -\u003e *const std::ffi::c_char {\n    // Return a static string for now - proper implementation would\n    // need to maintain a stable pointer to the error message\n    c\"No error\".as_ptr()\n}\n\n/// Memory allocation through Rust's allocator\n/// Returns null pointer on failure\n///\n/// # Safety\n/// Memory allocation requires unsafe - this is unavoidable for C FFI.\n/// The allocated memory must be freed with fz_free.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_malloc(_ctx: Handle, size: usize) -\u003e *mut c_void {\n    if size == 0 {\n        return std::ptr::null_mut();\n    }\n\n    let layout = match std::alloc::Layout::from_size_align(size, 8) {\n        Ok(l) =\u003e l,\n        Err(_) =\u003e return std::ptr::null_mut(),\n    };\n\n    // SAFETY: Memory allocation is inherently unsafe but necessary for C FFI.\n    // We use the global allocator which is safe to use from any thread.\n    #[allow(unsafe_code)]\n    unsafe {\n        std::alloc::alloc(layout) as *mut c_void\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_free(_ctx: Handle, _ptr: *mut c_void) {\n    // Note: Proper deallocation would require tracking the size\n    // For a real implementation, consider using a slab allocator\n    // or tracking allocations in a HashMap\n}\n\n/// Duplicate a C string (allocates new memory)\n///\n/// # Safety\n/// This function interfaces with C code and requires minimal unsafe for:\n/// - Reading from C string pointer (CStr::from_ptr)\n/// - Writing to allocated memory\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_strdup(ctx: Handle, s: *const std::ffi::c_char) -\u003e *mut std::ffi::c_char {\n    if s.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    // SAFETY: Caller guarantees s is a valid null-terminated C string\n    let c_str = match std::panic::catch_unwind(|| {\n        // This is the minimal unsafe needed to read a C string\n        #[allow(unsafe_code)]\n        unsafe { std::ffi::CStr::from_ptr(s) }\n    }) {\n        Ok(c) =\u003e c,\n        Err(_) =\u003e return std::ptr::null_mut(),\n    };\n\n    let bytes = c_str.to_bytes_with_nul();\n    let len = bytes.len();\n\n    let ptr = fz_malloc(ctx, len);\n    if ptr.is_null() {\n        return std::ptr::null_mut();\n    }\n\n    // SAFETY: We just allocated this memory and know its size\n    #[allow(unsafe_code)]\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr as *mut u8, len);\n    }\n\n    ptr as *mut std::ffi::c_char\n}\n\nimpl Drop for Context {\n    fn drop(\u0026mut self) {\n        // Clean up any resources\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_context_new() {\n        let ctx = Context::new();\n        assert_eq!(ctx.error_code, 0);\n        assert!(ctx.error_message.is_empty());\n        assert!(ctx.user_data.is_none());\n    }\n\n    #[test]\n    fn test_context_default() {\n        let ctx: Context = Default::default();\n        assert_eq!(ctx.error_code, 0);\n    }\n\n    #[test]\n    fn test_context_set_error() {\n        let mut ctx = Context::new();\n        ctx.set_error(FZ_ERROR_GENERIC, \"Test error\");\n        assert_eq!(ctx.error_code, FZ_ERROR_GENERIC);\n        assert_eq!(ctx.error_message, \"Test error\");\n    }\n\n    #[test]\n    fn test_context_clear_error() {\n        let mut ctx = Context::new();\n        ctx.set_error(FZ_ERROR_SYNTAX, \"Syntax error\");\n        ctx.clear_error();\n        assert_eq!(ctx.error_code, FZ_ERROR_NONE);\n        assert!(ctx.error_message.is_empty());\n    }\n\n    #[test]\n    fn test_fz_new_context() {\n        let handle = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        fz_drop_context(handle);\n    }\n\n    #[test]\n    fn test_fz_clone_context() {\n        let handle1 = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let handle2 = fz_clone_context(handle1);\n        assert_ne!(handle2, 0);\n        assert_ne!(handle1, handle2);\n        fz_drop_context(handle1);\n        fz_drop_context(handle2);\n    }\n\n    #[test]\n    fn test_fz_clone_invalid_context() {\n        let handle = fz_clone_context(0);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_user_context() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Initially null\n        let user = fz_user_context(ctx);\n        assert!(user.is_null());\n\n        // Set user data\n        let data: usize = 0x12345678;\n        fz_set_user_context(ctx, data as *mut c_void);\n\n        // Get it back\n        let user = fz_user_context(ctx);\n        assert_eq!(user as usize, data);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_caught() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Initially 0\n        assert_eq!(fz_caught(ctx), 0);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_caught_message() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let msg = fz_caught_message(ctx);\n        assert!(!msg.is_null());\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_malloc() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Zero size returns null\n        let ptr = fz_malloc(ctx, 0);\n        assert!(ptr.is_null());\n\n        // Normal allocation\n        let ptr = fz_malloc(ctx, 100);\n        assert!(!ptr.is_null());\n        fz_free(ctx, ptr);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_fz_strdup() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n\n        // Null input returns null\n        let result = fz_strdup(ctx, std::ptr::null());\n        assert!(result.is_null());\n\n        // Valid string\n        let s = c\"Hello, World!\";\n        let result = fz_strdup(ctx, s.as_ptr());\n        assert!(!result.is_null());\n        fz_free(ctx, result as *mut c_void);\n\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_error_codes() {\n        assert_eq!(FZ_ERROR_NONE, 0);\n        assert_eq!(FZ_ERROR_MEMORY, 1);\n        assert_eq!(FZ_ERROR_GENERIC, 2);\n        assert_eq!(FZ_ERROR_SYNTAX, 3);\n        assert_eq!(FZ_ERROR_MINOR, 4);\n        assert_eq!(FZ_ERROR_TRYLATER, 5);\n        assert_eq!(FZ_ERROR_ABORT, 6);\n        assert_eq!(FZ_ERROR_SYSTEM, 7);\n        assert_eq!(FZ_ERROR_LIBRARY, 8);\n        assert_eq!(FZ_ERROR_FORMAT, 9);\n        assert_eq!(FZ_ERROR_LIMIT, 10);\n        assert_eq!(FZ_ERROR_UNSUPPORTED, 11);\n        assert_eq!(FZ_ERROR_ARGUMENT, 12);\n    }\n\n    #[test]\n    fn test_fz_user_context_invalid_handle() {\n        let user = fz_user_context(0);\n        assert!(user.is_null());\n    }\n\n    #[test]\n    fn test_fz_caught_invalid_handle() {\n        assert_eq!(fz_caught(0), 0);\n    }\n}\n","traces":[{"line":15,"address":[2123344],"length":1,"stats":{"Line":1}},{"line":16,"address":[2123352],"length":1,"stats":{"Line":1}},{"line":21,"address":[1566800],"length":1,"stats":{"Line":2}},{"line":25,"address":[1566822],"length":1,"stats":{"Line":2}},{"line":29,"address":[1567034,1566912],"length":1,"stats":{"Line":1}},{"line":30,"address":[1566965],"length":1,"stats":{"Line":1}},{"line":31,"address":[1567065,1567007,1566968],"length":1,"stats":{"Line":4}},{"line":34,"address":[1567104],"length":1,"stats":{"Line":1}},{"line":35,"address":[2123685],"length":1,"stats":{"Line":1}},{"line":36,"address":[1567116],"length":1,"stats":{"Line":1}},{"line":58,"address":[1567225,1567178,1567136],"length":1,"stats":{"Line":4}},{"line":63,"address":[1567155,1567184],"length":1,"stats":{"Line":6}},{"line":68,"address":[1567443,1567304,1567565,1567264],"length":1,"stats":{"Line":1}},{"line":69,"address":[1567320,1567281],"length":1,"stats":{"Line":2}},{"line":70,"address":[1567490],"length":1,"stats":{"Line":1}},{"line":72,"address":[1567468],"length":1,"stats":{"Line":1}},{"line":78,"address":[1567677,1567621,1567584],"length":1,"stats":{"Line":2}},{"line":79,"address":[1567637,1567598],"length":1,"stats":{"Line":7}},{"line":84,"address":[1568213,1567712,1568188,1567765],"length":1,"stats":{"Line":1}},{"line":85,"address":[1567742,1567781],"length":1,"stats":{"Line":2}},{"line":86,"address":[1567845,1567982,1567931],"length":1,"stats":{"Line":3}},{"line":87,"address":[1568076,1568000],"length":1,"stats":{"Line":2}},{"line":94,"address":[1568735,1568860,1568256,1568296,1568819],"length":1,"stats":{"Line":1}},{"line":95,"address":[1568312,1568273],"length":1,"stats":{"Line":2}},{"line":96,"address":[1568376,1568508,1568462],"length":1,"stats":{"Line":3}},{"line":97,"address":[1568590,1568526],"length":1,"stats":{"Line":2}},{"line":98,"address":[1568616],"length":1,"stats":{"Line":1}},{"line":102,"address":[1568844,1568871],"length":1,"stats":{"Line":2}},{"line":107,"address":[1568880,1569344,1569307,1568920],"length":1,"stats":{"Line":1}},{"line":108,"address":[1568897,1568936],"length":1,"stats":{"Line":2}},{"line":109,"address":[1569129,1569000,1569083],"length":1,"stats":{"Line":3}},{"line":110,"address":[1569208,1569147],"length":1,"stats":{"Line":2}},{"line":113,"address":[1569385],"length":1,"stats":{"Line":1}},{"line":118,"address":[1569441,1569408],"length":1,"stats":{"Line":1}},{"line":121,"address":[2125737],"length":1,"stats":{"Line":1}},{"line":131,"address":[1569540,1569472],"length":1,"stats":{"Line":1}},{"line":132,"address":[1569491],"length":1,"stats":{"Line":1}},{"line":133,"address":[1569497,1569551],"length":1,"stats":{"Line":2}},{"line":136,"address":[1569523,1569576],"length":1,"stats":{"Line":2}},{"line":137,"address":[1569627],"length":1,"stats":{"Line":1}},{"line":138,"address":[2125986,2125927],"length":1,"stats":{"Line":0}},{"line":145,"address":[1569647],"length":1,"stats":{"Line":1}},{"line":150,"address":[2126000],"length":1,"stats":{"Line":1}},{"line":163,"address":[1570267,1569712,1569757,1569910,1570261],"length":1,"stats":{"Line":1}},{"line":164,"address":[2126067,2126041],"length":1,"stats":{"Line":2}},{"line":165,"address":[1569797,1570278],"length":1,"stats":{"Line":2}},{"line":169,"address":[1533424],"length":1,"stats":{"Line":3}},{"line":172,"address":[1533429],"length":1,"stats":{"Line":1}},{"line":174,"address":[1569849],"length":1,"stats":{"Line":1}},{"line":175,"address":[1570234,1569830],"length":1,"stats":{"Line":0}},{"line":178,"address":[1569948],"length":1,"stats":{"Line":1}},{"line":179,"address":[2126296],"length":1,"stats":{"Line":1}},{"line":181,"address":[1570020],"length":1,"stats":{"Line":1}},{"line":182,"address":[1570048],"length":1,"stats":{"Line":1}},{"line":183,"address":[1570099,1570175],"length":1,"stats":{"Line":0}},{"line":189,"address":[1570083,1570130],"length":1,"stats":{"Line":2}},{"line":192,"address":[1570146],"length":1,"stats":{"Line":1}},{"line":196,"address":[1370800],"length":1,"stats":{"Line":2}}],"covered":55,"coverable":58},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","document.rs"],"content":"//! C FFI for document - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, DOCUMENTS, STREAMS};\nuse std::ffi::c_char;\n\n/// Internal document state\npub struct Document {\n    // PDF document data - will be expanded with actual PDF parsing\n    data: Vec\u003cu8\u003e,\n    page_count: i32,\n    needs_password: bool,\n    authenticated: bool,\n}\n\nimpl Document {\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self {\n        // Basic PDF detection and page count estimation\n        // In a real implementation, this would parse the PDF structure\n        let page_count = Self::estimate_page_count(\u0026data);\n\n        Self {\n            data,\n            page_count,\n            needs_password: false,\n            authenticated: true,\n        }\n    }\n\n    fn estimate_page_count(data: \u0026[u8]) -\u003e i32 {\n        // Simple heuristic: count /Type /Page occurrences\n        // Real implementation would parse the PDF properly\n        let mut count = 0;\n        let pattern = b\"/Type /Page\";\n\n        for window in data.windows(pattern.len()) {\n            if window == pattern {\n                count += 1;\n            }\n        }\n\n        count.max(1) // At least 1 page\n    }\n}\n\n/// Open a document from file\n///\n/// # Safety\n/// Caller must ensure `filename` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_document(_ctx: Handle, filename: *const c_char) -\u003e Handle {\n    if filename.is_null() {\n        return 0;\n    }\n\n    // SAFETY: Caller guarantees filename is a valid null-terminated C string\n    #[allow(unsafe_code)]\n    let c_str = unsafe { std::ffi::CStr::from_ptr(filename) };\n    let path = match c_str.to_str() {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return 0,\n    };\n\n    match std::fs::read(path) {\n        Ok(data) =\u003e DOCUMENTS.insert(Document::new(data)),\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Open a document from stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_document_with_stream(\n    _ctx: Handle,\n    _magic: *const c_char,\n    stm: Handle,\n) -\u003e Handle {\n    // Read all data from stream\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return DOCUMENTS.insert(Document::new(guard.data.clone()));\n        }\n    }\n    0\n}\n\n/// Keep (increment ref) document\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_document(_ctx: Handle, doc: Handle) -\u003e Handle {\n    DOCUMENTS.keep(doc)\n}\n\n/// Drop document reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_document(_ctx: Handle, doc: Handle) {\n    let _ = DOCUMENTS.remove(doc);\n}\n\n/// Check if document needs a password\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_needs_password(_ctx: Handle, doc: Handle) -\u003e i32 {\n    if let Some(d) = DOCUMENTS.get(doc) {\n        if let Ok(guard) = d.lock() {\n            return i32::from(guard.needs_password);\n        }\n    }\n    0\n}\n\n/// Authenticate with password\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_authenticate_password(\n    _ctx: Handle,\n    doc: Handle,\n    _password: *const c_char,\n) -\u003e i32 {\n    if let Some(document) = DOCUMENTS.get(doc) {\n        if let Ok(mut d) = document.lock() {\n            // For now, always succeed if no password needed\n            if !d.needs_password {\n                d.authenticated = true;\n                return 1;\n            }\n            // TODO: Implement actual password verification\n        }\n    }\n    0\n}\n\n/// Count pages in document\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_pages(_ctx: Handle, doc: Handle) -\u003e i32 {\n    if let Some(d) = DOCUMENTS.get(doc) {\n        if let Ok(guard) = d.lock() {\n            return guard.page_count;\n        }\n    }\n    0\n}\n\n/// Count chapters in document (PDF has 1 chapter)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_chapters(_ctx: Handle, _doc: Handle) -\u003e i32 {\n    1\n}\n\n/// Count pages in chapter\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_count_chapter_pages(_ctx: Handle, doc: Handle, _chapter: i32) -\u003e i32 {\n    fz_count_pages(_ctx, doc)\n}\n\n/// Get page number from location\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_page_number_from_location(\n    _ctx: Handle,\n    _doc: Handle,\n    chapter: i32,\n    page: i32,\n) -\u003e i32 {\n    if chapter == 0 {\n        page\n    } else {\n        -1\n    }\n}\n\n/// Check document permission\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_has_permission(_ctx: Handle, doc: Handle, _permission: i32) -\u003e i32 {\n    // For now, allow all permissions if document is open\n    if DOCUMENTS.get(doc).is_some() {\n        1\n    } else {\n        0\n    }\n}\n\n// Permission flags\npub const FZ_PERMISSION_PRINT: i32 = 1 \u003c\u003c 0;\npub const FZ_PERMISSION_COPY: i32 = 1 \u003c\u003c 1;\npub const FZ_PERMISSION_EDIT: i32 = 1 \u003c\u003c 2;\npub const FZ_PERMISSION_ANNOTATE: i32 = 1 \u003c\u003c 3;\n\n/// Lookup metadata\n///\n/// # Safety\n/// Caller must ensure `buf` points to writable memory of at least `size` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_lookup_metadata(\n    _ctx: Handle,\n    _doc: Handle,\n    _key: *const c_char,\n    buf: *mut c_char,\n    size: i32,\n) -\u003e i32 {\n    // Return empty string for now\n    if !buf.is_null() \u0026\u0026 size \u003e 0 {\n        // SAFETY: Caller guarantees buf points to writable memory of `size` bytes\n        #[allow(unsafe_code)]\n        unsafe {\n            *buf = 0; // Null terminate\n        }\n    }\n    -1 // Key not found\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use super::super::STREAMS;\n    use super::super::stream::Stream;\n\n    #[test]\n    fn test_document_handle() {\n        // Create a minimal \"PDF\" for testing\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n\n        let handle = DOCUMENTS.insert(doc);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_count_chapters(0, handle), 1);\n        assert!(fz_count_pages(0, handle) \u003e= 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_document_new() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        assert_eq!(doc.page_count, 2);\n        assert!(!doc.needs_password);\n        assert!(doc.authenticated);\n    }\n\n    #[test]\n    fn test_document_estimate_page_count() {\n        // No pages\n        let empty = b\"%PDF-1.4\\n%%EOF\";\n        let doc1 = Document::new(empty.to_vec());\n        assert_eq!(doc1.page_count, 1); // Minimum 1\n\n        // Multiple pages\n        let multi = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc2 = Document::new(multi.to_vec());\n        assert_eq!(doc2.page_count, 3);\n    }\n\n    #[test]\n    fn test_keep_document() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        let kept = fz_keep_document(0, handle);\n        assert_eq!(kept, handle);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_needs_password() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_needs_password(0, handle), 0);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_needs_password_invalid_handle() {\n        assert_eq!(fz_needs_password(0, 0), 0);\n    }\n\n    #[test]\n    fn test_authenticate_password() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        // No password needed, should succeed\n        let result = fz_authenticate_password(0, handle, c\"\".as_ptr());\n        assert_eq!(result, 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_authenticate_password_invalid_handle() {\n        let result = fz_authenticate_password(0, 0, c\"\".as_ptr());\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_count_pages() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_count_pages(0, handle), 2);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_count_pages_invalid_handle() {\n        assert_eq!(fz_count_pages(0, 0), 0);\n    }\n\n    #[test]\n    fn test_count_chapters() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        // PDFs always have 1 chapter\n        assert_eq!(fz_count_chapters(0, handle), 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_count_chapter_pages() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_count_chapter_pages(0, handle, 0), 2);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_page_number_from_location() {\n        assert_eq!(fz_page_number_from_location(0, 0, 0, 5), 5);\n        assert_eq!(fz_page_number_from_location(0, 0, 0, 0), 0);\n        assert_eq!(fz_page_number_from_location(0, 0, 1, 5), -1); // Invalid chapter\n    }\n\n    #[test]\n    fn test_has_permission() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_PRINT), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_COPY), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_EDIT), 1);\n        assert_eq!(fz_has_permission(0, handle, FZ_PERMISSION_ANNOTATE), 1);\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_has_permission_invalid_handle() {\n        assert_eq!(fz_has_permission(0, 0, FZ_PERMISSION_PRINT), 0);\n    }\n\n    #[test]\n    fn test_lookup_metadata() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let doc = Document::new(pdf_data.to_vec());\n        let handle = DOCUMENTS.insert(doc);\n\n        let mut buf = [0i8; 100];\n        let result = fz_lookup_metadata(0, handle, c\"Title\".as_ptr(), buf.as_mut_ptr(), 100);\n        assert_eq!(result, -1); // Not found\n\n        fz_drop_document(0, handle);\n    }\n\n    #[test]\n    fn test_lookup_metadata_null_buffer() {\n        let result = fz_lookup_metadata(0, 0, c\"Title\".as_ptr(), std::ptr::null_mut(), 0);\n        assert_eq!(result, -1);\n    }\n\n    #[test]\n    fn test_open_document_null_filename() {\n        let handle = fz_open_document(0, std::ptr::null());\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_open_document_with_stream() {\n        let pdf_data = b\"%PDF-1.4\\n/Type /Page\\n%%EOF\";\n        let stream = Stream::from_memory(pdf_data.to_vec());\n        let stream_handle = STREAMS.insert(stream);\n\n        let doc_handle = fz_open_document_with_stream(0, std::ptr::null(), stream_handle);\n        assert_ne!(doc_handle, 0);\n\n        assert_eq!(fz_count_pages(0, doc_handle), 1);\n\n        fz_drop_document(0, doc_handle);\n        super::super::STREAMS.remove(stream_handle);\n    }\n\n    #[test]\n    fn test_open_document_with_invalid_stream() {\n        let doc_handle = fz_open_document_with_stream(0, std::ptr::null(), 0);\n        assert_eq!(doc_handle, 0);\n    }\n\n    #[test]\n    fn test_permission_constants() {\n        assert_eq!(FZ_PERMISSION_PRINT, 1);\n        assert_eq!(FZ_PERMISSION_COPY, 2);\n        assert_eq!(FZ_PERMISSION_EDIT, 4);\n        assert_eq!(FZ_PERMISSION_ANNOTATE, 8);\n    }\n}\n\n","traces":[{"line":17,"address":[1898563,1898368],"length":1,"stats":{"Line":11}},{"line":20,"address":[1898461,1898395],"length":1,"stats":{"Line":22}},{"line":30,"address":[1562736],"length":1,"stats":{"Line":11}},{"line":33,"address":[1562762],"length":1,"stats":{"Line":1}},{"line":34,"address":[1562770],"length":1,"stats":{"Line":11}},{"line":36,"address":[1562851,1562782],"length":1,"stats":{"Line":22}},{"line":37,"address":[1562986,1562920],"length":1,"stats":{"Line":22}},{"line":38,"address":[1562991,1562965],"length":1,"stats":{"Line":10}},{"line":42,"address":[1898795],"length":1,"stats":{"Line":1}},{"line":51,"address":[1563571,1563072,1563577,1563008],"length":1,"stats":{"Line":1}},{"line":52,"address":[1563082,1563049],"length":1,"stats":{"Line":2}},{"line":53,"address":[1563110],"length":1,"stats":{"Line":1}},{"line":58,"address":[1563093,1563134],"length":1,"stats":{"Line":0}},{"line":59,"address":[1563150],"length":1,"stats":{"Line":0}},{"line":60,"address":[1563191],"length":1,"stats":{"Line":0}},{"line":61,"address":[1563177],"length":1,"stats":{"Line":0}},{"line":64,"address":[1563217],"length":1,"stats":{"Line":0}},{"line":65,"address":[1563281,1563335,1563555],"length":1,"stats":{"Line":0}},{"line":66,"address":[1563267],"length":1,"stats":{"Line":0}},{"line":72,"address":[1563664,1564222,1564263,1563723],"length":1,"stats":{"Line":1}},{"line":78,"address":[1563700,1563739],"length":1,"stats":{"Line":2}},{"line":79,"address":[1563889,1563935,1563803],"length":1,"stats":{"Line":3}},{"line":80,"address":[1563953,1564017],"length":1,"stats":{"Line":2}},{"line":83,"address":[1564304],"length":1,"stats":{"Line":1}},{"line":88,"address":[1564362,1564320],"length":1,"stats":{"Line":1}},{"line":89,"address":[1564378,1564339],"length":1,"stats":{"Line":2}},{"line":94,"address":[1564416,1564458,1564516],"length":1,"stats":{"Line":1}},{"line":95,"address":[1564435,1564474],"length":1,"stats":{"Line":6}},{"line":100,"address":[1564592,1565044,1564544,1565004],"length":1,"stats":{"Line":1}},{"line":101,"address":[1564569,1564608],"length":1,"stats":{"Line":2}},{"line":102,"address":[1564804,1564672,1564758],"length":1,"stats":{"Line":3}},{"line":103,"address":[1564886,1564822],"length":1,"stats":{"Line":2}},{"line":106,"address":[1565085],"length":1,"stats":{"Line":1}},{"line":111,"address":[1565610,1565693,1565104,1565157],"length":1,"stats":{"Line":1}},{"line":116,"address":[1900849,1900814],"length":1,"stats":{"Line":2}},{"line":117,"address":[1565237,1565323,1565369],"length":1,"stats":{"Line":3}},{"line":119,"address":[1565451,1565387],"length":1,"stats":{"Line":2}},{"line":120,"address":[1565457,1565500],"length":1,"stats":{"Line":2}},{"line":121,"address":[1565504],"length":1,"stats":{"Line":1}},{"line":126,"address":[1565718],"length":1,"stats":{"Line":1}},{"line":131,"address":[1901726,1901385,1901344,1901763],"length":1,"stats":{"Line":1}},{"line":132,"address":[1565750,1565789],"length":1,"stats":{"Line":2}},{"line":133,"address":[1901537,1901570,1901466],"length":1,"stats":{"Line":9}},{"line":134,"address":[1566000,1566059],"length":1,"stats":{"Line":8}},{"line":137,"address":[1901796],"length":1,"stats":{"Line":1}},{"line":142,"address":[1566256],"length":1,"stats":{"Line":2}},{"line":148,"address":[1901824],"length":1,"stats":{"Line":1}},{"line":149,"address":[1566289],"length":1,"stats":{"Line":1}},{"line":154,"address":[1901856],"length":1,"stats":{"Line":1}},{"line":160,"address":[1566326,1566339],"length":1,"stats":{"Line":2}},{"line":161,"address":[1566335],"length":1,"stats":{"Line":1}},{"line":163,"address":[1566341],"length":1,"stats":{"Line":1}},{"line":169,"address":[1901920,1901962,1902127,1902078],"length":1,"stats":{"Line":1}},{"line":171,"address":[1566597,1566430,1566391],"length":1,"stats":{"Line":3}},{"line":172,"address":[1566589],"length":1,"stats":{"Line":1}},{"line":174,"address":[1566572],"length":1,"stats":{"Line":1}},{"line":189,"address":[1566608,1566675],"length":1,"stats":{"Line":1}},{"line":197,"address":[1566685,1566740,1566660],"length":1,"stats":{"Line":3}},{"line":201,"address":[1566715,1566742],"length":1,"stats":{"Line":1}}],"covered":52,"coverable":59},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","geometry.rs"],"content":"//! C FFI for geometry types - MuPDF compatible\n//!\n//! # Safety Note\n//! This module provides C FFI exports which require `unsafe` annotations\n//! in Rust 2024 edition. The internal implementation is 100% safe Rust.\n//! The `#[unsafe(no_mangle)]` attribute is required for C symbol visibility.\n\nuse std::ffi::c_float;\n\n/// fz_point - 2D point\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_point {\n    pub x: c_float,\n    pub y: c_float,\n}\n\n/// fz_rect - Rectangle\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_rect {\n    pub x0: c_float,\n    pub y0: c_float,\n    pub x1: c_float,\n    pub y1: c_float,\n}\n\n/// fz_irect - Integer rectangle\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub struct fz_irect {\n    pub x0: i32,\n    pub y0: i32,\n    pub x1: i32,\n    pub y1: i32,\n}\n\n/// fz_matrix - Transformation matrix\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct fz_matrix {\n    pub a: c_float,\n    pub b: c_float,\n    pub c: c_float,\n    pub d: c_float,\n    pub e: c_float,\n    pub f: c_float,\n}\n\nimpl Default for fz_matrix {\n    fn default() -\u003e Self {\n        Self::identity()\n    }\n}\n\nimpl fz_matrix {\n    pub const fn identity() -\u003e Self {\n        Self { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 }\n    }\n}\n\n/// fz_quad - Quadrilateral\n#[repr(C)]\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub struct fz_quad {\n    pub ul: fz_point,\n    pub ur: fz_point,\n    pub ll: fz_point,\n    pub lr: fz_point,\n}\n\n// Constants\npub const FZ_MIN_INF_RECT: i32 = i32::MIN;\npub const FZ_MAX_INF_RECT: i32 = 0x7fffff80;\n\n// Static constants exposed to C\n// SAFETY: These are constant data with no mutable access, safe for FFI export\n#[unsafe(no_mangle)]\npub static fz_identity: fz_matrix = fz_matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 };\n\n#[unsafe(no_mangle)]\npub static fz_empty_rect: fz_rect = fz_rect {\n    x0: f32::INFINITY, y0: f32::INFINITY,\n    x1: f32::NEG_INFINITY, y1: f32::NEG_INFINITY,\n};\n\n#[unsafe(no_mangle)]\npub static fz_infinite_rect: fz_rect = fz_rect {\n    x0: FZ_MIN_INF_RECT as f32, y0: FZ_MIN_INF_RECT as f32,\n    x1: FZ_MAX_INF_RECT as f32, y1: FZ_MAX_INF_RECT as f32,\n};\n\n#[unsafe(no_mangle)]\npub static fz_unit_rect: fz_rect = fz_rect { x0: 0.0, y0: 0.0, x1: 1.0, y1: 1.0 };\n\n#[unsafe(no_mangle)]\npub static fz_empty_irect: fz_irect = fz_irect { x0: 0, y0: 0, x1: 0, y1: 0 };\n\n#[unsafe(no_mangle)]\npub static fz_infinite_irect: fz_irect = fz_irect {\n    x0: FZ_MIN_INF_RECT, y0: FZ_MIN_INF_RECT,\n    x1: FZ_MAX_INF_RECT, y1: FZ_MAX_INF_RECT,\n};\n\n// ============================================================================\n// Matrix functions - Pure safe Rust implementations with FFI export\n// ============================================================================\n\n/// Concatenate two matrices\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_concat(left: fz_matrix, right: fz_matrix) -\u003e fz_matrix {\n    fz_matrix {\n        a: left.a * right.a + left.b * right.c,\n        b: left.a * right.b + left.b * right.d,\n        c: left.c * right.a + left.d * right.c,\n        d: left.c * right.b + left.d * right.d,\n        e: left.e * right.a + left.f * right.c + right.e,\n        f: left.e * right.b + left.f * right.d + right.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_scale(sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_matrix { a: sx, b: 0.0, c: 0.0, d: sy, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_scale(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(fz_scale(sx, sy), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_post_scale(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(m, fz_scale(sx, sy))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_shear(sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_matrix { a: 1.0, b: sy, c: sx, d: 1.0, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_shear(m: fz_matrix, sx: c_float, sy: c_float) -\u003e fz_matrix {\n    fz_concat(fz_shear(sx, sy), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rotate(degrees: c_float) -\u003e fz_matrix {\n    let rad = degrees * std::f32::consts::PI / 180.0;\n    let (s, c) = rad.sin_cos();\n    fz_matrix { a: c, b: s, c: -s, d: c, e: 0.0, f: 0.0 }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_rotate(m: fz_matrix, degrees: c_float) -\u003e fz_matrix {\n    fz_concat(fz_rotate(degrees), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate(tx: c_float, ty: c_float) -\u003e fz_matrix {\n    fz_matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: tx, f: ty }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pre_translate(m: fz_matrix, tx: c_float, ty: c_float) -\u003e fz_matrix {\n    fz_concat(fz_translate(tx, ty), m)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_invert_matrix(m: fz_matrix) -\u003e fz_matrix {\n    let det = m.a * m.d - m.b * m.c;\n    if det.abs() \u003c 1e-6 {\n        return m; // Singular matrix, return original\n    }\n    let rdet = 1.0 / det;\n    fz_matrix {\n        a: m.d * rdet,\n        b: -m.b * rdet,\n        c: -m.c * rdet,\n        d: m.a * rdet,\n        e: (m.c * m.f - m.d * m.e) * rdet,\n        f: (m.b * m.e - m.a * m.f) * rdet,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_matrix_expansion(m: fz_matrix) -\u003e c_float {\n    (m.a.abs() * m.d.abs() - m.b.abs() * m.c.abs()).abs().sqrt()\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_matrix_max_expansion(m: fz_matrix) -\u003e c_float {\n    m.a.abs().max(m.b.abs()).max(m.c.abs()).max(m.d.abs())\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_rectilinear(m: fz_matrix) -\u003e i32 {\n    if (m.b.abs() \u003c 1e-6 \u0026\u0026 m.c.abs() \u003c 1e-6) || (m.a.abs() \u003c 1e-6 \u0026\u0026 m.d.abs() \u003c 1e-6) {\n        1\n    } else {\n        0\n    }\n}\n\n// ============================================================================\n// Rect functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_intersect_rect(a: fz_rect, b: fz_rect) -\u003e fz_rect {\n    fz_rect {\n        x0: a.x0.max(b.x0),\n        y0: a.y0.max(b.y0),\n        x1: a.x1.min(b.x1),\n        y1: a.y1.min(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_intersect_irect(a: fz_irect, b: fz_irect) -\u003e fz_irect {\n    fz_irect {\n        x0: a.x0.max(b.x0),\n        y0: a.y0.max(b.y0),\n        x1: a.x1.min(b.x1),\n        y1: a.y1.min(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_union_rect(a: fz_rect, b: fz_rect) -\u003e fz_rect {\n    fz_rect {\n        x0: a.x0.min(b.x0),\n        y0: a.y0.min(b.y0),\n        x1: a.x1.max(b.x1),\n        y1: a.y1.max(b.y1),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_irect_from_rect(rect: fz_rect) -\u003e fz_irect {\n    fz_irect {\n        x0: rect.x0.floor() as i32,\n        y0: rect.y0.floor() as i32,\n        x1: rect.x1.ceil() as i32,\n        y1: rect.y1.ceil() as i32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_round_rect(rect: fz_rect) -\u003e fz_irect {\n    fz_irect {\n        x0: (rect.x0 + 0.001).floor() as i32,\n        y0: (rect.y0 + 0.001).floor() as i32,\n        x1: (rect.x1 - 0.001).ceil() as i32,\n        y1: (rect.y1 - 0.001).ceil() as i32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rect_from_irect(bbox: fz_irect) -\u003e fz_rect {\n    fz_rect {\n        x0: bbox.x0 as f32,\n        y0: bbox.y0 as f32,\n        x1: bbox.x1 as f32,\n        y1: bbox.y1 as f32,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_expand_rect(r: fz_rect, expand: c_float) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0 - expand,\n        y0: r.y0 - expand,\n        x1: r.x1 + expand,\n        y1: r.y1 + expand,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_expand_irect(r: fz_irect, expand: i32) -\u003e fz_irect {\n    fz_irect {\n        x0: r.x0.saturating_sub(expand),\n        y0: r.y0.saturating_sub(expand),\n        x1: r.x1.saturating_add(expand),\n        y1: r.y1.saturating_add(expand),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_include_point_in_rect(r: fz_rect, p: fz_point) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0.min(p.x),\n        y0: r.y0.min(p.y),\n        x1: r.x1.max(p.x),\n        y1: r.y1.max(p.y),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate_rect(r: fz_rect, xoff: c_float, yoff: c_float) -\u003e fz_rect {\n    fz_rect {\n        x0: r.x0 + xoff,\n        y0: r.y0 + yoff,\n        x1: r.x1 + xoff,\n        y1: r.y1 + yoff,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_translate_irect(r: fz_irect, xoff: i32, yoff: i32) -\u003e fz_irect {\n    fz_irect {\n        x0: r.x0.saturating_add(xoff),\n        y0: r.y0.saturating_add(yoff),\n        x1: r.x1.saturating_add(xoff),\n        y1: r.y1.saturating_add(yoff),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_contains_rect(a: fz_rect, b: fz_rect) -\u003e i32 {\n    i32::from(a.x0 \u003c= b.x0 \u0026\u0026 a.y0 \u003c= b.y0 \u0026\u0026 a.x1 \u003e= b.x1 \u0026\u0026 a.y1 \u003e= b.y1)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_overlaps_rect(a: fz_rect, b: fz_rect) -\u003e i32 {\n    i32::from(a.x0 \u003c b.x1 \u0026\u0026 b.x0 \u003c a.x1 \u0026\u0026 a.y0 \u003c b.y1 \u0026\u0026 b.y0 \u003c a.y1)\n}\n\n// ============================================================================\n// Point/Transform functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_point(p: fz_point, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: p.x * m.a + p.y * m.c + m.e,\n        y: p.x * m.b + p.y * m.d + m.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_point_xy(x: c_float, y: c_float, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: x * m.a + y * m.c + m.e,\n        y: x * m.b + y * m.d + m.f,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_vector(v: fz_point, m: fz_matrix) -\u003e fz_point {\n    fz_point {\n        x: v.x * m.a + v.y * m.c,\n        y: v.x * m.b + v.y * m.d,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_rect(r: fz_rect, m: fz_matrix) -\u003e fz_rect {\n    if fz_is_rectilinear(m) != 0 {\n        let p1 = fz_transform_point(fz_point { x: r.x0, y: r.y0 }, m);\n        let p2 = fz_transform_point(fz_point { x: r.x1, y: r.y1 }, m);\n        fz_rect {\n            x0: p1.x.min(p2.x),\n            y0: p1.y.min(p2.y),\n            x1: p1.x.max(p2.x),\n            y1: p1.y.max(p2.y),\n        }\n    } else {\n        let p1 = fz_transform_point(fz_point { x: r.x0, y: r.y0 }, m);\n        let p2 = fz_transform_point(fz_point { x: r.x1, y: r.y0 }, m);\n        let p3 = fz_transform_point(fz_point { x: r.x0, y: r.y1 }, m);\n        let p4 = fz_transform_point(fz_point { x: r.x1, y: r.y1 }, m);\n        fz_rect {\n            x0: p1.x.min(p2.x).min(p3.x).min(p4.x),\n            y0: p1.y.min(p2.y).min(p3.y).min(p4.y),\n            x1: p1.x.max(p2.x).max(p3.x).max(p4.x),\n            y1: p1.y.max(p2.y).max(p3.y).max(p4.y),\n        }\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_normalize_vector(p: fz_point) -\u003e fz_point {\n    let len = (p.x * p.x + p.y * p.y).sqrt();\n    if len \u003c 1e-6 {\n        return fz_point { x: 0.0, y: 0.0 };\n    }\n    fz_point { x: p.x / len, y: p.y / len }\n}\n\n// ============================================================================\n// Quad functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_quad_from_rect(r: fz_rect) -\u003e fz_quad {\n    fz_quad {\n        ul: fz_point { x: r.x0, y: r.y0 },\n        ur: fz_point { x: r.x1, y: r.y0 },\n        ll: fz_point { x: r.x0, y: r.y1 },\n        lr: fz_point { x: r.x1, y: r.y1 },\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_rect_from_quad(q: fz_quad) -\u003e fz_rect {\n    fz_rect {\n        x0: q.ul.x.min(q.ur.x).min(q.ll.x).min(q.lr.x),\n        y0: q.ul.y.min(q.ur.y).min(q.ll.y).min(q.lr.y),\n        x1: q.ul.x.max(q.ur.x).max(q.ll.x).max(q.lr.x),\n        y1: q.ul.y.max(q.ur.y).max(q.ll.y).max(q.lr.y),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_transform_quad(q: fz_quad, m: fz_matrix) -\u003e fz_quad {\n    fz_quad {\n        ul: fz_transform_point(q.ul, m),\n        ur: fz_transform_point(q.ur, m),\n        ll: fz_transform_point(q.ll, m),\n        lr: fz_transform_point(q.lr, m),\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_point_inside_rect(p: fz_point, r: fz_rect) -\u003e i32 {\n    i32::from(p.x \u003e= r.x0 \u0026\u0026 p.x \u003c r.x1 \u0026\u0026 p.y \u003e= r.y0 \u0026\u0026 p.y \u003c r.y1)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_point_inside_irect(x: i32, y: i32, r: fz_irect) -\u003e i32 {\n    i32::from(x \u003e= r.x0 \u0026\u0026 x \u003c r.x1 \u0026\u0026 y \u003e= r.y0 \u0026\u0026 y \u003c r.y1)\n}\n\n// ============================================================================\n// Version\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_version() -\u003e *const std::ffi::c_char {\n    c\"0.1.0\".as_ptr()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Struct tests\n    #[test]\n    fn test_point_struct() {\n        let p = fz_point { x: 3.5, y: 4.5 };\n        assert_eq!(p.x, 3.5);\n        assert_eq!(p.y, 4.5);\n    }\n\n    #[test]\n    fn test_rect_struct() {\n        let r = fz_rect { x0: 1.0, y0: 2.0, x1: 10.0, y1: 20.0 };\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_irect_struct() {\n        let r = fz_irect { x0: 1, y0: 2, x1: 10, y1: 20 };\n        assert_eq!(r.x0, 1);\n        assert_eq!(r.y0, 2);\n        assert_eq!(r.x1, 10);\n        assert_eq!(r.y1, 20);\n    }\n\n    #[test]\n    fn test_irect_from_rect() {\n        let r = fz_rect { x0: 0.5, y0: 1.5, x1: 9.5, y1: 19.5 };\n        let ir = fz_irect_from_rect(r);\n        assert_eq!(ir.x0, 0);\n        assert_eq!(ir.y0, 1);\n        assert_eq!(ir.x1, 10);\n        assert_eq!(ir.y1, 20);\n    }\n\n    #[test]\n    fn test_round_rect() {\n        let r = fz_rect { x0: 0.2, y0: 1.8, x1: 9.3, y1: 19.7 };\n        let ir = fz_round_rect(r);\n        // round_rect should round correctly\n        assert!(ir.x0 \u003e= 0);\n        assert!(ir.x1 \u003e= 9);\n    }\n\n    #[test]\n    fn test_rect_from_irect() {\n        let ir = fz_irect { x0: 1, y0: 2, x1: 10, y1: 20 };\n        let r = fz_rect_from_irect(ir);\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    // Matrix tests\n    #[test]\n    fn test_matrix_identity() {\n        let m = fz_matrix::identity();\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.b, 0.0);\n        assert_eq!(m.c, 0.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_matrix_struct() {\n        let m = fz_matrix { a: 1.0, b: 2.0, c: 3.0, d: 4.0, e: 5.0, f: 6.0 };\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 2.0);\n        assert_eq!(m.c, 3.0);\n        assert_eq!(m.d, 4.0);\n        assert_eq!(m.e, 5.0);\n        assert_eq!(m.f, 6.0);\n    }\n\n    #[test]\n    fn test_translate() {\n        let m = fz_translate(10.0, 20.0);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.e, 10.0);\n        assert_eq!(m.f, 20.0);\n    }\n\n    #[test]\n    fn test_scale() {\n        let m = fz_scale(2.0, 3.0);\n        assert_eq!(m.a, 2.0);\n        assert_eq!(m.d, 3.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_rotate() {\n        let m = fz_rotate(90.0);\n        assert!((m.a - 0.0).abs() \u003c 0.001);\n        assert!((m.b - 1.0).abs() \u003c 0.001);\n        assert!((m.c - (-1.0)).abs() \u003c 0.001);\n        assert!((m.d - 0.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_shear() {\n        let m = fz_shear(0.5, 0.5);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 0.5);\n        assert_eq!(m.c, 0.5);\n        assert_eq!(m.d, 1.0);\n    }\n\n    #[test]\n    fn test_pre_translate() {\n        let m = fz_scale(2.0, 2.0);\n        let result = fz_pre_translate(m, 10.0, 10.0);\n        // Pre-translate: scale first, then translate\n        assert_eq!(result.e, 20.0);\n        assert_eq!(result.f, 20.0);\n    }\n\n    #[test]\n    fn test_pre_scale() {\n        let m = fz_translate(10.0, 10.0);\n        let result = fz_pre_scale(m, 2.0, 2.0);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 2.0);\n    }\n\n    #[test]\n    fn test_post_scale() {\n        let m = fz_translate(10.0, 10.0);\n        let result = fz_post_scale(m, 2.0, 2.0);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 2.0);\n    }\n\n    #[test]\n    fn test_pre_rotate() {\n        let m = fz_matrix::identity();\n        let result = fz_pre_rotate(m, 90.0);\n        assert!((result.b - 1.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_pre_shear() {\n        let m = fz_matrix::identity();\n        let result = fz_pre_shear(m, 0.5, 0.5);\n        assert_eq!(result.b, 0.5);\n        assert_eq!(result.c, 0.5);\n    }\n\n    #[test]\n    fn test_matrix_concat() {\n        let m1 = fz_translate(10.0, 20.0);\n        let m2 = fz_scale(2.0, 2.0);\n        let m3 = fz_concat(m1, m2);\n\n        let p = fz_point { x: 0.0, y: 0.0 };\n        let result = fz_transform_point(p, m3);\n        assert_eq!(result.x, 20.0);\n        assert_eq!(result.y, 40.0);\n    }\n\n    #[test]\n    fn test_invert_matrix() {\n        let m = fz_scale(2.0, 2.0);\n        let inv = fz_invert_matrix(m);\n        // Inverse of scale(2,2) should be scale(0.5, 0.5)\n        assert!((inv.a - 0.5).abs() \u003c 0.001);\n        assert!((inv.d - 0.5).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_matrix_expansion() {\n        let m = fz_scale(2.0, 3.0);\n        let exp = fz_matrix_expansion(m);\n        // Geometric mean of scale factors\n        assert!(exp \u003e 2.0);\n        assert!(exp \u003c 3.0);\n    }\n\n    #[test]\n    fn test_matrix_max_expansion() {\n        let m = fz_scale(2.0, 3.0);\n        let max_exp = fz_matrix_max_expansion(m);\n        assert_eq!(max_exp, 3.0);\n    }\n\n    #[test]\n    fn test_is_rectilinear() {\n        let identity = fz_matrix::identity();\n        let rotated = fz_rotate(45.0);\n        assert_eq!(fz_is_rectilinear(identity), 1);\n        assert_eq!(fz_is_rectilinear(rotated), 0);\n    }\n\n    // Transform tests\n    #[test]\n    fn test_transform_point() {\n        let m = fz_translate(10.0, 20.0);\n        let p = fz_point { x: 5.0, y: 5.0 };\n        let result = fz_transform_point(p, m);\n        assert_eq!(result.x, 15.0);\n        assert_eq!(result.y, 25.0);\n    }\n\n    #[test]\n    fn test_transform_point_xy() {\n        let m = fz_translate(10.0, 20.0);\n        let result = fz_transform_point_xy(5.0, 5.0, m);\n        assert_eq!(result.x, 15.0);\n        assert_eq!(result.y, 25.0);\n    }\n\n    #[test]\n    fn test_transform_vector() {\n        let m = fz_translate(10.0, 20.0);\n        let v = fz_point { x: 5.0, y: 5.0 };\n        // Vector transform ignores translation\n        let result = fz_transform_vector(v, m);\n        assert_eq!(result.x, 5.0);\n        assert_eq!(result.y, 5.0);\n    }\n\n    #[test]\n    fn test_transform_rect() {\n        let m = fz_scale(2.0, 2.0);\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let result = fz_transform_rect(r, m);\n        assert_eq!(result.x0, 0.0);\n        assert_eq!(result.y0, 0.0);\n        assert_eq!(result.x1, 20.0);\n        assert_eq!(result.y1, 20.0);\n    }\n\n    #[test]\n    fn test_normalize_vector() {\n        let p = fz_point { x: 3.0, y: 4.0 };\n        let result = fz_normalize_vector(p);\n        // Length should be 1\n        let len = (result.x * result.x + result.y * result.y).sqrt();\n        assert!((len - 1.0).abs() \u003c 0.001);\n    }\n\n    // Rect operations tests\n    #[test]\n    fn test_rect_operations() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let r2 = fz_rect { x0: 50.0, y0: 50.0, x1: 150.0, y1: 150.0 };\n\n        let intersection = fz_intersect_rect(r1, r2);\n        assert_eq!(intersection.x0, 50.0);\n        assert_eq!(intersection.y0, 50.0);\n        assert_eq!(intersection.x1, 100.0);\n        assert_eq!(intersection.y1, 100.0);\n\n        let union = fz_union_rect(r1, r2);\n        assert_eq!(union.x0, 0.0);\n        assert_eq!(union.y0, 0.0);\n        assert_eq!(union.x1, 150.0);\n        assert_eq!(union.y1, 150.0);\n    }\n\n    #[test]\n    fn test_intersect_irect() {\n        let r1 = fz_irect { x0: 0, y0: 0, x1: 100, y1: 100 };\n        let r2 = fz_irect { x0: 50, y0: 50, x1: 150, y1: 150 };\n        let result = fz_intersect_irect(r1, r2);\n        assert_eq!(result.x0, 50);\n        assert_eq!(result.y0, 50);\n        assert_eq!(result.x1, 100);\n        assert_eq!(result.y1, 100);\n    }\n\n    #[test]\n    fn test_expand_rect() {\n        let r = fz_rect { x0: 10.0, y0: 10.0, x1: 20.0, y1: 20.0 };\n        let expanded = fz_expand_rect(r, 5.0);\n        assert_eq!(expanded.x0, 5.0);\n        assert_eq!(expanded.y0, 5.0);\n        assert_eq!(expanded.x1, 25.0);\n        assert_eq!(expanded.y1, 25.0);\n    }\n\n    #[test]\n    fn test_expand_irect() {\n        let r = fz_irect { x0: 10, y0: 10, x1: 20, y1: 20 };\n        let expanded = fz_expand_irect(r, 5);\n        assert_eq!(expanded.x0, 5);\n        assert_eq!(expanded.y0, 5);\n        assert_eq!(expanded.x1, 25);\n        assert_eq!(expanded.y1, 25);\n    }\n\n    #[test]\n    fn test_include_point_in_rect() {\n        let r = fz_rect { x0: 10.0, y0: 10.0, x1: 20.0, y1: 20.0 };\n        let p = fz_point { x: 0.0, y: 30.0 };\n        let result = fz_include_point_in_rect(r, p);\n        assert_eq!(result.x0, 0.0);\n        assert_eq!(result.y0, 10.0);\n        assert_eq!(result.x1, 20.0);\n        assert_eq!(result.y1, 30.0);\n    }\n\n    #[test]\n    fn test_translate_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let result = fz_translate_rect(r, 5.0, 5.0);\n        assert_eq!(result.x0, 5.0);\n        assert_eq!(result.y0, 5.0);\n        assert_eq!(result.x1, 15.0);\n        assert_eq!(result.y1, 15.0);\n    }\n\n    #[test]\n    fn test_translate_irect() {\n        let r = fz_irect { x0: 0, y0: 0, x1: 10, y1: 10 };\n        let result = fz_translate_irect(r, 5, 5);\n        assert_eq!(result.x0, 5);\n        assert_eq!(result.y0, 5);\n        assert_eq!(result.x1, 15);\n        assert_eq!(result.y1, 15);\n    }\n\n    #[test]\n    fn test_contains_rect() {\n        let outer = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let inner = fz_rect { x0: 10.0, y0: 10.0, x1: 50.0, y1: 50.0 };\n        let outside = fz_rect { x0: 200.0, y0: 200.0, x1: 300.0, y1: 300.0 };\n\n        assert_eq!(fz_contains_rect(outer, inner), 1);\n        assert_eq!(fz_contains_rect(outer, outside), 0);\n    }\n\n    #[test]\n    fn test_overlaps_rect() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 50.0, y1: 50.0 };\n        let r2 = fz_rect { x0: 25.0, y0: 25.0, x1: 75.0, y1: 75.0 };\n        let r3 = fz_rect { x0: 100.0, y0: 100.0, x1: 150.0, y1: 150.0 };\n\n        assert_eq!(fz_overlaps_rect(r1, r2), 1);\n        assert_eq!(fz_overlaps_rect(r1, r3), 0);\n    }\n\n    // Quad tests\n    #[test]\n    fn test_quad_from_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 20.0 };\n        let q = fz_quad_from_rect(r);\n        assert_eq!(q.ul.x, 0.0);\n        assert_eq!(q.ul.y, 0.0);\n        assert_eq!(q.ur.x, 10.0);\n        assert_eq!(q.ur.y, 0.0);\n        assert_eq!(q.ll.x, 0.0);\n        assert_eq!(q.ll.y, 20.0);\n        assert_eq!(q.lr.x, 10.0);\n        assert_eq!(q.lr.y, 20.0);\n    }\n\n    #[test]\n    fn test_rect_from_quad() {\n        let q = fz_quad {\n            ul: fz_point { x: 0.0, y: 0.0 },\n            ur: fz_point { x: 10.0, y: 0.0 },\n            ll: fz_point { x: 0.0, y: 20.0 },\n            lr: fz_point { x: 10.0, y: 20.0 },\n        };\n        let r = fz_rect_from_quad(q);\n        assert_eq!(r.x0, 0.0);\n        assert_eq!(r.y0, 0.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_transform_quad() {\n        let q = fz_quad {\n            ul: fz_point { x: 0.0, y: 0.0 },\n            ur: fz_point { x: 10.0, y: 0.0 },\n            ll: fz_point { x: 0.0, y: 10.0 },\n            lr: fz_point { x: 10.0, y: 10.0 },\n        };\n        let m = fz_translate(5.0, 5.0);\n        let result = fz_transform_quad(q, m);\n        assert_eq!(result.ul.x, 5.0);\n        assert_eq!(result.ul.y, 5.0);\n        assert_eq!(result.lr.x, 15.0);\n        assert_eq!(result.lr.y, 15.0);\n    }\n\n    // Point inside tests\n    #[test]\n    fn test_is_point_inside_rect() {\n        let r = fz_rect { x0: 0.0, y0: 0.0, x1: 10.0, y1: 10.0 };\n        let inside = fz_point { x: 5.0, y: 5.0 };\n        let outside = fz_point { x: 15.0, y: 15.0 };\n        assert_eq!(fz_is_point_inside_rect(inside, r), 1);\n        assert_eq!(fz_is_point_inside_rect(outside, r), 0);\n    }\n\n    #[test]\n    fn test_is_point_inside_irect() {\n        let r = fz_irect { x0: 0, y0: 0, x1: 10, y1: 10 };\n        assert_eq!(fz_is_point_inside_irect(5, 5, r), 1);\n        assert_eq!(fz_is_point_inside_irect(15, 15, r), 0);\n    }\n\n    // Static values tests\n    #[test]\n    fn test_static_values() {\n        assert_eq!(fz_identity.a, 1.0);\n        assert_eq!(fz_identity.d, 1.0);\n\n        // Empty rect uses infinity\n        assert!(fz_empty_rect.x0.is_infinite());\n        assert_eq!(fz_unit_rect.x1, 1.0);\n    }\n\n    // Version test\n    #[test]\n    fn test_version() {\n        let version = fz_version();\n        assert!(!version.is_null());\n    }\n}\n","traces":[{"line":51,"address":[1471472],"length":1,"stats":{"Line":0}},{"line":52,"address":[2259224],"length":1,"stats":{"Line":0}},{"line":57,"address":[1471504],"length":1,"stats":{"Line":3}},{"line":111,"address":[1471568],"length":1,"stats":{"Line":1}},{"line":113,"address":[1471581],"length":1,"stats":{"Line":1}},{"line":114,"address":[1471603],"length":1,"stats":{"Line":2}},{"line":115,"address":[1471626],"length":1,"stats":{"Line":2}},{"line":116,"address":[2259393],"length":1,"stats":{"Line":2}},{"line":117,"address":[1471673],"length":1,"stats":{"Line":3}},{"line":118,"address":[1471701],"length":1,"stats":{"Line":6}},{"line":123,"address":[1471760],"length":1,"stats":{"Line":2}},{"line":128,"address":[1471824],"length":1,"stats":{"Line":1}},{"line":129,"address":[1471866],"length":1,"stats":{"Line":1}},{"line":133,"address":[1472000],"length":1,"stats":{"Line":1}},{"line":134,"address":[1472042],"length":1,"stats":{"Line":1}},{"line":138,"address":[1472176],"length":1,"stats":{"Line":1}},{"line":143,"address":[1472256],"length":1,"stats":{"Line":1}},{"line":144,"address":[1472298],"length":1,"stats":{"Line":1}},{"line":148,"address":[1472500,1472432],"length":1,"stats":{"Line":1}},{"line":149,"address":[1472459],"length":1,"stats":{"Line":1}},{"line":150,"address":[1472527,1472481],"length":1,"stats":{"Line":2}},{"line":151,"address":[2260283],"length":1,"stats":{"Line":2}},{"line":155,"address":[1472608],"length":1,"stats":{"Line":1}},{"line":156,"address":[1472644],"length":1,"stats":{"Line":1}},{"line":160,"address":[1472784],"length":1,"stats":{"Line":2}},{"line":165,"address":[1472864],"length":1,"stats":{"Line":1}},{"line":166,"address":[1472906],"length":1,"stats":{"Line":1}},{"line":170,"address":[2260784,2260864],"length":1,"stats":{"Line":1}},{"line":171,"address":[1473064],"length":1,"stats":{"Line":1}},{"line":172,"address":[1473132,1473107],"length":1,"stats":{"Line":2}},{"line":173,"address":[1473346],"length":1,"stats":{"Line":0}},{"line":175,"address":[1473165],"length":1,"stats":{"Line":1}},{"line":177,"address":[1473189],"length":1,"stats":{"Line":1}},{"line":178,"address":[2260941],"length":1,"stats":{"Line":1}},{"line":179,"address":[1473220],"length":1,"stats":{"Line":1}},{"line":180,"address":[2260987],"length":1,"stats":{"Line":1}},{"line":181,"address":[1473250],"length":1,"stats":{"Line":1}},{"line":182,"address":[1473278],"length":1,"stats":{"Line":1}},{"line":187,"address":[1473392,1473423],"length":1,"stats":{"Line":1}},{"line":188,"address":[1473434,1473406],"length":1,"stats":{"Line":2}},{"line":192,"address":[1473631,1473600],"length":1,"stats":{"Line":1}},{"line":193,"address":[1473614,1473642],"length":1,"stats":{"Line":2}},{"line":197,"address":[1473792,1473824],"length":1,"stats":{"Line":1}},{"line":198,"address":[1473921,1473836,1473950,1473806],"length":1,"stats":{"Line":4}},{"line":199,"address":[2261657],"length":1,"stats":{"Line":1}},{"line":201,"address":[1473942],"length":1,"stats":{"Line":1}},{"line":210,"address":[1474089,1474016],"length":1,"stats":{"Line":2}},{"line":212,"address":[1474064],"length":1,"stats":{"Line":2}},{"line":213,"address":[2261839],"length":1,"stats":{"Line":2}},{"line":214,"address":[1474120],"length":1,"stats":{"Line":2}},{"line":215,"address":[1474145],"length":1,"stats":{"Line":2}},{"line":220,"address":[1474307,1474240],"length":1,"stats":{"Line":1}},{"line":222,"address":[1474284],"length":1,"stats":{"Line":1}},{"line":223,"address":[1474313],"length":1,"stats":{"Line":1}},{"line":224,"address":[1474336],"length":1,"stats":{"Line":1}},{"line":225,"address":[1474359],"length":1,"stats":{"Line":1}},{"line":230,"address":[1474505,1474432],"length":1,"stats":{"Line":2}},{"line":232,"address":[1474480],"length":1,"stats":{"Line":2}},{"line":233,"address":[1474511],"length":1,"stats":{"Line":2}},{"line":234,"address":[1474536],"length":1,"stats":{"Line":2}},{"line":235,"address":[1474561],"length":1,"stats":{"Line":2}},{"line":240,"address":[2262400,2262445],"length":1,"stats":{"Line":1}},{"line":242,"address":[1474682,1474713],"length":1,"stats":{"Line":2}},{"line":243,"address":[1474748],"length":1,"stats":{"Line":1}},{"line":244,"address":[1474808],"length":1,"stats":{"Line":1}},{"line":245,"address":[1474868],"length":1,"stats":{"Line":1}},{"line":250,"address":[1474976,1475033],"length":1,"stats":{"Line":1}},{"line":252,"address":[1475002,1475045],"length":1,"stats":{"Line":2}},{"line":253,"address":[1475080],"length":1,"stats":{"Line":1}},{"line":254,"address":[2262896],"length":1,"stats":{"Line":1}},{"line":255,"address":[1475224],"length":1,"stats":{"Line":1}},{"line":260,"address":[1475344],"length":1,"stats":{"Line":1}},{"line":262,"address":[1475364],"length":1,"stats":{"Line":1}},{"line":263,"address":[1475370],"length":1,"stats":{"Line":1}},{"line":264,"address":[1475376],"length":1,"stats":{"Line":1}},{"line":265,"address":[1475382],"length":1,"stats":{"Line":1}},{"line":270,"address":[1475440],"length":1,"stats":{"Line":1}},{"line":272,"address":[1475471,1475483],"length":1,"stats":{"Line":2}},{"line":273,"address":[1475477,1475487],"length":1,"stats":{"Line":2}},{"line":274,"address":[1475491],"length":1,"stats":{"Line":1}},{"line":275,"address":[1475501],"length":1,"stats":{"Line":1}},{"line":280,"address":[1475552,1475606],"length":1,"stats":{"Line":1}},{"line":282,"address":[2263335],"length":1,"stats":{"Line":1}},{"line":283,"address":[1475616],"length":1,"stats":{"Line":1}},{"line":284,"address":[1475635],"length":1,"stats":{"Line":1}},{"line":285,"address":[2263398],"length":1,"stats":{"Line":1}},{"line":290,"address":[2263539,2263472],"length":1,"stats":{"Line":1}},{"line":292,"address":[1475770],"length":1,"stats":{"Line":1}},{"line":293,"address":[2263545],"length":1,"stats":{"Line":1}},{"line":294,"address":[1475826],"length":1,"stats":{"Line":1}},{"line":295,"address":[2263595],"length":1,"stats":{"Line":1}},{"line":300,"address":[1475952],"length":1,"stats":{"Line":1}},{"line":302,"address":[1476004,1476016],"length":1,"stats":{"Line":2}},{"line":303,"address":[2263754,2263764],"length":1,"stats":{"Line":2}},{"line":304,"address":[2263768],"length":1,"stats":{"Line":1}},{"line":305,"address":[1476034],"length":1,"stats":{"Line":1}},{"line":310,"address":[1476096,1476158],"length":1,"stats":{"Line":1}},{"line":312,"address":[1476143],"length":1,"stats":{"Line":1}},{"line":313,"address":[1476168],"length":1,"stats":{"Line":1}},{"line":314,"address":[2263931],"length":1,"stats":{"Line":1}},{"line":315,"address":[2263950],"length":1,"stats":{"Line":1}},{"line":320,"address":[1476272,1476420],"length":1,"stats":{"Line":2}},{"line":321,"address":[1476330],"length":1,"stats":{"Line":2}},{"line":325,"address":[1476448,1476604],"length":1,"stats":{"Line":1}},{"line":326,"address":[1476506],"length":1,"stats":{"Line":1}},{"line":334,"address":[1476624],"length":1,"stats":{"Line":2}},{"line":336,"address":[1476645],"length":1,"stats":{"Line":2}},{"line":337,"address":[2264419],"length":1,"stats":{"Line":2}},{"line":342,"address":[2264480],"length":1,"stats":{"Line":1}},{"line":344,"address":[2264500],"length":1,"stats":{"Line":1}},{"line":345,"address":[1476780],"length":1,"stats":{"Line":1}},{"line":350,"address":[1476832],"length":1,"stats":{"Line":1}},{"line":352,"address":[2264597],"length":1,"stats":{"Line":1}},{"line":353,"address":[2264622],"length":1,"stats":{"Line":1}},{"line":358,"address":[2266074,2264672],"length":1,"stats":{"Line":1}},{"line":359,"address":[2264745,2266594],"length":1,"stats":{"Line":2}},{"line":360,"address":[2265665],"length":1,"stats":{"Line":1}},{"line":361,"address":[2265861],"length":1,"stats":{"Line":1}},{"line":363,"address":[2266058],"length":1,"stats":{"Line":1}},{"line":364,"address":[2266471],"length":1,"stats":{"Line":1}},{"line":365,"address":[1478806],"length":1,"stats":{"Line":1}},{"line":366,"address":[1478831],"length":1,"stats":{"Line":1}},{"line":369,"address":[2264835],"length":1,"stats":{"Line":0}},{"line":370,"address":[2265034],"length":1,"stats":{"Line":0}},{"line":371,"address":[2265230],"length":1,"stats":{"Line":0}},{"line":372,"address":[1477710],"length":1,"stats":{"Line":0}},{"line":374,"address":[2265638,2266095],"length":1,"stats":{"Line":0}},{"line":375,"address":[1478446],"length":1,"stats":{"Line":0}},{"line":376,"address":[2266229],"length":1,"stats":{"Line":0}},{"line":377,"address":[1478614],"length":1,"stats":{"Line":0}},{"line":383,"address":[2266665,2266608],"length":1,"stats":{"Line":1}},{"line":384,"address":[2266677,2266628],"length":1,"stats":{"Line":2}},{"line":385,"address":[1478987],"length":1,"stats":{"Line":1}},{"line":386,"address":[2266736],"length":1,"stats":{"Line":0}},{"line":388,"address":[1479006],"length":1,"stats":{"Line":1}},{"line":396,"address":[1479072],"length":1,"stats":{"Line":2}},{"line":398,"address":[1479107],"length":1,"stats":{"Line":2}},{"line":399,"address":[1479119],"length":1,"stats":{"Line":2}},{"line":400,"address":[2266827],"length":1,"stats":{"Line":2}},{"line":401,"address":[1479143],"length":1,"stats":{"Line":2}},{"line":406,"address":[1479236,1479200],"length":1,"stats":{"Line":2}},{"line":408,"address":[1479253,1479214],"length":1,"stats":{"Line":4}},{"line":409,"address":[1479305],"length":1,"stats":{"Line":2}},{"line":410,"address":[1479391],"length":1,"stats":{"Line":2}},{"line":411,"address":[1479476],"length":1,"stats":{"Line":2}},{"line":416,"address":[1479632],"length":1,"stats":{"Line":1}},{"line":418,"address":[1479675],"length":1,"stats":{"Line":1}},{"line":419,"address":[1479839],"length":1,"stats":{"Line":1}},{"line":420,"address":[2267725],"length":1,"stats":{"Line":1}},{"line":421,"address":[1480223],"length":1,"stats":{"Line":1}},{"line":426,"address":[1480496,1480638],"length":1,"stats":{"Line":1}},{"line":427,"address":[1480548],"length":1,"stats":{"Line":1}},{"line":431,"address":[1480772,1480656],"length":1,"stats":{"Line":1}},{"line":432,"address":[1480706],"length":1,"stats":{"Line":1}},{"line":440,"address":[1480800,1480824],"length":1,"stats":{"Line":1}},{"line":441,"address":[1480801],"length":1,"stats":{"Line":1}}],"covered":144,"coverable":156},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","mod.rs"],"content":"//! C FFI Module - MuPDF API Compatible Exports\n//!\n//! This module provides C-compatible exports that match MuPDF's API.\n//! Uses safe Rust patterns with handle-based resource management.\n\npub mod geometry;\npub mod context;\npub mod buffer;\npub mod stream;\npub mod colorspace;\npub mod pixmap;\npub mod document;\npub mod pdf_object;\n\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex, atomic::{AtomicU64, Ordering}};\n\n/// Global handle manager for safe FFI resource management\nstatic HANDLE_COUNTER: AtomicU64 = AtomicU64::new(1);\n\n/// Type alias for handles\npub type Handle = u64;\n\n/// Generate a new unique handle\npub fn new_handle() -\u003e Handle {\n    HANDLE_COUNTER.fetch_add(1, Ordering::SeqCst)\n}\n\n/// Thread-safe handle storage for a specific type\npub struct HandleStore\u003cT\u003e {\n    store: Mutex\u003cHashMap\u003cHandle, Arc\u003cMutex\u003cT\u003e\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e HandleStore\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self {\n            store: Mutex::new(HashMap::new()),\n        }\n    }\n\n    pub fn insert(\u0026self, value: T) -\u003e Handle {\n        let handle = new_handle();\n        let mut store = self.store.lock().unwrap();\n        store.insert(handle, Arc::new(Mutex::new(value)));\n        handle\n    }\n\n    pub fn get(\u0026self, handle: Handle) -\u003e Option\u003cArc\u003cMutex\u003cT\u003e\u003e\u003e {\n        let store = self.store.lock().unwrap();\n        store.get(\u0026handle).cloned()\n    }\n\n    pub fn remove(\u0026self, handle: Handle) -\u003e Option\u003cArc\u003cMutex\u003cT\u003e\u003e\u003e {\n        let mut store = self.store.lock().unwrap();\n        store.remove(\u0026handle)\n    }\n\n    pub fn keep(\u0026self, handle: Handle) -\u003e Handle {\n        // For reference counting, we just return the same handle\n        // The Arc inside handles ref counting automatically\n        handle\n    }\n}\n\nimpl\u003cT\u003e Default for HandleStore\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// Lazy initialization for handle stores\nuse std::sync::LazyLock;\n\npub static CONTEXTS: LazyLock\u003cHandleStore\u003ccontext::Context\u003e\u003e = LazyLock::new(HandleStore::new);\npub static BUFFERS: LazyLock\u003cHandleStore\u003cbuffer::Buffer\u003e\u003e = LazyLock::new(HandleStore::new);\npub static STREAMS: LazyLock\u003cHandleStore\u003cstream::Stream\u003e\u003e = LazyLock::new(HandleStore::new);\npub static PIXMAPS: LazyLock\u003cHandleStore\u003cpixmap::Pixmap\u003e\u003e = LazyLock::new(HandleStore::new);\npub static DOCUMENTS: LazyLock\u003cHandleStore\u003cdocument::Document\u003e\u003e = LazyLock::new(HandleStore::new);\n","traces":[{"line":25,"address":[1983040],"length":1,"stats":{"Line":6}},{"line":26,"address":[1671953],"length":1,"stats":{"Line":8}},{"line":35,"address":[1672768,1673088,1672688,1672848,1672928,1673008],"length":1,"stats":{"Line":10}},{"line":37,"address":[1672941,1672701,1672861,1673101,1673021,1672781],"length":1,"stats":{"Line":10}},{"line":41,"address":[1674521,1673605,1675433,1673168,1674096,1675008,1673648,1675895,1674560,1675472,1674973,1674059],"length":1,"stats":{"Line":32}},{"line":42,"address":[1673193,1674585,1673756,1674204,1675580,1673276,1675116,1674121,1675033,1673673,1674668,1675497],"length":1,"stats":{"Line":81}},{"line":43,"address":[1674676,1675588,1673284,1675124,1674212,1673764],"length":1,"stats":{"Line":40}},{"line":44,"address":[1675259,1675192,1675723,1674347,1674811,1673832,1674744,1673419,1673352,1675656,1673899,1674280],"length":1,"stats":{"Line":20}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[1675936,1676549,1676751,1676335,1676133,1676127,1676352,1676341,1676959,1677173,1676965,1676543,1676768,1676560,1676144,1677167,1676976,1676757],"length":1,"stats":{"Line":17}},{"line":49,"address":[1676372,1676996,1675956,1676164,1676580,1676788],"length":1,"stats":{"Line":18}},{"line":50,"address":[1676008,1676216,1676840,1676632,1676898,1676424,1676274,1677106,1676482,1677048,1676690,1676066],"length":1,"stats":{"Line":18}},{"line":53,"address":[1677376,1678322,1677746,1678144,1677932,1677740,1677184,1677760,1678316,1677568,1677952,1678130,1677554,1677548,1677938,1678124,1677362,1677356],"length":1,"stats":{"Line":27}},{"line":54,"address":[1677972,1677204,1678164,1677396,1677588,1677780],"length":1,"stats":{"Line":34}},{"line":55,"address":[1677448,1677256,1678274,1677698,1677890,1678216,1677314,1677640,1677506,1678024,1677832,1678082],"length":1,"stats":{"Line":20}},{"line":58,"address":[1678384,1678368,1678352,1678336],"length":1,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[1678400],"length":1,"stats":{"Line":1}},{"line":67,"address":[1678408],"length":1,"stats":{"Line":1}},{"line":74,"address":[11599984],"length":1,"stats":{"Line":0}},{"line":75,"address":[11600002],"length":1,"stats":{"Line":0}},{"line":76,"address":[11600032],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":22},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","pdf_object.rs"],"content":"//! PDF Object FFI - MuPDF API Compatible Exports\n//!\n//! This module provides C-compatible exports for PDF object manipulation.\n\nuse std::ffi::{c_char, CStr, CString};\nuse std::sync::{LazyLock, Mutex};\n\nuse super::{Handle, HandleStore};\n\n// ============================================================================\n// PDF Object Types\n// ============================================================================\n\n/// PDF Object type enumeration\n#[derive(Debug, Clone)]\npub enum PdfObjType {\n    Null,\n    Bool(bool),\n    Int(i64),\n    Real(f64),\n    Name(String),\n    String(Vec\u003cu8\u003e),\n    Array(Vec\u003cPdfObj\u003e),\n    Dict(Vec\u003c(String, PdfObj)\u003e),\n    Indirect { num: i32, generation: i32 },\n    Stream { dict: Box\u003cPdfObj\u003e, data: Vec\u003cu8\u003e },\n}\n\nimpl PdfObjType {\n    /// Compare two object types for equality (shallow comparison)\n    pub fn shallow_eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (PdfObjType::Null, PdfObjType::Null) =\u003e true,\n            (PdfObjType::Bool(a), PdfObjType::Bool(b)) =\u003e a == b,\n            (PdfObjType::Int(a), PdfObjType::Int(b)) =\u003e a == b,\n            (PdfObjType::Real(a), PdfObjType::Real(b)) =\u003e (a - b).abs() \u003c f64::EPSILON,\n            (PdfObjType::Name(a), PdfObjType::Name(b)) =\u003e a == b,\n            (PdfObjType::String(a), PdfObjType::String(b)) =\u003e a == b,\n            (PdfObjType::Array(a), PdfObjType::Array(b)) =\u003e a.len() == b.len(),\n            (PdfObjType::Dict(a), PdfObjType::Dict(b)) =\u003e a.len() == b.len(),\n            (PdfObjType::Indirect { num: n1, generation: g1 }, PdfObjType::Indirect { num: n2, generation: g2 }) =\u003e {\n                n1 == n2 \u0026\u0026 g1 == g2\n            }\n            (PdfObjType::Stream { .. }, PdfObjType::Stream { .. }) =\u003e false, // Streams never match\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Internal PDF object representation\n#[derive(Debug, Clone)]\npub struct PdfObj {\n    pub obj_type: PdfObjType,\n    pub marked: bool,\n    pub dirty: bool,\n    pub parent_num: i32,\n    pub refs: i32,\n}\n\nimpl PdfObj {\n    pub fn new_null() -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Null,\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_bool(b: bool) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Bool(b),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_int(i: i64) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Int(i),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_real(f: f64) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Real(f),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_name(s: \u0026str) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Name(s.to_string()),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_string(data: \u0026[u8]) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::String(data.to_vec()),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_array(cap: usize) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Array(Vec::with_capacity(cap)),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_dict(cap: usize) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Dict(Vec::with_capacity(cap)),\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n\n    pub fn new_indirect(num: i32, generation: i32) -\u003e Self {\n        Self {\n            obj_type: PdfObjType::Indirect { num, generation },\n            marked: false,\n            dirty: false,\n            parent_num: 0,\n            refs: 1,\n        }\n    }\n}\n\n/// Handle type for PDF objects\npub type PdfObjHandle = Handle;\n\n/// Global PDF object storage\npub static PDF_OBJECTS: LazyLock\u003cHandleStore\u003cPdfObj\u003e\u003e = LazyLock::new(HandleStore::default);\n\n// ============================================================================\n// PDF Object Creation Functions\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_null(_ctx: Handle) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_null())\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_bool(_ctx: Handle, b: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_bool(b != 0))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_int(_ctx: Handle, i: i64) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_int(i))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_real(_ctx: Handle, f: f32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_real(f as f64))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_name(_ctx: Handle, str: *const c_char) -\u003e PdfObjHandle {\n    if str.is_null() {\n        return PDF_OBJECTS.insert(PdfObj::new_name(\"\"));\n    }\n    #[allow(unsafe_code)]\n    let name = unsafe { CStr::from_ptr(str) }\n        .to_str()\n        .unwrap_or(\"\");\n    PDF_OBJECTS.insert(PdfObj::new_name(name))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_string(_ctx: Handle, str: *const c_char, len: usize) -\u003e PdfObjHandle {\n    if str.is_null() || len == 0 {\n        return PDF_OBJECTS.insert(PdfObj::new_string(\u0026[]));\n    }\n    #[allow(unsafe_code)]\n    let data = unsafe { std::slice::from_raw_parts(str as *const u8, len) };\n    PDF_OBJECTS.insert(PdfObj::new_string(data))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_text_string(_ctx: Handle, s: *const c_char) -\u003e PdfObjHandle {\n    if s.is_null() {\n        return PDF_OBJECTS.insert(PdfObj::new_string(\u0026[]));\n    }\n    #[allow(unsafe_code)]\n    let text = unsafe { CStr::from_ptr(s) }\n        .to_str()\n        .unwrap_or(\"\");\n    PDF_OBJECTS.insert(PdfObj::new_string(text.as_bytes()))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_indirect(_ctx: Handle, _doc: Handle, num: i32, generation: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_indirect(num, generation))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_array(_ctx: Handle, _doc: Handle, initialcap: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_array(initialcap.max(0) as usize))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_new_dict(_ctx: Handle, _doc: Handle, initialcap: i32) -\u003e PdfObjHandle {\n    PDF_OBJECTS.insert(PdfObj::new_dict(initialcap.max(0) as usize))\n}\n\n// ============================================================================\n// PDF Object Reference Counting\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_keep_obj(_ctx: Handle, obj: PdfObjHandle) -\u003e PdfObjHandle {\n    if let Some(arc) = PDF_OBJECTS.get(obj) {\n        if let Ok(mut guard) = arc.lock() {\n            guard.refs += 1;\n        }\n    }\n    obj\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_drop_obj(_ctx: Handle, obj: PdfObjHandle) {\n    if let Some(arc) = PDF_OBJECTS.get(obj) {\n        let should_remove = {\n            if let Ok(mut guard) = arc.lock() {\n                guard.refs -= 1;\n                guard.refs \u003c= 0\n            } else {\n                false\n            }\n        };\n        if should_remove {\n            PDF_OBJECTS.remove(obj);\n        }\n    }\n}\n\n// ============================================================================\n// Helper function to extract object properties\n// ============================================================================\n\nfn with_obj\u003cT, F: FnOnce(\u0026PdfObj) -\u003e T\u003e(obj: PdfObjHandle, default: T, f: F) -\u003e T {\n    PDF_OBJECTS\n        .get(obj)\n        .and_then(|arc| arc.lock().ok().map(|guard| f(\u0026guard)))\n        .unwrap_or(default)\n}\n\nfn with_obj_mut\u003cT, F: FnOnce(\u0026mut PdfObj) -\u003e T\u003e(obj: PdfObjHandle, default: T, f: F) -\u003e T {\n    PDF_OBJECTS\n        .get(obj)\n        .and_then(|arc| arc.lock().ok().map(|mut guard| f(\u0026mut guard)))\n        .unwrap_or(default)\n}\n\n// ============================================================================\n// PDF Object Type Checking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_null(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 1, |o| i32::from(matches!(o.obj_type, PdfObjType::Null)))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_bool(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Bool(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_int(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Int(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_real(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Real(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_number(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| {\n        i32::from(matches!(o.obj_type, PdfObjType::Int(_) | PdfObjType::Real(_)))\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_name(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Name(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_string(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::String(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_array(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Array(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_dict(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Dict(_))))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_indirect(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Indirect { .. })))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_is_stream(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(matches!(o.obj_type, PdfObjType::Stream { .. })))\n}\n\n// ============================================================================\n// PDF Object Value Extraction\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_bool(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Bool(b) =\u003e i32::from(*b),\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i as i32,\n        PdfObjType::Real(f) =\u003e *f as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int64(_ctx: Handle, obj: PdfObjHandle) -\u003e i64 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i,\n        PdfObjType::Real(f) =\u003e *f as i64,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_real(_ctx: Handle, obj: PdfObjHandle) -\u003e f32 {\n    with_obj(obj, 0.0, |o| match \u0026o.obj_type {\n        PdfObjType::Real(f) =\u003e *f as f32,\n        PdfObjType::Int(i) =\u003e *i as f32,\n        _ =\u003e 0.0,\n    })\n}\n\n// Static storage for returned name strings\nstatic NAME_STORAGE: LazyLock\u003cMutex\u003cVec\u003cCString\u003e\u003e\u003e = LazyLock::new(|| Mutex::new(Vec::new()));\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_name(_ctx: Handle, obj: PdfObjHandle) -\u003e *const c_char {\n    static EMPTY: \u0026[u8] = b\"\\0\";\n\n    let name = with_obj(obj, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    match name {\n        Some(s) =\u003e {\n            if let Ok(cstring) = CString::new(s) {\n                let ptr = cstring.as_ptr();\n                if let Ok(mut storage) = NAME_STORAGE.lock() {\n                    storage.push(cstring);\n                }\n                ptr\n            } else {\n                EMPTY.as_ptr() as *const c_char\n            }\n        }\n        None =\u003e EMPTY.as_ptr() as *const c_char,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_num(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Indirect { num, .. } =\u003e *num,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_gen(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Indirect { generation, .. } =\u003e *generation,\n        _ =\u003e 0,\n    })\n}\n\n// ============================================================================\n// PDF Object Value Extraction with Defaults\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_bool_default(_ctx: Handle, obj: PdfObjHandle, def: i32) -\u003e i32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Bool(b) =\u003e i32::from(*b),\n        _ =\u003e def,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_int_default(_ctx: Handle, obj: PdfObjHandle, def: i32) -\u003e i32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Int(i) =\u003e *i as i32,\n        PdfObjType::Real(f) =\u003e *f as i32,\n        _ =\u003e def,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_to_real_default(_ctx: Handle, obj: PdfObjHandle, def: f32) -\u003e f32 {\n    with_obj(obj, def, |o| match \u0026o.obj_type {\n        PdfObjType::Real(f) =\u003e *f as f32,\n        PdfObjType::Int(i) =\u003e *i as f32,\n        _ =\u003e def,\n    })\n}\n\n// ============================================================================\n// PDF Array Operations\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_len(_ctx: Handle, array: PdfObjHandle) -\u003e i32 {\n    with_obj(array, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Array(arr) =\u003e arr.len() as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push(_ctx: Handle, array: PdfObjHandle, obj: PdfObjHandle) {\n    let obj_to_push = with_obj(obj, None, |o| Some(o.clone()));\n\n    if let Some(obj_clone) = obj_to_push {\n        with_obj_mut(array, (), |arr| {\n            if let PdfObjType::Array(ref mut a) = arr.obj_type {\n                a.push(obj_clone);\n                arr.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_int(_ctx: Handle, array: PdfObjHandle, x: i64) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_int(x));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_real(_ctx: Handle, array: PdfObjHandle, x: f64) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_real(x));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_push_bool(_ctx: Handle, array: PdfObjHandle, x: i32) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            a.push(PdfObj::new_bool(x != 0));\n            arr.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_array_delete(_ctx: Handle, array: PdfObjHandle, index: i32) {\n    with_obj_mut(array, (), |arr| {\n        if let PdfObjType::Array(ref mut a) = arr.obj_type {\n            let idx = index as usize;\n            if idx \u003c a.len() {\n                a.remove(idx);\n                arr.dirty = true;\n            }\n        }\n    });\n}\n\n// ============================================================================\n// PDF Dictionary Operations\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_len(_ctx: Handle, dict: PdfObjHandle) -\u003e i32 {\n    with_obj(dict, 0, |o| match \u0026o.obj_type {\n        PdfObjType::Dict(d) =\u003e d.len() as i32,\n        _ =\u003e 0,\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_puts(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: *const c_char,\n    val: PdfObjHandle,\n) {\n    if key.is_null() {\n        return;\n    }\n\n    #[allow(unsafe_code)]\n    let key_str = unsafe { CStr::from_ptr(key) }\n        .to_str()\n        .unwrap_or(\"\")\n        .to_string();\n\n    let val_obj = with_obj(val, None, |o| Some(o.clone()));\n\n    if let Some(val_clone) = val_obj {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val_clone;\n                } else {\n                    dict_entries.push((key_str.clone(), val_clone));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_dels(_ctx: Handle, dict: PdfObjHandle, key: *const c_char) {\n    if key.is_null() {\n        return;\n    }\n\n    #[allow(unsafe_code)]\n    let key_str = unsafe { CStr::from_ptr(key) }\n        .to_str()\n        .unwrap_or(\"\")\n        .to_string();\n\n    with_obj_mut(dict, (), |d| {\n        if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n            dict_entries.retain(|(k, _)| k != \u0026key_str);\n            d.dirty = true;\n        }\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_int(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: i64,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_int(x);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_real(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: f64,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_real(x);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dict_put_bool(\n    _ctx: Handle,\n    dict: PdfObjHandle,\n    key: PdfObjHandle,\n    x: i32,\n) {\n    let key_name = with_obj(key, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    if let Some(key_str) = key_name {\n        with_obj_mut(dict, (), |d| {\n            if let PdfObjType::Dict(ref mut dict_entries) = d.obj_type {\n                let val = PdfObj::new_bool(x != 0);\n                if let Some(entry) = dict_entries.iter_mut().find(|(k, _)| k == \u0026key_str) {\n                    entry.1 = val;\n                } else {\n                    dict_entries.push((key_str.clone(), val));\n                }\n                d.dirty = true;\n            }\n        });\n    }\n}\n\n// ============================================================================\n// PDF Object Marking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_marked(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(o.marked))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_mark_obj(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj_mut(obj, 0, |o| {\n        let was_marked = o.marked;\n        o.marked = true;\n        i32::from(was_marked)\n    })\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_unmark_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.marked = false;\n    });\n}\n\n// ============================================================================\n// PDF Object Dirty Tracking\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_is_dirty(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| i32::from(o.dirty))\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_dirty_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.dirty = true;\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_clean_obj(_ctx: Handle, obj: PdfObjHandle) {\n    with_obj_mut(obj, (), |o| {\n        o.dirty = false;\n    });\n}\n\n// ============================================================================\n// PDF Object Parent\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_set_obj_parent(_ctx: Handle, obj: PdfObjHandle, num: i32) {\n    with_obj_mut(obj, (), |o| {\n        o.parent_num = num;\n    });\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_parent_num(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| o.parent_num)\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_obj_refs(_ctx: Handle, obj: PdfObjHandle) -\u003e i32 {\n    with_obj(obj, 0, |o| o.refs)\n}\n\n// ============================================================================\n// PDF Object Comparison\n// ============================================================================\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_objcmp(_ctx: Handle, a: PdfObjHandle, b: PdfObjHandle) -\u003e i32 {\n    let obj_a = with_obj(a, None, |o| Some(o.obj_type.clone()));\n    let obj_b = with_obj(b, None, |o| Some(o.obj_type.clone()));\n\n    match (obj_a, obj_b) {\n        (Some(a_type), Some(b_type)) =\u003e i32::from(!a_type.shallow_eq(\u0026b_type)),\n        _ =\u003e 1,\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn pdf_name_eq(_ctx: Handle, a: PdfObjHandle, b: PdfObjHandle) -\u003e i32 {\n    let name_a = with_obj(a, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    let name_b = with_obj(b, None, |o| match \u0026o.obj_type {\n        PdfObjType::Name(s) =\u003e Some(s.clone()),\n        _ =\u003e None,\n    });\n\n    match (name_a, name_b) {\n        (Some(a_name), Some(b_name)) =\u003e i32::from(a_name == b_name),\n        _ =\u003e 0,\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // Object Creation Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_new_null() {\n        let null = pdf_new_null(0);\n        assert_eq!(pdf_is_null(0, null), 1);\n        assert_eq!(pdf_is_bool(0, null), 0);\n        assert_eq!(pdf_is_int(0, null), 0);\n    }\n\n    #[test]\n    fn test_pdf_new_bool() {\n        let bool_true = pdf_new_bool(0, 1);\n        assert_eq!(pdf_is_bool(0, bool_true), 1);\n        assert_eq!(pdf_to_bool(0, bool_true), 1);\n\n        let bool_false = pdf_new_bool(0, 0);\n        assert_eq!(pdf_is_bool(0, bool_false), 1);\n        assert_eq!(pdf_to_bool(0, bool_false), 0);\n\n        // Non-zero should also be true\n        let bool_nonzero = pdf_new_bool(0, 42);\n        assert_eq!(pdf_to_bool(0, bool_nonzero), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_int() {\n        let int_val = pdf_new_int(0, 42);\n        assert_eq!(pdf_is_int(0, int_val), 1);\n        assert_eq!(pdf_to_int(0, int_val), 42);\n        assert_eq!(pdf_to_int64(0, int_val), 42);\n\n        // Negative value\n        let neg_val = pdf_new_int(0, -100);\n        assert_eq!(pdf_to_int(0, neg_val), -100);\n        assert_eq!(pdf_to_int64(0, neg_val), -100);\n\n        // Large value\n        let large_val = pdf_new_int(0, i64::MAX);\n        assert_eq!(pdf_to_int64(0, large_val), i64::MAX);\n    }\n\n    #[test]\n    fn test_pdf_new_real() {\n        let real_val = pdf_new_real(0, 3.14);\n        assert_eq!(pdf_is_real(0, real_val), 1);\n        assert!((pdf_to_real(0, real_val) - 3.14).abs() \u003c 0.01);\n\n        // Negative value\n        let neg_real = pdf_new_real(0, -2.5);\n        assert!((pdf_to_real(0, neg_real) + 2.5).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_pdf_is_number() {\n        let int_val = pdf_new_int(0, 42);\n        let real_val = pdf_new_real(0, 3.14);\n        let null_val = pdf_new_null(0);\n\n        assert_eq!(pdf_is_number(0, int_val), 1);\n        assert_eq!(pdf_is_number(0, real_val), 1);\n        assert_eq!(pdf_is_number(0, null_val), 0);\n    }\n\n    #[test]\n    fn test_pdf_new_name() {\n        let name = pdf_new_name(0, b\"Type\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_is_name(0, name), 1);\n\n        // Empty name\n        let empty_name = pdf_new_name(0, std::ptr::null());\n        assert_eq!(pdf_is_name(0, empty_name), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_string() {\n        let data = b\"Hello, PDF!\";\n        let str_obj = pdf_new_string(0, data.as_ptr() as *const c_char, data.len());\n        assert_eq!(pdf_is_string(0, str_obj), 1);\n\n        // Empty string\n        let empty_str = pdf_new_string(0, std::ptr::null(), 0);\n        assert_eq!(pdf_is_string(0, empty_str), 1);\n\n        // Null pointer with non-zero length\n        let null_str = pdf_new_string(0, std::ptr::null(), 10);\n        assert_eq!(pdf_is_string(0, null_str), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_text_string() {\n        let text_obj = pdf_new_text_string(0, b\"Hello World\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_is_string(0, text_obj), 1);\n\n        // Null text\n        let null_text = pdf_new_text_string(0, std::ptr::null());\n        assert_eq!(pdf_is_string(0, null_text), 1);\n    }\n\n    #[test]\n    fn test_pdf_new_indirect() {\n        let indirect = pdf_new_indirect(0, 0, 10, 2);\n        assert_eq!(pdf_is_indirect(0, indirect), 1);\n        assert_eq!(pdf_to_num(0, indirect), 10);\n        assert_eq!(pdf_to_gen(0, indirect), 2);\n    }\n\n    // ============================================================================\n    // Reference Counting Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_keep_drop_obj() {\n        let obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_obj_refs(0, obj), 1);\n\n        pdf_keep_obj(0, obj);\n        assert_eq!(pdf_obj_refs(0, obj), 2);\n\n        pdf_drop_obj(0, obj);\n        assert_eq!(pdf_obj_refs(0, obj), 1);\n\n        pdf_drop_obj(0, obj);\n        // Object should be removed, so refs should be 0 (default)\n        assert_eq!(pdf_obj_refs(0, obj), 0);\n    }\n\n    #[test]\n    fn test_pdf_keep_invalid_handle() {\n        let invalid = pdf_keep_obj(0, 99999);\n        assert_eq!(invalid, 99999); // Should return same handle\n    }\n\n    // ============================================================================\n    // Value Extraction with Defaults Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_to_bool_default() {\n        let bool_obj = pdf_new_bool(0, 1);\n        let null_obj = pdf_new_null(0);\n\n        assert_eq!(pdf_to_bool_default(0, bool_obj, 0), 1);\n        assert_eq!(pdf_to_bool_default(0, null_obj, 99), 99);\n    }\n\n    #[test]\n    fn test_pdf_to_int_default() {\n        let int_obj = pdf_new_int(0, 42);\n        let null_obj = pdf_new_null(0);\n        let real_obj = pdf_new_real(0, 3.7);\n\n        assert_eq!(pdf_to_int_default(0, int_obj, 0), 42);\n        assert_eq!(pdf_to_int_default(0, null_obj, 99), 99);\n        assert_eq!(pdf_to_int_default(0, real_obj, 0), 3); // Truncated\n    }\n\n    #[test]\n    fn test_pdf_to_real_default() {\n        let real_obj = pdf_new_real(0, 3.14);\n        let null_obj = pdf_new_null(0);\n        let int_obj = pdf_new_int(0, 5);\n\n        assert!((pdf_to_real_default(0, real_obj, 0.0) - 3.14).abs() \u003c 0.01);\n        assert!((pdf_to_real_default(0, null_obj, 99.0) - 99.0).abs() \u003c 0.01);\n        assert!((pdf_to_real_default(0, int_obj, 0.0) - 5.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn test_pdf_to_name() {\n        let name = pdf_new_name(0, b\"TestName\\0\".as_ptr() as *const c_char);\n        let ptr = pdf_to_name(0, name);\n        assert!(!ptr.is_null());\n\n        // Test non-name object returns empty\n        let int_obj = pdf_new_int(0, 42);\n        let ptr2 = pdf_to_name(0, int_obj);\n        assert!(!ptr2.is_null());\n    }\n\n    // ============================================================================\n    // Array Operations Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_array_operations() {\n        let arr = pdf_new_array(0, 0, 10);\n        assert_eq!(pdf_is_array(0, arr), 1);\n        assert_eq!(pdf_array_len(0, arr), 0);\n\n        // Push int\n        pdf_array_push_int(0, arr, 100);\n        assert_eq!(pdf_array_len(0, arr), 1);\n\n        // Push real\n        pdf_array_push_real(0, arr, 2.5);\n        assert_eq!(pdf_array_len(0, arr), 2);\n\n        // Push bool\n        pdf_array_push_bool(0, arr, 1);\n        assert_eq!(pdf_array_len(0, arr), 3);\n\n        // Push object\n        let obj = pdf_new_int(0, 42);\n        pdf_array_push(0, arr, obj);\n        assert_eq!(pdf_array_len(0, arr), 4);\n\n        // Delete\n        pdf_array_delete(0, arr, 0);\n        assert_eq!(pdf_array_len(0, arr), 3);\n\n        // Delete out of bounds (should not crash)\n        pdf_array_delete(0, arr, 100);\n        assert_eq!(pdf_array_len(0, arr), 3);\n    }\n\n    #[test]\n    fn test_pdf_array_len_non_array() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_array_len(0, dict), 0);\n\n        let null = pdf_new_null(0);\n        assert_eq!(pdf_array_len(0, null), 0);\n    }\n\n    #[test]\n    fn test_pdf_array_push_to_non_array() {\n        let dict = pdf_new_dict(0, 0, 10);\n        pdf_array_push_int(0, dict, 42); // Should not crash\n        assert_eq!(pdf_dict_len(0, dict), 0); // Dict unchanged\n    }\n\n    // ============================================================================\n    // Dictionary Operations Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_dict_operations() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_is_dict(0, dict), 1);\n        assert_eq!(pdf_dict_len(0, dict), 0);\n\n        // Put int with name key\n        let key1 = pdf_new_name(0, b\"Type\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_int(0, dict, key1, 42);\n        assert_eq!(pdf_dict_len(0, dict), 1);\n\n        // Put real\n        let key2 = pdf_new_name(0, b\"Width\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_real(0, dict, key2, 100.5);\n        assert_eq!(pdf_dict_len(0, dict), 2);\n\n        // Put bool\n        let key3 = pdf_new_name(0, b\"Enabled\\0\".as_ptr() as *const c_char);\n        pdf_dict_put_bool(0, dict, key3, 1);\n        assert_eq!(pdf_dict_len(0, dict), 3);\n\n        // Update existing key\n        pdf_dict_put_int(0, dict, key1, 99);\n        assert_eq!(pdf_dict_len(0, dict), 3); // Length unchanged\n\n        // Delete by string key\n        pdf_dict_dels(0, dict, b\"Width\\0\".as_ptr() as *const c_char);\n        assert_eq!(pdf_dict_len(0, dict), 2);\n    }\n\n    #[test]\n    fn test_pdf_dict_puts() {\n        let dict = pdf_new_dict(0, 0, 10);\n        let val = pdf_new_int(0, 42);\n\n        pdf_dict_puts(0, dict, b\"Key\\0\".as_ptr() as *const c_char, val);\n        assert_eq!(pdf_dict_len(0, dict), 1);\n\n        // Null key\n        pdf_dict_puts(0, dict, std::ptr::null(), val);\n        assert_eq!(pdf_dict_len(0, dict), 1); // Unchanged\n    }\n\n    #[test]\n    fn test_pdf_dict_dels_null_key() {\n        let dict = pdf_new_dict(0, 0, 10);\n        pdf_dict_dels(0, dict, std::ptr::null()); // Should not crash\n    }\n\n    #[test]\n    fn test_pdf_dict_put_with_non_name_key() {\n        let dict = pdf_new_dict(0, 0, 10);\n        let int_key = pdf_new_int(0, 42); // Not a name\n\n        pdf_dict_put_int(0, dict, int_key, 100);\n        assert_eq!(pdf_dict_len(0, dict), 0); // Should be unchanged\n    }\n\n    #[test]\n    fn test_pdf_dict_len_non_dict() {\n        let arr = pdf_new_array(0, 0, 10);\n        assert_eq!(pdf_dict_len(0, arr), 0);\n    }\n\n    // ============================================================================\n    // Object Marking Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_object_marking() {\n        let obj = pdf_new_int(0, 1);\n        assert_eq!(pdf_obj_marked(0, obj), 0);\n\n        let was_marked = pdf_mark_obj(0, obj);\n        assert_eq!(was_marked, 0); // Was not marked before\n        assert_eq!(pdf_obj_marked(0, obj), 1);\n\n        let was_marked2 = pdf_mark_obj(0, obj);\n        assert_eq!(was_marked2, 1); // Was marked before\n\n        pdf_unmark_obj(0, obj);\n        assert_eq!(pdf_obj_marked(0, obj), 0);\n    }\n\n    // ============================================================================\n    // Object Dirty Tracking Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_object_dirty() {\n        let obj = pdf_new_int(0, 1);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 0);\n\n        pdf_dirty_obj(0, obj);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 1);\n\n        pdf_clean_obj(0, obj);\n        assert_eq!(pdf_obj_is_dirty(0, obj), 0);\n    }\n\n    // ============================================================================\n    // Parent Number Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_obj_parent_num() {\n        let obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_obj_parent_num(0, obj), 0);\n\n        pdf_set_obj_parent(0, obj, 100);\n        assert_eq!(pdf_obj_parent_num(0, obj), 100);\n    }\n\n    // ============================================================================\n    // Object Comparison Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_objcmp() {\n        // Same type, same value\n        let int1 = pdf_new_int(0, 42);\n        let int2 = pdf_new_int(0, 42);\n        assert_eq!(pdf_objcmp(0, int1, int2), 0);\n\n        // Same type, different value\n        let int3 = pdf_new_int(0, 100);\n        assert_eq!(pdf_objcmp(0, int1, int3), 1);\n\n        // Different types\n        let real = pdf_new_real(0, 42.0);\n        assert_eq!(pdf_objcmp(0, int1, real), 1);\n\n        // Null objects\n        let null1 = pdf_new_null(0);\n        let null2 = pdf_new_null(0);\n        assert_eq!(pdf_objcmp(0, null1, null2), 0);\n\n        // Bool comparison\n        let bool1 = pdf_new_bool(0, 1);\n        let bool2 = pdf_new_bool(0, 1);\n        let bool3 = pdf_new_bool(0, 0);\n        assert_eq!(pdf_objcmp(0, bool1, bool2), 0);\n        assert_eq!(pdf_objcmp(0, bool1, bool3), 1);\n\n        // Invalid handles\n        assert_eq!(pdf_objcmp(0, 99999, 99998), 1);\n    }\n\n    #[test]\n    fn test_pdf_name_eq() {\n        let name1 = pdf_new_name(0, b\"Test\\0\".as_ptr() as *const c_char);\n        let name2 = pdf_new_name(0, b\"Test\\0\".as_ptr() as *const c_char);\n        let name3 = pdf_new_name(0, b\"Other\\0\".as_ptr() as *const c_char);\n\n        assert_eq!(pdf_name_eq(0, name1, name2), 1);\n        assert_eq!(pdf_name_eq(0, name1, name3), 0);\n\n        // Non-name objects\n        let int_obj = pdf_new_int(0, 42);\n        assert_eq!(pdf_name_eq(0, name1, int_obj), 0);\n        assert_eq!(pdf_name_eq(0, int_obj, int_obj), 0);\n    }\n\n    // ============================================================================\n    // Type Checking Edge Cases\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_is_stream() {\n        let dict = pdf_new_dict(0, 0, 10);\n        assert_eq!(pdf_is_stream(0, dict), 0);\n\n        // Note: We don't have pdf_new_stream, so we can't test positive case easily\n    }\n\n    #[test]\n    fn test_type_checks_invalid_handle() {\n        let invalid: PdfObjHandle = 99999;\n        assert_eq!(pdf_is_null(0, invalid), 1); // Default is 1 for null check\n        assert_eq!(pdf_is_bool(0, invalid), 0);\n        assert_eq!(pdf_is_int(0, invalid), 0);\n        assert_eq!(pdf_is_real(0, invalid), 0);\n        assert_eq!(pdf_is_number(0, invalid), 0);\n        assert_eq!(pdf_is_name(0, invalid), 0);\n        assert_eq!(pdf_is_string(0, invalid), 0);\n        assert_eq!(pdf_is_array(0, invalid), 0);\n        assert_eq!(pdf_is_dict(0, invalid), 0);\n        assert_eq!(pdf_is_indirect(0, invalid), 0);\n        assert_eq!(pdf_is_stream(0, invalid), 0);\n    }\n\n    #[test]\n    fn test_value_extraction_wrong_type() {\n        let str_obj = pdf_new_string(0, b\"test\".as_ptr() as *const c_char, 4);\n\n        assert_eq!(pdf_to_bool(0, str_obj), 0);\n        assert_eq!(pdf_to_int(0, str_obj), 0);\n        assert_eq!(pdf_to_int64(0, str_obj), 0);\n        assert!((pdf_to_real(0, str_obj) - 0.0).abs() \u003c 0.01);\n        assert_eq!(pdf_to_num(0, str_obj), 0);\n        assert_eq!(pdf_to_gen(0, str_obj), 0);\n    }\n\n    // ============================================================================\n    // PdfObjType Tests\n    // ============================================================================\n\n    #[test]\n    fn test_pdf_obj_type_shallow_eq() {\n        // Same string values\n        let s1 = PdfObjType::String(b\"hello\".to_vec());\n        let s2 = PdfObjType::String(b\"hello\".to_vec());\n        assert!(s1.shallow_eq(\u0026s2));\n\n        // Different string values\n        let s3 = PdfObjType::String(b\"world\".to_vec());\n        assert!(!s1.shallow_eq(\u0026s3));\n\n        // Arrays with same length\n        let a1 = PdfObjType::Array(vec![PdfObj::new_int(1)]);\n        let a2 = PdfObjType::Array(vec![PdfObj::new_int(2)]);\n        assert!(a1.shallow_eq(\u0026a2)); // Only checks length\n\n        // Dicts with same length\n        let d1 = PdfObjType::Dict(vec![(\"key\".to_string(), PdfObj::new_int(1))]);\n        let d2 = PdfObjType::Dict(vec![(\"other\".to_string(), PdfObj::new_int(2))]);\n        assert!(d1.shallow_eq(\u0026d2)); // Only checks length\n\n        // Indirect refs\n        let i1 = PdfObjType::Indirect { num: 1, generation: 0 };\n        let i2 = PdfObjType::Indirect { num: 1, generation: 0 };\n        let i3 = PdfObjType::Indirect { num: 2, generation: 0 };\n        assert!(i1.shallow_eq(\u0026i2));\n        assert!(!i1.shallow_eq(\u0026i3));\n\n        // Streams never match\n        let st1 = PdfObjType::Stream { dict: Box::new(PdfObj::new_dict(0)), data: vec![] };\n        let st2 = PdfObjType::Stream { dict: Box::new(PdfObj::new_dict(0)), data: vec![] };\n        assert!(!st1.shallow_eq(\u0026st2));\n\n        // Different types\n        let null = PdfObjType::Null;\n        let int = PdfObjType::Int(42);\n        assert!(!null.shallow_eq(\u0026int));\n    }\n\n    #[test]\n    fn test_pdf_obj_new_functions() {\n        let null = PdfObj::new_null();\n        assert!(matches!(null.obj_type, PdfObjType::Null));\n        assert!(!null.marked);\n        assert!(!null.dirty);\n        assert_eq!(null.refs, 1);\n\n        let arr = PdfObj::new_array(5);\n        if let PdfObjType::Array(a) = \u0026arr.obj_type {\n            assert!(a.capacity() \u003e= 5);\n        } else {\n            panic!(\"Expected array\");\n        }\n\n        let dict = PdfObj::new_dict(3);\n        if let PdfObjType::Dict(d) = \u0026dict.obj_type {\n            assert!(d.capacity() \u003e= 3);\n        } else {\n            panic!(\"Expected dict\");\n        }\n\n        let indirect = PdfObj::new_indirect(10, 2);\n        if let PdfObjType::Indirect { num, generation } = \u0026indirect.obj_type {\n            assert_eq!(*num, 10);\n            assert_eq!(*generation, 2);\n        } else {\n            panic!(\"Expected indirect\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[1442560,1442464],"length":1,"stats":{"Line":1}},{"line":32,"address":[1504711,1504786],"length":1,"stats":{"Line":2}},{"line":34,"address":[1443019],"length":1,"stats":{"Line":1}},{"line":35,"address":[1505301],"length":1,"stats":{"Line":1}},{"line":36,"address":[1505353],"length":1,"stats":{"Line":0}},{"line":37,"address":[1443210],"length":1,"stats":{"Line":0}},{"line":38,"address":[1443265],"length":1,"stats":{"Line":1}},{"line":39,"address":[1443326],"length":1,"stats":{"Line":1}},{"line":40,"address":[1443412],"length":1,"stats":{"Line":1}},{"line":41,"address":[1443498],"length":1,"stats":{"Line":1}},{"line":42,"address":[1505785],"length":1,"stats":{"Line":1}},{"line":45,"address":[1443071],"length":1,"stats":{"Line":1}},{"line":61,"address":[1505856],"length":1,"stats":{"Line":2}},{"line":71,"address":[1443728],"length":1,"stats":{"Line":1}},{"line":73,"address":[1443743],"length":1,"stats":{"Line":1}},{"line":81,"address":[1443824],"length":1,"stats":{"Line":2}},{"line":83,"address":[1506040],"length":1,"stats":{"Line":2}},{"line":91,"address":[1506128],"length":1,"stats":{"Line":1}},{"line":93,"address":[1443929],"length":1,"stats":{"Line":1}},{"line":101,"address":[1506224],"length":1,"stats":{"Line":1}},{"line":103,"address":[1444039],"length":1,"stats":{"Line":1}},{"line":111,"address":[1444176],"length":1,"stats":{"Line":1}},{"line":113,"address":[1444199],"length":1,"stats":{"Line":2}},{"line":121,"address":[1444336],"length":1,"stats":{"Line":1}},{"line":123,"address":[1444355],"length":1,"stats":{"Line":2}},{"line":131,"address":[1444496],"length":1,"stats":{"Line":1}},{"line":133,"address":[1444515],"length":1,"stats":{"Line":2}},{"line":141,"address":[1444656],"length":1,"stats":{"Line":1}},{"line":143,"address":[1444667],"length":1,"stats":{"Line":1}},{"line":163,"address":[1444831,1444752,1444784],"length":1,"stats":{"Line":1}},{"line":164,"address":[1444761,1444790],"length":1,"stats":{"Line":3}},{"line":168,"address":[1444864,1444963,1444904],"length":1,"stats":{"Line":1}},{"line":169,"address":[1507118,1507089],"length":1,"stats":{"Line":2}},{"line":173,"address":[1445102,1445008,1445050],"length":1,"stats":{"Line":1}},{"line":174,"address":[1445061,1445027],"length":1,"stats":{"Line":3}},{"line":178,"address":[1445237,1445180,1445136],"length":1,"stats":{"Line":1}},{"line":179,"address":[1445157,1445192],"length":1,"stats":{"Line":2}},{"line":183,"address":[1445336,1445280,1445590],"length":1,"stats":{"Line":1}},{"line":184,"address":[1445321,1445346],"length":1,"stats":{"Line":2}},{"line":185,"address":[1445641,1445374],"length":1,"stats":{"Line":2}},{"line":188,"address":[1445410,1445357],"length":1,"stats":{"Line":2}},{"line":191,"address":[1445623,1445509],"length":1,"stats":{"Line":2}},{"line":195,"address":[1445781,1445712,1445988],"length":1,"stats":{"Line":1}},{"line":196,"address":[1445791,1445766],"length":1,"stats":{"Line":2}},{"line":197,"address":[1445808,1446039],"length":1,"stats":{"Line":2}},{"line":200,"address":[1445844],"length":1,"stats":{"Line":1}},{"line":201,"address":[1508145,1508043],"length":1,"stats":{"Line":2}},{"line":205,"address":[1508276,1508537,1508224],"length":1,"stats":{"Line":1}},{"line":206,"address":[1446178,1446153],"length":1,"stats":{"Line":2}},{"line":207,"address":[1508314,1508605],"length":1,"stats":{"Line":2}},{"line":210,"address":[1446189,1446242],"length":1,"stats":{"Line":2}},{"line":213,"address":[1446341,1446482],"length":1,"stats":{"Line":2}},{"line":217,"address":[1508753,1508705,1508656],"length":1,"stats":{"Line":1}},{"line":218,"address":[1446643,1446606],"length":1,"stats":{"Line":2}},{"line":222,"address":[1508800,1508841,1508909],"length":1,"stats":{"Line":1}},{"line":223,"address":[1508851,1508822],"length":1,"stats":{"Line":2}},{"line":227,"address":[1508985,1509053,1508944],"length":1,"stats":{"Line":1}},{"line":228,"address":[1446935,1446902],"length":1,"stats":{"Line":2}},{"line":236,"address":[1447511,1447085,1447536,1447040],"length":1,"stats":{"Line":1}},{"line":237,"address":[1447101,1447062],"length":1,"stats":{"Line":2}},{"line":238,"address":[1447294,1447248,1447165],"length":1,"stats":{"Line":3}},{"line":239,"address":[1509423,1509337,1509385],"length":1,"stats":{"Line":2}},{"line":246,"address":[1509584,1510178,1510069,1509631],"length":1,"stats":{"Line":1}},{"line":247,"address":[1447612,1447651],"length":1,"stats":{"Line":2}},{"line":249,"address":[1509712,1510095,1509786,1509819],"length":1,"stats":{"Line":3}},{"line":250,"address":[1509851,1509905,1509951],"length":1,"stats":{"Line":2}},{"line":251,"address":[1509976,1509939],"length":1,"stats":{"Line":2}},{"line":253,"address":[1510090],"length":1,"stats":{"Line":0}},{"line":256,"address":[1510060],"length":1,"stats":{"Line":1}},{"line":257,"address":[1448168],"length":1,"stats":{"Line":1}},{"line":266,"address":[1402549,1403824,1407727,1403554,1408480,1408434,1402128,1401781,1402864,1408768,1402847,1403088,1407744,1403600,1401584,1406165,1409925,1404021,1404752,1409701,1406416,1401104,1407215,1401344,1407968,1401320,1402325,1409056,1406389,1407941,1404501,1402818,1405744,1406898,1404725,1408720,1409477,1409280,1408463,1406944,1405296,1404048,1405031,1402087,1401559,1407456,1407429,1403583,1409728,1403797,1405968,1406632,1407232,1407698,1404304,1405717,1408192,1402116,1406656,1409008,1408165,1402352,1404528,1405060,1404278,1405072,1409253,1403285,1402576,1403312,1403061,1408749,1406192,1407186,1405952,1405269,1401808,1405520,1409504,1406927,1405493,1409037],"length":1,"stats":{"Line":38}},{"line":267,"address":[1407579,1403762,1405422,1407067,1401370,1403950,1406853,1402514,1403461,1403622,1407332,1409078,1408675,1408603,1409218,1402228,1403344,1402478,1405646,1402886,1402290,1406688,1402452,1402773,1408315,1403700,1404166,1402150,1408891,1406597,1405234,1406448,1405990,1407141,1401606,1407844,1404654,1406354,1402254,1407906,1404404,1405850,1409182,1406805,1405768,1406214,1409666,1402699,1404430,1406530,1401249,1408627,1407870,1408224,1405172,1405198,1407605,1401478,1401710,1405917,1405876,1408094,1407990,1403726,1408512,1408389,1407488,1404326,1407653,1403110,1401976,1401949,1401843,1406094,1408341,1403924,1404787,1409630,1401520,1409890,1403250,1404197,1404690,1402374,1408963,1401285,1406779,1401218,1409750,1405396,1403509,1408130,1404550,1409828,1405542,1409302,1407093,1405620,1403986,1409442,1407766,1409406,1407394,1409526,1403846,1407254,1403188,1404983,1404628,1402990,1406130,1402039,1409380,1406318,1406292,1404893,1406561,1404466,1401136,1401746,1404239,1403214,1407358,1402608,1408068,1401452,1405094,1404084,1404920,1408800,1403435,1402964,1408915,1406068,1409854,1409156,1405318,1402725,1409604,1406976,1401684,1405682,1405458,1403026],"length":1,"stats":{"Line":152}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[1422800,1412473,1423338,1403721,1424667,1418803,1403456,1423968,1409625,1402249,1424816,1418281,1411721,1418542,1420881,1413251,1410704,1410192,1404912,1418727,1412729,1412397,1422353,1420049,1421226,1419858,1419360,1413977,1419042,1405641,1413165,1412217,1424155,1404649,1401244,1417760,1422193,1417043,1402985,1417264,1421713,1418961,1408089,1423120,1422491,1412145,1411987,1419840,1410958,1421393,1414985,1416265,1423280,1413721,1420992,1424843,1419569,1407088,1401473,1415165,1420187,1420832,1424304,1416512,1419729,1423819,1422033,1419698,1419520,1411216,1409401,1412464,1421362,1403209,1411712,1424017,1424480,1420850,1411491,1413491,1411149,1416445,1420336,1420218,1411405,1414224,1408336,1423505,1418272,1415421,1421842,1415232,1424128,1410129,1424331,1407600,1422144,1410637,1409952,1419073,1408910,1422658,1401968,1421873,1419211,1413409,1420545,1401705,1415488,1421050,1405871,1414729,1417693,1418205,1412653,1420160,1415753,1421019,1402473,1421984,1420496,1421682,1414233,1423474,1417774,1419184,1414499,1420385,1416768,1416009,1422002,1420656,1413901,1423986,1414480,1410723,1414413,1422818,1421344,1422304,1421664,1402720,1420714,1414915,1423674,1405417,1421504,1413232,1421522,1416777,1422522,1423643,1415744,1420514,1411968,1422960,1415933,1420683,1421824,1416256,1418784,1416521,1423616,1415497,1416706,1410448,1419538,1419889,1411649,1411225,1417959,1409971,1410457,1407353,1412985,1419378,1410944,1421195,1416189,1417441,1416957,1406313,1418025,1410381,1406556,1412720,1409849,1420018,1414657,1423792,1419242,1419024,1410201,1415241,1422322,1424529,1422849,1423307,1420000,1403945,1423456,1424498,1405193,1413472,1417024,1413968,1422162,1413649,1422978,1422464,1407865,1413712,1417283,1408622,1423850,1424186,1412976,1418461,1418016,1424874,1417201,1422689,1423138,1424362,1404425,1421168,1412208,1415677,1416000,1423169,1417513,1410881,1417504,1411472,1421553,1419680,1406089,1422640,1419409,1418528,1404192,1414976,1409177,1424640,1420354,1414720,1424698,1406800,1414157,1423009,1412909,1411901],"length":1,"stats":{"Line":191}},{"line":270,"address":[2019617,2019201,2021816,2020670,2018739,2025281,2024801,2018993,2024394,2021347,2022304,2022801,2023489,2023009,2021601,2020913,2023697,2024593,2025489,2026123,2025027,2024161,2020449,2022534,2019409,2023235,2019825,2022035,2025697,2023918,2026358,2025920,2018467,2021121,2020241,2020033],"length":1,"stats":{"Line":38}},{"line":273,"address":[2041054,2043246,2040413,2042880,2040432,2041072,2042861,2040704,2042672,2041920,2043072,2042447,2042112,2041328,2041694,2042653,2041502,2040224,2042271,2041298,2043054,2042464,2041520,2042288,2040670,2041893,2041712,2042094,2040863,2040880],"length":1,"stats":{"Line":15}},{"line":274,"address":[2040454,2041830,2040904,2042222,2041665,2043005,2042200,2040541,2041544,2041178,2041453,2042780,2040608,2043217,2041808,2040718,2040628,2040364,2041862,2040258,2043025,2040384,2041025,2041944,2042904,2042398,2041256,2041426,2042065,2042242,2040792,2043170,2041473,2040978,2041645,2043096,2042572,2042302,2040814,2042978,2041005,2041352,2042418,2042812,2042376,2042498,2042018,2042045,2042604,2040332,2040834,2042126,2043197,2041734,2042832,2041236,2042706,2041618,2041094,2042624],"length":1,"stats":{"Line":60}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[2042393,2047798,2048461,2048277,2048757,2044368,2047072,2045760,2044160,2047286,2047638,2046400,2044686,2046414,2048594,2044302,2044824,2044169,2041825,2043489,2041000,2048576,2046795,2046822,2043416,2043000,2043472,2048065,2047922,2045698,2047409,2041200,2047949,2047744,2048304,2045987,2046635,2044094,2044889,2043278,2045312,2048960,2045555,2046130,2045536,2045088,2043952,2040809,2045912,2047771,2048621,2047611,2048048,2048127,2048434,2045331,2045097,2040563,2047904,2048720,2046344,2045774,2047259,2048784,2043264,2048416,2044385,2046192,2045250,2042040,2045968,2047462,2046662,2046608,2047232,2043758,2047392,2043896,2046206,2041640,2046552,2041448,2046768,2042807,2047584,2044672,2045022,2042599,2043192,2046973,2042217,2043961,2048933,2043744,2047126,2046946,2048896,2047099,2044880,2046928,2045474,2048240,2040359],"length":1,"stats":{"Line":75}},{"line":277,"address":[2043020,2041020,2040623,2042619,2040379,2042827,2040829,2041251,2041660,2043212,2041468,2042237,2042060,2041857,2042413],"length":1,"stats":{"Line":15}},{"line":285,"address":[1510267,1510224],"length":1,"stats":{"Line":1}},{"line":286,"address":[2049081,2049072],"length":1,"stats":{"Line":3}},{"line":290,"address":[1510328,1510288],"length":1,"stats":{"Line":1}},{"line":291,"address":[1448381],"length":1,"stats":{"Line":3}},{"line":295,"address":[1448416,1448456],"length":1,"stats":{"Line":1}},{"line":296,"address":[1434640,1434649],"length":1,"stats":{"Line":3}},{"line":300,"address":[1448480,1448520],"length":1,"stats":{"Line":1}},{"line":301,"address":[2049264,2049273],"length":1,"stats":{"Line":3}},{"line":305,"address":[1448544,1448584],"length":1,"stats":{"Line":1}},{"line":306,"address":[1448573],"length":1,"stats":{"Line":2}},{"line":307,"address":[1434777],"length":1,"stats":{"Line":1}},{"line":312,"address":[1510544,1510584],"length":1,"stats":{"Line":1}},{"line":313,"address":[1434864,1434873],"length":1,"stats":{"Line":3}},{"line":317,"address":[1448672,1448712],"length":1,"stats":{"Line":2}},{"line":318,"address":[2049488,2049497],"length":1,"stats":{"Line":6}},{"line":322,"address":[1510672,1510712],"length":1,"stats":{"Line":1}},{"line":323,"address":[1448765],"length":1,"stats":{"Line":3}},{"line":327,"address":[1510736,1510776],"length":1,"stats":{"Line":1}},{"line":328,"address":[1510765],"length":1,"stats":{"Line":3}},{"line":332,"address":[1448864,1448904],"length":1,"stats":{"Line":1}},{"line":333,"address":[1510829],"length":1,"stats":{"Line":3}},{"line":337,"address":[1448968,1448928],"length":1,"stats":{"Line":1}},{"line":338,"address":[1510893],"length":1,"stats":{"Line":3}},{"line":346,"address":[1510968,1510928],"length":1,"stats":{"Line":1}},{"line":347,"address":[1510957],"length":1,"stats":{"Line":5}},{"line":348,"address":[1435302],"length":1,"stats":{"Line":1}},{"line":349,"address":[1435333],"length":1,"stats":{"Line":1}},{"line":354,"address":[1510992,1511032],"length":1,"stats":{"Line":1}},{"line":355,"address":[1449085],"length":1,"stats":{"Line":3}},{"line":356,"address":[1435443],"length":1,"stats":{"Line":1}},{"line":357,"address":[1435470],"length":1,"stats":{"Line":0}},{"line":358,"address":[1435428],"length":1,"stats":{"Line":1}},{"line":363,"address":[1449120,1449163],"length":1,"stats":{"Line":2}},{"line":364,"address":[1511087],"length":1,"stats":{"Line":4}},{"line":365,"address":[1435620],"length":1,"stats":{"Line":1}},{"line":366,"address":[1435648],"length":1,"stats":{"Line":0}},{"line":367,"address":[1435604],"length":1,"stats":{"Line":1}},{"line":372,"address":[1449227,1449184],"length":1,"stats":{"Line":1}},{"line":373,"address":[1511150],"length":1,"stats":{"Line":3}},{"line":374,"address":[2050403],"length":1,"stats":{"Line":1}},{"line":375,"address":[1435812],"length":1,"stats":{"Line":0}},{"line":376,"address":[1435796],"length":1,"stats":{"Line":1}},{"line":381,"address":[1435888,1435907],"length":1,"stats":{"Line":2}},{"line":384,"address":[1511247,1511184,1511911],"length":1,"stats":{"Line":1}},{"line":387,"address":[1449271],"length":1,"stats":{"Line":3}},{"line":388,"address":[2050574],"length":1,"stats":{"Line":1}},{"line":389,"address":[1436072],"length":1,"stats":{"Line":1}},{"line":392,"address":[1449339],"length":1,"stats":{"Line":1}},{"line":393,"address":[1449373],"length":1,"stats":{"Line":1}},{"line":394,"address":[1511409,1511332,1511464,1512160],"length":1,"stats":{"Line":3}},{"line":395,"address":[1449648,1449580],"length":1,"stats":{"Line":2}},{"line":396,"address":[1449673,1449756],"length":1,"stats":{"Line":2}},{"line":397,"address":[1449856,1449786],"length":1,"stats":{"Line":2}},{"line":399,"address":[1511894],"length":1,"stats":{"Line":1}},{"line":401,"address":[1450234],"length":1,"stats":{"Line":0}},{"line":404,"address":[1511356],"length":1,"stats":{"Line":1}},{"line":409,"address":[1450328,1450288],"length":1,"stats":{"Line":1}},{"line":410,"address":[1450317],"length":1,"stats":{"Line":3}},{"line":411,"address":[1436146],"length":1,"stats":{"Line":1}},{"line":412,"address":[1436167],"length":1,"stats":{"Line":1}},{"line":417,"address":[1450392,1450352],"length":1,"stats":{"Line":1}},{"line":418,"address":[1450381],"length":1,"stats":{"Line":3}},{"line":419,"address":[2050802],"length":1,"stats":{"Line":1}},{"line":420,"address":[1436263],"length":1,"stats":{"Line":1}},{"line":429,"address":[1512304,1512355],"length":1,"stats":{"Line":1}},{"line":430,"address":[1436288,1436306],"length":1,"stats":{"Line":3}},{"line":431,"address":[2050905],"length":1,"stats":{"Line":1}},{"line":432,"address":[2050936],"length":1,"stats":{"Line":1}},{"line":437,"address":[1512384,1512435],"length":1,"stats":{"Line":1}},{"line":438,"address":[1450527],"length":1,"stats":{"Line":3}},{"line":439,"address":[2051051],"length":1,"stats":{"Line":1}},{"line":440,"address":[2051078],"length":1,"stats":{"Line":1}},{"line":441,"address":[1436473],"length":1,"stats":{"Line":1}},{"line":446,"address":[1512521,1512464],"length":1,"stats":{"Line":1}},{"line":447,"address":[1450609],"length":1,"stats":{"Line":3}},{"line":448,"address":[1436718],"length":1,"stats":{"Line":1}},{"line":449,"address":[1436687],"length":1,"stats":{"Line":1}},{"line":450,"address":[1436665],"length":1,"stats":{"Line":1}},{"line":459,"address":[1512584,1512544],"length":1,"stats":{"Line":1}},{"line":460,"address":[2051312,2051326],"length":1,"stats":{"Line":3}},{"line":461,"address":[2051366],"length":1,"stats":{"Line":1}},{"line":462,"address":[2051386],"length":1,"stats":{"Line":1}},{"line":467,"address":[1450807,1450720],"length":1,"stats":{"Line":1}},{"line":468,"address":[2051408,2051427],"length":1,"stats":{"Line":4}},{"line":470,"address":[1450843],"length":1,"stats":{"Line":1}},{"line":471,"address":[1451022,1450926],"length":1,"stats":{"Line":3}},{"line":472,"address":[1436931],"length":1,"stats":{"Line":1}},{"line":473,"address":[1437000],"length":1,"stats":{"Line":1}},{"line":474,"address":[2051607],"length":1,"stats":{"Line":1}},{"line":481,"address":[1513004,1512960],"length":1,"stats":{"Line":1}},{"line":482,"address":[1437088],"length":1,"stats":{"Line":2}},{"line":483,"address":[1437107],"length":1,"stats":{"Line":1}},{"line":484,"address":[1437160],"length":1,"stats":{"Line":1}},{"line":485,"address":[2051764],"length":1,"stats":{"Line":1}},{"line":491,"address":[1513069,1513024],"length":1,"stats":{"Line":1}},{"line":492,"address":[1513062],"length":1,"stats":{"Line":2}},{"line":493,"address":[1437235],"length":1,"stats":{"Line":1}},{"line":494,"address":[1437288],"length":1,"stats":{"Line":1}},{"line":495,"address":[1437335],"length":1,"stats":{"Line":1}},{"line":501,"address":[1513088,1513131],"length":1,"stats":{"Line":1}},{"line":502,"address":[1437344],"length":1,"stats":{"Line":2}},{"line":503,"address":[1437363],"length":1,"stats":{"Line":1}},{"line":504,"address":[1437416],"length":1,"stats":{"Line":1}},{"line":505,"address":[2052029],"length":1,"stats":{"Line":1}},{"line":511,"address":[1513195,1513152],"length":1,"stats":{"Line":1}},{"line":512,"address":[1451300],"length":1,"stats":{"Line":2}},{"line":513,"address":[2052067],"length":1,"stats":{"Line":1}},{"line":514,"address":[1437560],"length":1,"stats":{"Line":1}},{"line":515,"address":[2052206,2052138],"length":1,"stats":{"Line":2}},{"line":516,"address":[1437611],"length":1,"stats":{"Line":1}},{"line":517,"address":[2052202],"length":1,"stats":{"Line":1}},{"line":528,"address":[1451368,1451328],"length":1,"stats":{"Line":1}},{"line":529,"address":[1451357],"length":1,"stats":{"Line":3}},{"line":530,"address":[1437718],"length":1,"stats":{"Line":1}},{"line":531,"address":[1437739],"length":1,"stats":{"Line":1}},{"line":536,"address":[1513366,1513861,1513280,1513889],"length":1,"stats":{"Line":1}},{"line":542,"address":[1451492,1451459],"length":1,"stats":{"Line":2}},{"line":547,"address":[1451503,1451538],"length":1,"stats":{"Line":2}},{"line":552,"address":[2052323,2052304],"length":1,"stats":{"Line":4}},{"line":554,"address":[1513590],"length":1,"stats":{"Line":1}},{"line":555,"address":[2053024,2052368,2052999],"length":1,"stats":{"Line":3}},{"line":556,"address":[1438306,1437849],"length":1,"stats":{"Line":2}},{"line":557,"address":[1438013,1437922,1438544,1438558],"length":1,"stats":{"Line":2}},{"line":558,"address":[1438228,1438144],"length":1,"stats":{"Line":0}},{"line":560,"address":[1438321,1438201],"length":1,"stats":{"Line":2}},{"line":562,"address":[1438302],"length":1,"stats":{"Line":1}},{"line":569,"address":[1452032,1452300,1452328,1452095],"length":1,"stats":{"Line":1}},{"line":570,"address":[1452080,1452105],"length":1,"stats":{"Line":2}},{"line":575,"address":[1514019,1513984],"length":1,"stats":{"Line":2}},{"line":580,"address":[1514100],"length":1,"stats":{"Line":2}},{"line":581,"address":[1438627],"length":1,"stats":{"Line":1}},{"line":582,"address":[2053188,2053216,2053230],"length":1,"stats":{"Line":3}},{"line":583,"address":[1438692],"length":1,"stats":{"Line":1}},{"line":589,"address":[1514293,1514500,1514208],"length":1,"stats":{"Line":1}},{"line":595,"address":[2053303,2053280],"length":1,"stats":{"Line":3}},{"line":596,"address":[2053342],"length":1,"stats":{"Line":1}},{"line":597,"address":[2053400],"length":1,"stats":{"Line":1}},{"line":600,"address":[1514326],"length":1,"stats":{"Line":1}},{"line":601,"address":[2054103,2054128,2053424],"length":1,"stats":{"Line":2}},{"line":602,"address":[2053454,2053939],"length":1,"stats":{"Line":2}},{"line":603,"address":[2053519],"length":1,"stats":{"Line":1}},{"line":604,"address":[2053550,2053626,2054158,2054144],"length":1,"stats":{"Line":4}},{"line":605,"address":[1439263,1439354],"length":1,"stats":{"Line":1}},{"line":607,"address":[1439325,1439457],"length":1,"stats":{"Line":2}},{"line":609,"address":[1439435],"length":1,"stats":{"Line":1}},{"line":616,"address":[1452672,1452758,1452965],"length":1,"stats":{"Line":1}},{"line":622,"address":[2054231,2054208],"length":1,"stats":{"Line":3}},{"line":623,"address":[2054270],"length":1,"stats":{"Line":1}},{"line":624,"address":[2054328],"length":1,"stats":{"Line":0}},{"line":627,"address":[1452791],"length":1,"stats":{"Line":1}},{"line":628,"address":[1440576,1439872,1440605],"length":1,"stats":{"Line":2}},{"line":629,"address":[2054382,2054868],"length":1,"stats":{"Line":2}},{"line":630,"address":[1439967],"length":1,"stats":{"Line":1}},{"line":631,"address":[2055072,2054479,2055086,2054555],"length":1,"stats":{"Line":4}},{"line":632,"address":[1440224,1440315],"length":1,"stats":{"Line":0}},{"line":634,"address":[2054878,2054746],"length":1,"stats":{"Line":2}},{"line":636,"address":[1440396],"length":1,"stats":{"Line":1}},{"line":643,"address":[1515171,1514964,1514880],"length":1,"stats":{"Line":1}},{"line":649,"address":[1514927],"length":1,"stats":{"Line":3}},{"line":650,"address":[1440750],"length":1,"stats":{"Line":1}},{"line":651,"address":[2055256],"length":1,"stats":{"Line":0}},{"line":654,"address":[1453125],"length":1,"stats":{"Line":1}},{"line":655,"address":[1440832,1441571,1441542],"length":1,"stats":{"Line":2}},{"line":656,"address":[2055802,2055310],"length":1,"stats":{"Line":2}},{"line":657,"address":[1440927],"length":1,"stats":{"Line":1}},{"line":658,"address":[1441049,1441584,1441598,1440969],"length":1,"stats":{"Line":4}},{"line":659,"address":[2055709,2055622],"length":1,"stats":{"Line":0}},{"line":661,"address":[2055812,2055680],"length":1,"stats":{"Line":2}},{"line":663,"address":[2055790],"length":1,"stats":{"Line":1}},{"line":674,"address":[1453344,1453384],"length":1,"stats":{"Line":1}},{"line":675,"address":[1453373],"length":1,"stats":{"Line":3}},{"line":679,"address":[1453408,1453448],"length":1,"stats":{"Line":1}},{"line":680,"address":[1515309],"length":1,"stats":{"Line":2}},{"line":681,"address":[1441689],"length":1,"stats":{"Line":1}},{"line":682,"address":[1441701],"length":1,"stats":{"Line":1}},{"line":683,"address":[2056121],"length":1,"stats":{"Line":1}},{"line":688,"address":[1453504,1453472],"length":1,"stats":{"Line":1}},{"line":689,"address":[1515369],"length":1,"stats":{"Line":2}},{"line":690,"address":[2056149],"length":1,"stats":{"Line":1}},{"line":699,"address":[1515432,1515392],"length":1,"stats":{"Line":1}},{"line":700,"address":[1515421],"length":1,"stats":{"Line":3}},{"line":704,"address":[1515456,1515488],"length":1,"stats":{"Line":1}},{"line":705,"address":[1441776],"length":1,"stats":{"Line":2}},{"line":706,"address":[2056197],"length":1,"stats":{"Line":1}},{"line":711,"address":[1453664,1453632],"length":1,"stats":{"Line":1}},{"line":712,"address":[1441792],"length":1,"stats":{"Line":2}},{"line":713,"address":[1441797],"length":1,"stats":{"Line":1}},{"line":722,"address":[1515552,1515595],"length":1,"stats":{"Line":1}},{"line":723,"address":[1441808],"length":1,"stats":{"Line":2}},{"line":724,"address":[1441818],"length":1,"stats":{"Line":1}},{"line":729,"address":[1453744,1453784],"length":1,"stats":{"Line":1}},{"line":730,"address":[2056261,2056256],"length":1,"stats":{"Line":3}},{"line":734,"address":[1515680,1515720],"length":1,"stats":{"Line":1}},{"line":735,"address":[2056272,2056277],"length":1,"stats":{"Line":3}},{"line":743,"address":[1515744,1516516,1515836],"length":1,"stats":{"Line":1}},{"line":744,"address":[1515869,1515780],"length":1,"stats":{"Line":4}},{"line":745,"address":[2056368,2056387],"length":1,"stats":{"Line":3}},{"line":747,"address":[1515953],"length":1,"stats":{"Line":1}},{"line":748,"address":[1454360],"length":1,"stats":{"Line":1}},{"line":749,"address":[1454347],"length":1,"stats":{"Line":1}},{"line":754,"address":[1454928,1455652,1455020],"length":1,"stats":{"Line":1}},{"line":755,"address":[1516804],"length":1,"stats":{"Line":3}},{"line":756,"address":[2056510],"length":1,"stats":{"Line":1}},{"line":757,"address":[2056568],"length":1,"stats":{"Line":1}},{"line":760,"address":[1442199,1442176],"length":1,"stats":{"Line":3}},{"line":761,"address":[1442238],"length":1,"stats":{"Line":1}},{"line":762,"address":[1442296],"length":1,"stats":{"Line":1}},{"line":765,"address":[1455131],"length":1,"stats":{"Line":1}},{"line":766,"address":[1455362],"length":1,"stats":{"Line":1}},{"line":767,"address":[1455349],"length":1,"stats":{"Line":1}}],"covered":276,"coverable":290},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","pixmap.rs"],"content":"//! C FFI for pixmap - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, PIXMAPS};\nuse super::geometry::fz_irect;\nuse super::colorspace::{ColorspaceHandle, FZ_COLORSPACE_RGB};\n\n/// Internal pixmap state\npub struct Pixmap {\n    x: i32,\n    y: i32,\n    width: i32,\n    height: i32,\n    n: i32,        // Number of components\n    alpha: bool,\n    stride: i32,\n    samples: Vec\u003cu8\u003e,\n    colorspace: ColorspaceHandle,\n}\n\nimpl Pixmap {\n    pub fn new(cs: ColorspaceHandle, width: i32, height: i32, alpha: bool) -\u003e Self {\n        let n = super::colorspace::fz_colorspace_n(0, cs) + i32::from(alpha);\n        let stride = width * n;\n        let size = (stride * height) as usize;\n\n        Self {\n            x: 0,\n            y: 0,\n            width,\n            height,\n            n,\n            alpha,\n            stride,\n            samples: vec![0u8; size],\n            colorspace: cs,\n        }\n    }\n\n    pub fn with_bbox(cs: ColorspaceHandle, bbox: fz_irect, alpha: bool) -\u003e Self {\n        let width = bbox.x1 - bbox.x0;\n        let height = bbox.y1 - bbox.y0;\n        let n = super::colorspace::fz_colorspace_n(0, cs) + i32::from(alpha);\n        let stride = width * n;\n        let size = (stride * height).max(0) as usize;\n\n        Self {\n            x: bbox.x0,\n            y: bbox.y0,\n            width,\n            height,\n            n,\n            alpha,\n            stride,\n            samples: vec![0u8; size],\n            colorspace: cs,\n        }\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.samples.fill(0);\n    }\n\n    pub fn clear_with_value(\u0026mut self, value: u8) {\n        self.samples.fill(value);\n    }\n\n    pub fn get_sample(\u0026self, x: i32, y: i32, component: i32) -\u003e Option\u003cu8\u003e {\n        if x \u003c self.x || x \u003e= self.x + self.width ||\n           y \u003c self.y || y \u003e= self.y + self.height ||\n           component \u003c 0 || component \u003e= self.n {\n            return None;\n        }\n        let local_x = x - self.x;\n        let local_y = y - self.y;\n        let offset = (local_y * self.stride + local_x * self.n + component) as usize;\n        self.samples.get(offset).copied()\n    }\n\n    pub fn set_sample(\u0026mut self, x: i32, y: i32, component: i32, value: u8) {\n        if x \u003c self.x || x \u003e= self.x + self.width ||\n           y \u003c self.y || y \u003e= self.y + self.height ||\n           component \u003c 0 || component \u003e= self.n {\n            return;\n        }\n        let local_x = x - self.x;\n        let local_y = y - self.y;\n        let offset = (local_y * self.stride + local_x * self.n + component) as usize;\n        if let Some(sample) = self.samples.get_mut(offset) {\n            *sample = value;\n        }\n    }\n}\n\n/// Create a new pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_pixmap(\n    _ctx: Handle,\n    cs: ColorspaceHandle,\n    w: i32,\n    h: i32,\n    _seps: Handle, // Separations not implemented yet\n    alpha: i32,\n) -\u003e Handle {\n    let cs = if cs == 0 { FZ_COLORSPACE_RGB } else { cs };\n    PIXMAPS.insert(Pixmap::new(cs, w, h, alpha != 0))\n}\n\n/// Create a new pixmap with bounding box\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_new_pixmap_with_bbox(\n    _ctx: Handle,\n    cs: ColorspaceHandle,\n    bbox: fz_irect,\n    _seps: Handle,\n    alpha: i32,\n) -\u003e Handle {\n    let cs = if cs == 0 { FZ_COLORSPACE_RGB } else { cs };\n    PIXMAPS.insert(Pixmap::with_bbox(cs, bbox, alpha != 0))\n}\n\n/// Keep (increment ref) pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_pixmap(_ctx: Handle, pix: Handle) -\u003e Handle {\n    PIXMAPS.keep(pix)\n}\n\n/// Drop pixmap reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_pixmap(_ctx: Handle, pix: Handle) {\n    let _ = PIXMAPS.remove(pix);\n}\n\n/// Get pixmap X origin\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_x(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.x;\n        }\n    }\n    0\n}\n\n/// Get pixmap Y origin\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_y(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.y;\n        }\n    }\n    0\n}\n\n/// Get pixmap width\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_width(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.width;\n        }\n    }\n    0\n}\n\n/// Get pixmap height\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_height(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.height;\n        }\n    }\n    0\n}\n\n/// Get number of components (including alpha)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_components(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.n;\n        }\n    }\n    0\n}\n\n/// Get number of colorants (excluding alpha)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_colorants(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.n - i32::from(guard.alpha);\n        }\n    }\n    0\n}\n\n/// Check if pixmap has alpha\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_alpha(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return i32::from(guard.alpha);\n        }\n    }\n    0\n}\n\n/// Get pixmap stride (bytes per row)\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_stride(_ctx: Handle, pix: Handle) -\u003e i32 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.stride;\n        }\n    }\n    0\n}\n\n/// Get pixmap bounding box\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_bbox(_ctx: Handle, pix: Handle) -\u003e fz_irect {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return fz_irect {\n                x0: guard.x,\n                y0: guard.y,\n                x1: guard.x + guard.width,\n                y1: guard.y + guard.height,\n            };\n        }\n    }\n    fz_irect { x0: 0, y0: 0, x1: 0, y1: 0 }\n}\n\n/// Get pixmap colorspace\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_pixmap_colorspace(_ctx: Handle, pix: Handle) -\u003e ColorspaceHandle {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            return guard.colorspace;\n        }\n    }\n    0\n}\n\n/// Clear pixmap to transparent black\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_pixmap(_ctx: Handle, pix: Handle) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.clear();\n        }\n    }\n}\n\n/// Clear pixmap to specific value\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_clear_pixmap_with_value(_ctx: Handle, pix: Handle, value: i32) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.clear_with_value(value as u8);\n        }\n    }\n}\n\n/// Invert pixmap colors\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_invert_pixmap(_ctx: Handle, pix: Handle) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            let colorants = (p.n - i32::from(p.alpha)) as usize;\n            for y in 0..p.height {\n                for x in 0..p.width {\n                    let offset = (y * p.stride + x * p.n) as usize;\n                    for c in 0..colorants {\n                        if let Some(sample) = p.samples.get_mut(offset + c) {\n                            *sample = 255 - *sample;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Apply gamma correction to pixmap\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_gamma_pixmap(_ctx: Handle, pix: Handle, gamma: f32) {\n    if gamma \u003c= 0.0 {\n        return;\n    }\n\n    // Pre-compute gamma lookup table\n    let mut gamma_table = [0u8; 256];\n    for (i, entry) in gamma_table.iter_mut().enumerate() {\n        let normalized = (i as f32) / 255.0;\n        let corrected = normalized.powf(1.0 / gamma);\n        *entry = (corrected * 255.0).round().clamp(0.0, 255.0) as u8;\n    }\n\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            let colorants = (p.n - i32::from(p.alpha)) as usize;\n            for y in 0..p.height {\n                for x in 0..p.width {\n                    let offset = (y * p.stride + x * p.n) as usize;\n                    for c in 0..colorants {\n                        if let Some(sample) = p.samples.get_mut(offset + c) {\n                            *sample = gamma_table[*sample as usize];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Get sample at specific position\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_get_pixmap_sample(_ctx: Handle, pix: Handle, x: i32, y: i32, n: i32) -\u003e u8 {\n    if let Some(p) = PIXMAPS.get(pix) {\n        if let Ok(guard) = p.lock() {\n            if let Some(sample) = guard.get_sample(x, y, n) {\n                return sample;\n            }\n        }\n    }\n    0\n}\n\n/// Set sample at specific position\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_set_pixmap_sample(_ctx: Handle, pix: Handle, x: i32, y: i32, n: i32, v: u8) {\n    if let Some(pixmap) = PIXMAPS.get(pix) {\n        if let Ok(mut p) = pixmap.lock() {\n            p.set_sample(x, y, n, v);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use super::super::colorspace::FZ_COLORSPACE_GRAY;\n\n    #[test]\n    fn test_pixmap_create() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 100, 100, 0, 1);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_pixmap_width(0, handle), 100);\n        assert_eq!(fz_pixmap_height(0, handle), 100);\n        assert_eq!(fz_pixmap_components(0, handle), 4); // RGB + alpha\n        assert_eq!(fz_pixmap_alpha(0, handle), 1);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_create_gray() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 50, 50, 0, 0);\n        assert_ne!(handle, 0);\n\n        assert_eq!(fz_pixmap_components(0, handle), 1); // Gray only\n        assert_eq!(fz_pixmap_colorants(0, handle), 1);\n        assert_eq!(fz_pixmap_alpha(0, handle), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_clear() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        fz_clear_pixmap_with_value(0, handle, 128);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 128);\n\n        fz_clear_pixmap(0, handle);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_set_get_sample() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        fz_set_pixmap_sample(0, handle, 5, 5, 0, 255);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 5, 5, 0), 255);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 5, 5, 1), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_keep() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let kept = fz_keep_pixmap(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_x_y() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        // Default origin is 0,0\n        assert_eq!(fz_pixmap_x(0, handle), 0);\n        assert_eq!(fz_pixmap_y(0, handle), 0);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_stride() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let stride = fz_pixmap_stride(0, handle);\n        // RGB = 3 components, width = 10, so stride = 30\n        assert_eq!(stride, 30);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_stride_with_alpha() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 1);\n        let stride = fz_pixmap_stride(0, handle);\n        // RGBA = 4 components, width = 10, so stride = 40\n        assert_eq!(stride, 40);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_bbox() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 100, 50, 0, 0);\n        let bbox = fz_pixmap_bbox(0, handle);\n        assert_eq!(bbox.x0, 0);\n        assert_eq!(bbox.y0, 0);\n        assert_eq!(bbox.x1, 100);\n        assert_eq!(bbox.y1, 50);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_colorspace() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n        let cs = fz_pixmap_colorspace(0, handle);\n        assert_eq!(cs, FZ_COLORSPACE_RGB);\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_invalid_handle() {\n        assert_eq!(fz_pixmap_width(0, 0), 0);\n        assert_eq!(fz_pixmap_height(0, 0), 0);\n        assert_eq!(fz_pixmap_components(0, 0), 0);\n        assert_eq!(fz_pixmap_x(0, 0), 0);\n        assert_eq!(fz_pixmap_y(0, 0), 0);\n        assert_eq!(fz_pixmap_alpha(0, 0), 0);\n        assert_eq!(fz_pixmap_stride(0, 0), 0);\n        assert_eq!(fz_pixmap_colorants(0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, 0, 0, 0, 0), 0);\n    }\n\n    #[test]\n    fn test_pixmap_invert() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 2, 2, 0, 0);\n\n        // Set to known values\n        fz_set_pixmap_sample(0, handle, 0, 0, 0, 100);\n        fz_set_pixmap_sample(0, handle, 1, 0, 0, 200);\n\n        fz_invert_pixmap(0, handle);\n\n        // Values should be inverted (255 - x)\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 0), 155);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 1, 0, 0), 55);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_gamma() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_GRAY, 2, 2, 0, 0);\n\n        // Set to mid-gray\n        fz_clear_pixmap_with_value(0, handle, 128);\n\n        // Apply gamma (1.0 should not change values significantly)\n        fz_gamma_pixmap(0, handle, 1.0);\n\n        // Value should be roughly the same\n        let sample = fz_get_pixmap_sample(0, handle, 0, 0, 0);\n        assert!(sample \u003e= 125 \u0026\u0026 sample \u003c= 131);\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_sample_bounds() {\n        let handle = fz_new_pixmap(0, FZ_COLORSPACE_RGB, 10, 10, 0, 0);\n\n        // Out of bounds access should return 0\n        assert_eq!(fz_get_pixmap_sample(0, handle, -1, 0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, -1, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 10, 0, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 10, 0), 0);\n        assert_eq!(fz_get_pixmap_sample(0, handle, 0, 0, 3), 0); // Component out of bounds\n\n        fz_drop_pixmap(0, handle);\n    }\n\n    #[test]\n    fn test_pixmap_internal_new() {\n        let pixmap = Pixmap::new(FZ_COLORSPACE_RGB, 100, 50, true);\n        assert_eq!(pixmap.width, 100);\n        assert_eq!(pixmap.height, 50);\n        assert_eq!(pixmap.n, 4); // RGB + alpha\n        assert!(pixmap.alpha);\n        assert_eq!(pixmap.stride, 400); // width * n\n        assert_eq!(pixmap.samples.len(), 400 * 50);\n    }\n\n    #[test]\n    fn test_pixmap_internal_get_set_sample() {\n        let mut pixmap = Pixmap::new(FZ_COLORSPACE_RGB, 10, 10, false);\n\n        pixmap.set_sample(5, 5, 0, 123);\n        assert_eq!(pixmap.get_sample(5, 5, 0), Some(123));\n\n        // Out of bounds\n        assert_eq!(pixmap.get_sample(-1, 0, 0), None);\n        assert_eq!(pixmap.get_sample(100, 0, 0), None);\n    }\n\n    #[test]\n    fn test_pixmap_internal_clear() {\n        let mut pixmap = Pixmap::new(FZ_COLORSPACE_GRAY, 5, 5, false);\n        pixmap.clear_with_value(255);\n\n        assert_eq!(pixmap.get_sample(0, 0, 0), Some(255));\n        assert_eq!(pixmap.get_sample(4, 4, 0), Some(255));\n    }\n}\n","traces":[{"line":22,"address":[1236768],"length":1,"stats":{"Line":3}},{"line":23,"address":[1370943,1370869],"length":1,"stats":{"Line":4}},{"line":24,"address":[1370929,1370985,1370964],"length":1,"stats":{"Line":8}},{"line":25,"address":[1371140,1370968,1371001],"length":1,"stats":{"Line":8}},{"line":35,"address":[1371009],"length":1,"stats":{"Line":11}},{"line":40,"address":[1371168],"length":1,"stats":{"Line":1}},{"line":41,"address":[1371257,1371213],"length":1,"stats":{"Line":1}},{"line":42,"address":[1371240,1371279,1371333],"length":1,"stats":{"Line":2}},{"line":43,"address":[1371354,1371375,1371283],"length":1,"stats":{"Line":2}},{"line":44,"address":[1371421,1371361,1371396],"length":1,"stats":{"Line":2}},{"line":45,"address":[1371438,1371606,1371403],"length":1,"stats":{"Line":2}},{"line":48,"address":[1371464],"length":1,"stats":{"Line":1}},{"line":49,"address":[1237418],"length":1,"stats":{"Line":1}},{"line":55,"address":[1371473],"length":1,"stats":{"Line":1}},{"line":60,"address":[1371632],"length":1,"stats":{"Line":1}},{"line":61,"address":[1371637],"length":1,"stats":{"Line":1}},{"line":64,"address":[1371664],"length":1,"stats":{"Line":2}},{"line":65,"address":[1371684],"length":1,"stats":{"Line":2}},{"line":68,"address":[1237680],"length":1,"stats":{"Line":2}},{"line":69,"address":[1371811,1371766],"length":1,"stats":{"Line":4}},{"line":70,"address":[1371839],"length":1,"stats":{"Line":2}},{"line":71,"address":[1371895],"length":1,"stats":{"Line":2}},{"line":72,"address":[1371793],"length":1,"stats":{"Line":1}},{"line":74,"address":[1371923,1371966],"length":1,"stats":{"Line":2}},{"line":75,"address":[1237959,1237940,1237904],"length":1,"stats":{"Line":4}},{"line":76,"address":[1372188,1371992,1372029],"length":1,"stats":{"Line":4}},{"line":77,"address":[1372145],"length":1,"stats":{"Line":2}},{"line":80,"address":[1372224],"length":1,"stats":{"Line":2}},{"line":81,"address":[1372276,1372319],"length":1,"stats":{"Line":4}},{"line":82,"address":[1372347],"length":1,"stats":{"Line":2}},{"line":83,"address":[1238355],"length":1,"stats":{"Line":2}},{"line":86,"address":[1372431,1372474],"length":1,"stats":{"Line":2}},{"line":87,"address":[1238412,1238448,1238467],"length":1,"stats":{"Line":4}},{"line":88,"address":[1372500,1372537,1372715],"length":1,"stats":{"Line":4}},{"line":89,"address":[1372732,1372654,1372747],"length":1,"stats":{"Line":8}},{"line":90,"address":[1372745],"length":1,"stats":{"Line":2}},{"line":97,"address":[1372940,1372867,1372752],"length":1,"stats":{"Line":7}},{"line":105,"address":[1372817],"length":1,"stats":{"Line":7}},{"line":106,"address":[1238833,1238796],"length":1,"stats":{"Line":15}},{"line":111,"address":[1372992,1373207,1373121],"length":1,"stats":{"Line":1}},{"line":118,"address":[1239007],"length":1,"stats":{"Line":1}},{"line":119,"address":[1373098,1373131],"length":1,"stats":{"Line":2}},{"line":124,"address":[1373290,1373248],"length":1,"stats":{"Line":1}},{"line":125,"address":[1373306,1373267],"length":1,"stats":{"Line":2}},{"line":130,"address":[1373444,1373344,1373386],"length":1,"stats":{"Line":2}},{"line":131,"address":[1373363,1373402],"length":1,"stats":{"Line":4}},{"line":136,"address":[1373939,1373902,1373472,1373517],"length":1,"stats":{"Line":2}},{"line":137,"address":[1373494,1373533],"length":1,"stats":{"Line":4}},{"line":138,"address":[1373597,1373726,1373680],"length":1,"stats":{"Line":6}},{"line":139,"address":[1373744,1373803],"length":1,"stats":{"Line":4}},{"line":142,"address":[1373980],"length":1,"stats":{"Line":1}},{"line":147,"address":[1374430,1374045,1374467,1374000],"length":1,"stats":{"Line":2}},{"line":148,"address":[1374061,1374022],"length":1,"stats":{"Line":4}},{"line":149,"address":[1374125,1374208,1374254],"length":1,"stats":{"Line":6}},{"line":150,"address":[1374331,1374272],"length":1,"stats":{"Line":4}},{"line":153,"address":[1374508],"length":1,"stats":{"Line":1}},{"line":158,"address":[1374958,1374528,1374573,1374995],"length":1,"stats":{"Line":2}},{"line":159,"address":[1374589,1374550],"length":1,"stats":{"Line":4}},{"line":160,"address":[1374782,1374736,1374653],"length":1,"stats":{"Line":6}},{"line":161,"address":[1374859,1374800],"length":1,"stats":{"Line":4}},{"line":164,"address":[1375036],"length":1,"stats":{"Line":1}},{"line":169,"address":[1375101,1375056,1375523,1375486],"length":1,"stats":{"Line":2}},{"line":170,"address":[1375078,1375117],"length":1,"stats":{"Line":4}},{"line":171,"address":[1375310,1375181,1375264],"length":1,"stats":{"Line":6}},{"line":172,"address":[1375328,1375387],"length":1,"stats":{"Line":4}},{"line":175,"address":[1375564],"length":1,"stats":{"Line":1}},{"line":180,"address":[1241667,1241248,1241289,1241630],"length":1,"stats":{"Line":2}},{"line":181,"address":[1375645,1375606],"length":1,"stats":{"Line":5}},{"line":182,"address":[1375792,1375709,1375838],"length":1,"stats":{"Line":6}},{"line":183,"address":[1375856,1375915],"length":1,"stats":{"Line":4}},{"line":186,"address":[1376092],"length":1,"stats":{"Line":1}},{"line":191,"address":[1376693,1376163,1376112,1376653],"length":1,"stats":{"Line":1}},{"line":192,"address":[1376140,1376179],"length":1,"stats":{"Line":2}},{"line":193,"address":[1376243,1376329,1376375],"length":1,"stats":{"Line":3}},{"line":194,"address":[1241973,1242027,1242110],"length":1,"stats":{"Line":2}},{"line":197,"address":[1376734],"length":1,"stats":{"Line":1}},{"line":202,"address":[1242288,1242740,1242700,1242332],"length":1,"stats":{"Line":2}},{"line":203,"address":[1376777,1376816],"length":1,"stats":{"Line":4}},{"line":204,"address":[1242520,1242487,1242413],"length":1,"stats":{"Line":6}},{"line":205,"address":[1377030,1377094],"length":1,"stats":{"Line":4}},{"line":208,"address":[1242773],"length":1,"stats":{"Line":1}},{"line":213,"address":[1377312,1377742,1377779,1377357],"length":1,"stats":{"Line":2}},{"line":214,"address":[1242841,1242806],"length":1,"stats":{"Line":4}},{"line":215,"address":[1377566,1377437,1377520],"length":1,"stats":{"Line":6}},{"line":216,"address":[1243079,1243033],"length":1,"stats":{"Line":4}},{"line":219,"address":[1243236],"length":1,"stats":{"Line":1}},{"line":224,"address":[1377840,1378665,1377891,1378619],"length":1,"stats":{"Line":1}},{"line":225,"address":[1243311,1243276],"length":1,"stats":{"Line":2}},{"line":226,"address":[1377983,1378078,1378133],"length":1,"stats":{"Line":3}},{"line":227,"address":[1378475],"length":1,"stats":{"Line":1}},{"line":228,"address":[1378163,1378236],"length":1,"stats":{"Line":2}},{"line":229,"address":[1378243],"length":1,"stats":{"Line":1}},{"line":230,"address":[1378384,1378279],"length":1,"stats":{"Line":1}},{"line":231,"address":[1243728,1243858,1243765],"length":1,"stats":{"Line":2}},{"line":240,"address":[1244464,1244080,1244121,1244502],"length":1,"stats":{"Line":1}},{"line":241,"address":[1378774,1378813],"length":1,"stats":{"Line":2}},{"line":242,"address":[1244273,1244306,1244202],"length":1,"stats":{"Line":3}},{"line":243,"address":[1244329,1244375],"length":1,"stats":{"Line":2}},{"line":246,"address":[1244535],"length":1,"stats":{"Line":0}},{"line":251,"address":[1379325,1379741,1379280,1379716],"length":1,"stats":{"Line":1}},{"line":252,"address":[1244617,1244582],"length":1,"stats":{"Line":2}},{"line":253,"address":[1244753,1244786,1244682],"length":1,"stats":{"Line":3}},{"line":254,"address":[1379552,1379613],"length":1,"stats":{"Line":2}},{"line":261,"address":[1379776,1380261,1379832,1380236],"length":1,"stats":{"Line":3}},{"line":262,"address":[1245041,1245076],"length":1,"stats":{"Line":6}},{"line":263,"address":[1245215,1245141,1245248],"length":1,"stats":{"Line":9}},{"line":264,"address":[1380130,1380062],"length":1,"stats":{"Line":6}},{"line":271,"address":[1380361,1381979,1380304,1382007],"length":1,"stats":{"Line":1}},{"line":272,"address":[1245519,1245563],"length":1,"stats":{"Line":2}},{"line":273,"address":[1245777,1245738,1245649],"length":1,"stats":{"Line":3}},{"line":274,"address":[1245815,1245878,1246013],"length":1,"stats":{"Line":2}},{"line":275,"address":[1245998,1246041],"length":1,"stats":{"Line":2}},{"line":276,"address":[1381207,1381056],"length":1,"stats":{"Line":2}},{"line":277,"address":[1381366,1381591],"length":1,"stats":{"Line":1}},{"line":278,"address":[1246738,1246682],"length":1,"stats":{"Line":2}},{"line":279,"address":[1246856,1247065],"length":1,"stats":{"Line":2}},{"line":280,"address":[1381958,1381926],"length":1,"stats":{"Line":1}},{"line":291,"address":[1382299,1384380,1384408,1384352,1382048],"length":1,"stats":{"Line":1}},{"line":292,"address":[1382100],"length":1,"stats":{"Line":1}},{"line":297,"address":[1382112],"length":1,"stats":{"Line":1}},{"line":298,"address":[1384524,1382251,1382321],"length":1,"stats":{"Line":3}},{"line":299,"address":[1382557,1382652],"length":1,"stats":{"Line":2}},{"line":300,"address":[1247777,1249451],"length":1,"stats":{"Line":2}},{"line":301,"address":[1384440],"length":1,"stats":{"Line":1}},{"line":304,"address":[1247800],"length":1,"stats":{"Line":1}},{"line":305,"address":[1382820,1382921,1382976],"length":1,"stats":{"Line":3}},{"line":306,"address":[1383006,1383085,1383228],"length":1,"stats":{"Line":2}},{"line":307,"address":[1383201,1383256],"length":1,"stats":{"Line":2}},{"line":308,"address":[1248606,1248479],"length":1,"stats":{"Line":2}},{"line":309,"address":[1383721,1383946],"length":1,"stats":{"Line":1}},{"line":310,"address":[1383921,1383977],"length":1,"stats":{"Line":2}},{"line":311,"address":[1384316,1384087],"length":1,"stats":{"Line":2}},{"line":312,"address":[1384281,1384326],"length":1,"stats":{"Line":1}},{"line":323,"address":[1385138,1384630,1384544,1385221],"length":1,"stats":{"Line":2}},{"line":324,"address":[1249666,1249631],"length":1,"stats":{"Line":4}},{"line":325,"address":[1384796,1384842,1384710],"length":1,"stats":{"Line":6}},{"line":326,"address":[1249864,1249930],"length":1,"stats":{"Line":4}},{"line":327,"address":[1385020],"length":1,"stats":{"Line":2}},{"line":331,"address":[1385246],"length":1,"stats":{"Line":1}},{"line":336,"address":[1385264,1385779,1385804,1385361],"length":1,"stats":{"Line":3}},{"line":337,"address":[1385338,1385377],"length":1,"stats":{"Line":6}},{"line":338,"address":[1385573,1385441,1385527],"length":1,"stats":{"Line":9}},{"line":339,"address":[1385591,1385669],"length":1,"stats":{"Line":6}}],"covered":142,"coverable":143},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","ffi","stream.rs"],"content":"//! C FFI for stream - MuPDF compatible\n//! Safe Rust implementation using handle-based resource management\n\nuse super::{Handle, STREAMS, BUFFERS};\nuse std::ffi::c_char;\n\n/// Internal stream state\npub struct Stream {\n    pub(crate) data: Vec\u003cu8\u003e,\n    position: usize,\n    eof: bool,\n}\n\nimpl Stream {\n    pub fn new() -\u003e Self {\n        Self {\n            data: Vec::new(),\n            position: 0,\n            eof: true,\n        }\n    }\n\n    pub fn from_memory(data: Vec\u003cu8\u003e) -\u003e Self {\n        let eof = data.is_empty();\n        Self {\n            data,\n            position: 0,\n            eof,\n        }\n    }\n\n    pub fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e usize {\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n            return 0;\n        }\n\n        let available = self.data.len() - self.position;\n        let to_read = buf.len().min(available);\n        buf[..to_read].copy_from_slice(\u0026self.data[self.position..self.position + to_read]);\n        self.position += to_read;\n\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n        }\n\n        to_read\n    }\n\n    pub fn read_byte(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n            return None;\n        }\n        let byte = self.data[self.position];\n        self.position += 1;\n        if self.position \u003e= self.data.len() {\n            self.eof = true;\n        }\n        Some(byte)\n    }\n\n    pub fn peek_byte(\u0026self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003e= self.data.len() {\n            return None;\n        }\n        Some(self.data[self.position])\n    }\n\n    pub fn seek(\u0026mut self, offset: i64, whence: i32) {\n        let new_pos = match whence {\n            0 =\u003e offset as usize, // SEEK_SET\n            1 =\u003e (self.position as i64 + offset) as usize, // SEEK_CUR\n            2 =\u003e (self.data.len() as i64 + offset) as usize, // SEEK_END\n            _ =\u003e self.position,\n        };\n        self.position = new_pos.min(self.data.len());\n        self.eof = self.position \u003e= self.data.len();\n    }\n\n    pub fn tell(\u0026self) -\u003e i64 {\n        self.position as i64\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.eof\n    }\n}\n\nimpl Default for Stream {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Keep (increment ref) a stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_keep_stream(_ctx: Handle, stm: Handle) -\u003e Handle {\n    STREAMS.keep(stm)\n}\n\n/// Drop a stream reference\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_drop_stream(_ctx: Handle, stm: Handle) {\n    let _ = STREAMS.remove(stm);\n}\n\n/// Open a file for reading\n///\n/// # Safety\n/// Caller must ensure `filename` is a valid null-terminated C string.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_file(_ctx: Handle, filename: *const c_char) -\u003e Handle {\n    if filename.is_null() {\n        return 0;\n    }\n\n    // SAFETY: Caller guarantees filename is a valid null-terminated C string\n    #[allow(unsafe_code)]\n    let c_str = unsafe { std::ffi::CStr::from_ptr(filename) };\n    let path = match c_str.to_str() {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e return 0,\n    };\n\n    match std::fs::read(path) {\n        Ok(data) =\u003e STREAMS.insert(Stream::from_memory(data)),\n        Err(_) =\u003e 0,\n    }\n}\n\n/// Open a stream from memory\n///\n/// # Safety\n/// Caller must ensure `data` points to valid memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_memory(\n    _ctx: Handle,\n    data: *const u8,\n    len: usize,\n) -\u003e Handle {\n    if data.is_null() || len == 0 {\n        return STREAMS.insert(Stream::new());\n    }\n\n    // SAFETY: Caller guarantees data points to valid memory of `len` bytes\n    #[allow(unsafe_code)]\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    STREAMS.insert(Stream::from_memory(slice.to_vec()))\n}\n\n/// Open a stream from a buffer handle\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_open_buffer(_ctx: Handle, buf: Handle) -\u003e Handle {\n    if let Some(buffer) = BUFFERS.get(buf) {\n        if let Ok(guard) = buffer.lock() {\n            return STREAMS.insert(Stream::from_memory(guard.data().to_vec()));\n        }\n    }\n    0\n}\n\n/// Read from stream into buffer\n///\n/// # Safety\n/// Caller must ensure `data` points to writable memory of at least `len` bytes.\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read(\n    _ctx: Handle,\n    stm: Handle,\n    data: *mut u8,\n    len: usize,\n) -\u003e usize {\n    if data.is_null() || len == 0 {\n        return 0;\n    }\n\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            // SAFETY: Caller guarantees data points to writable memory of `len` bytes\n            #[allow(unsafe_code)]\n            let buf = unsafe { std::slice::from_raw_parts_mut(data, len) };\n            return guard.read(buf);\n        }\n    }\n    0\n}\n\n/// Read a single byte from stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_byte(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            if let Some(byte) = guard.read_byte() {\n                return byte as i32;\n            }\n        }\n    }\n    -1 // EOF\n}\n\n/// Peek at next byte without consuming\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_peek_byte(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            if let Some(byte) = guard.peek_byte() {\n                return byte as i32;\n            }\n        }\n    }\n    -1\n}\n\n/// Check if stream is at EOF\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_is_eof(_ctx: Handle, stm: Handle) -\u003e i32 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return i32::from(guard.is_eof());\n        }\n    }\n    1\n}\n\n/// Seek in stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_seek(_ctx: Handle, stm: Handle, offset: i64, whence: i32) {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(mut guard) = stream.lock() {\n            guard.seek(offset, whence);\n        }\n    }\n}\n\n/// Get current position in stream\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_tell(_ctx: Handle, stm: Handle) -\u003e i64 {\n    if let Some(stream) = STREAMS.get(stm) {\n        if let Ok(guard) = stream.lock() {\n            return guard.tell();\n        }\n    }\n    0\n}\n\n// Integer reading functions\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint16(_ctx: Handle, stm: Handle) -\u003e u16 {\n    let mut buf = [0u8; 2];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 2) == 2 {\n        u16::from_be_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint32(_ctx: Handle, stm: Handle) -\u003e u32 {\n    let mut buf = [0u8; 4];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 4) == 4 {\n        u32::from_be_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint16_le(_ctx: Handle, stm: Handle) -\u003e u16 {\n    let mut buf = [0u8; 2];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 2) == 2 {\n        u16::from_le_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn fz_read_uint32_le(_ctx: Handle, stm: Handle) -\u003e u32 {\n    let mut buf = [0u8; 4];\n    if fz_read(_ctx, stm, buf.as_mut_ptr(), 4) == 4 {\n        u32::from_le_bytes(buf)\n    } else {\n        0\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stream_from_memory() {\n        let data = vec![1, 2, 3, 4, 5];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        assert_eq!(fz_read_byte(0, handle), 1);\n        assert_eq!(fz_read_byte(0, handle), 2);\n        assert_eq!(fz_tell(0, handle), 2);\n\n        fz_seek(0, handle, 0, 0); // SEEK_SET\n        assert_eq!(fz_read_byte(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_eof() {\n        let data = vec![1];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        assert_eq!(fz_is_eof(0, handle), 0);\n        fz_read_byte(0, handle);\n        assert_eq!(fz_is_eof(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_keep() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let kept = fz_keep_stream(0, handle);\n        assert_eq!(kept, handle);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_peek_byte() {\n        let data = vec![42, 43, 44];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        // Peek should return byte without advancing\n        let peeked = fz_peek_byte(0, handle);\n        assert_eq!(peeked, 42);\n        assert_eq!(fz_tell(0, handle), 0); // Position unchanged\n\n        // Read should advance\n        let read = fz_read_byte(0, handle);\n        assert_eq!(read, 42);\n        assert_eq!(fz_tell(0, handle), 1);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_multiple() {\n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let mut buf = [0u8; 4];\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 4);\n        assert_eq!(n, 4);\n        assert_eq!(buf, [1, 2, 3, 4]);\n\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 4);\n        assert_eq!(n, 4);\n        assert_eq!(buf, [5, 6, 7, 8]);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_seek_modes() {\n        let data = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        // SEEK_SET (0)\n        fz_seek(0, handle, 5, 0);\n        assert_eq!(fz_tell(0, handle), 5);\n\n        // SEEK_CUR (1)\n        fz_seek(0, handle, 2, 1);\n        assert_eq!(fz_tell(0, handle), 7);\n\n        // SEEK_END (2)\n        fz_seek(0, handle, -3, 2);\n        assert_eq!(fz_tell(0, handle), 7);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint16() {\n        let data = vec![0x12, 0x34, 0x56, 0x78];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint16(0, handle);\n        assert_eq!(val, 0x1234);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint32() {\n        let data = vec![0x12, 0x34, 0x56, 0x78];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint32(0, handle);\n        assert_eq!(val, 0x12345678);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint16_le() {\n        let data = vec![0x34, 0x12, 0x78, 0x56];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint16_le(0, handle);\n        assert_eq!(val, 0x1234);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_read_uint32_le() {\n        let data = vec![0x78, 0x56, 0x34, 0x12];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n\n        let val = fz_read_uint32_le(0, handle);\n        assert_eq!(val, 0x12345678);\n\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_stream_invalid_handle() {\n        assert_eq!(fz_read_byte(0, 0), -1);\n        assert_eq!(fz_peek_byte(0, 0), -1);\n        assert_eq!(fz_is_eof(0, 0), 1);\n        assert_eq!(fz_tell(0, 0), 0);\n    }\n\n    #[test]\n    fn test_stream_internal_new() {\n        let stream = Stream::new();\n        assert!(stream.data.is_empty());\n        assert_eq!(stream.position, 0);\n    }\n\n    #[test]\n    fn test_stream_internal_from_memory() {\n        let stream = Stream::from_memory(vec![1, 2, 3]);\n        assert_eq!(stream.data.len(), 3);\n        assert_eq!(stream.position, 0);\n    }\n\n    #[test]\n    fn test_stream_internal_read_byte() {\n        let mut stream = Stream::from_memory(vec![10, 20, 30]);\n        assert_eq!(stream.read_byte(), Some(10));\n        assert_eq!(stream.read_byte(), Some(20));\n        assert_eq!(stream.read_byte(), Some(30));\n        assert_eq!(stream.read_byte(), None);\n    }\n\n    #[test]\n    fn test_stream_internal_peek_byte() {\n        let mut stream = Stream::from_memory(vec![99]);\n        assert_eq!(stream.peek_byte(), Some(99));\n        assert_eq!(stream.peek_byte(), Some(99)); // Should not advance\n        assert_eq!(stream.read_byte(), Some(99));\n        assert_eq!(stream.peek_byte(), None);\n    }\n\n    #[test]\n    fn test_stream_internal_is_eof() {\n        let mut stream = Stream::from_memory(vec![1]);\n        assert!(!stream.is_eof());\n        stream.read_byte();\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_stream_internal_seek_set() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(3, 0);\n        assert_eq!(stream.tell(), 3);\n        assert_eq!(stream.read_byte(), Some(3));\n    }\n\n    #[test]\n    fn test_stream_internal_seek_cur() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(2, 0); // Start at 2\n        stream.seek(2, 1); // Move forward 2\n        assert_eq!(stream.tell(), 4);\n    }\n\n    #[test]\n    fn test_stream_internal_seek_end() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(-2, 2); // 2 from end\n        assert_eq!(stream.tell(), 3);\n    }\n\n    #[test]\n    fn test_stream_internal_seek_invalid_whence() {\n        let mut stream = Stream::from_memory(vec![0, 1, 2, 3, 4]);\n        stream.seek(2, 0); // Start at 2\n        stream.seek(99, 99); // Invalid whence\n        assert_eq!(stream.tell(), 2); // Should remain unchanged\n    }\n\n    #[test]\n    fn test_stream_internal_read() {\n        let mut stream = Stream::from_memory(vec![1, 2, 3, 4, 5]);\n        let mut buf = [0u8; 3];\n        let n = stream.read(\u0026mut buf);\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_stream_internal_read_empty() {\n        let mut stream = Stream::from_memory(vec![1]);\n        stream.read_byte();\n        let mut buf = [0u8; 10];\n        let n = stream.read(\u0026mut buf);\n        assert_eq!(n, 0);\n    }\n\n    #[test]\n    fn test_stream_default() {\n        let stream: Stream = Default::default();\n        assert!(stream.data.is_empty());\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_fz_open_memory_empty() {\n        let handle = fz_open_memory(0, std::ptr::null(), 0);\n        assert_ne!(handle, 0);\n        assert_eq!(fz_is_eof(0, handle), 1);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_open_file_null() {\n        let handle = fz_open_file(0, std::ptr::null());\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_open_buffer_invalid() {\n        let handle = fz_open_buffer(0, 99999);\n        assert_eq!(handle, 0);\n    }\n\n    #[test]\n    fn test_fz_read_null_data() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let n = fz_read(0, handle, std::ptr::null_mut(), 10);\n        assert_eq!(n, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_zero_len() {\n        let data = vec![1, 2, 3];\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let mut buf = [0u8; 10];\n        let n = fz_read(0, handle, buf.as_mut_ptr(), 0);\n        assert_eq!(n, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_seek_invalid_handle() {\n        fz_seek(0, 99999, 10, 0); // Should not panic\n    }\n\n    #[test]\n    fn test_fz_read_uint_incomplete() {\n        let data = vec![0x12]; // Only 1 byte\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint16(0, handle);\n        assert_eq!(val, 0); // Incomplete read returns 0\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint32_incomplete() {\n        let data = vec![0x12, 0x34]; // Only 2 bytes\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint32(0, handle);\n        assert_eq!(val, 0); // Incomplete read returns 0\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint_le_incomplete() {\n        let data = vec![0x12]; // Only 1 byte\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint16_le(0, handle);\n        assert_eq!(val, 0);\n        fz_drop_stream(0, handle);\n    }\n\n    #[test]\n    fn test_fz_read_uint32_le_incomplete() {\n        let data = vec![0x12, 0x34]; // Only 2 bytes\n        let handle = STREAMS.insert(Stream::from_memory(data));\n        let val = fz_read_uint32_le(0, handle);\n        assert_eq!(val, 0);\n        fz_drop_stream(0, handle);\n    }\n}\n","traces":[{"line":15,"address":[1385840],"length":1,"stats":{"Line":1}},{"line":17,"address":[2328701],"length":1,"stats":{"Line":1}},{"line":23,"address":[1385920,1386096],"length":1,"stats":{"Line":2}},{"line":24,"address":[1385947,1386013],"length":1,"stats":{"Line":4}},{"line":32,"address":[1386112],"length":1,"stats":{"Line":4}},{"line":33,"address":[2329000],"length":1,"stats":{"Line":5}},{"line":34,"address":[1386227],"length":1,"stats":{"Line":1}},{"line":35,"address":[1386231],"length":1,"stats":{"Line":1}},{"line":38,"address":[1386356,1386255,1386185],"length":1,"stats":{"Line":6}},{"line":39,"address":[1386263],"length":1,"stats":{"Line":5}},{"line":40,"address":[1386459,1386384,1386295],"length":1,"stats":{"Line":5}},{"line":41,"address":[1386482,1386514,1386443],"length":1,"stats":{"Line":5}},{"line":43,"address":[1386548,1386486],"length":1,"stats":{"Line":8}},{"line":44,"address":[1386544],"length":1,"stats":{"Line":1}},{"line":47,"address":[1386532],"length":1,"stats":{"Line":2}},{"line":50,"address":[1386576],"length":1,"stats":{"Line":4}},{"line":51,"address":[1386590],"length":1,"stats":{"Line":3}},{"line":52,"address":[2329531],"length":1,"stats":{"Line":1}},{"line":53,"address":[1386687],"length":1,"stats":{"Line":1}},{"line":55,"address":[1386623],"length":1,"stats":{"Line":4}},{"line":56,"address":[1386704,1386658,1386738],"length":1,"stats":{"Line":10}},{"line":57,"address":[2329556,2329623],"length":1,"stats":{"Line":9}},{"line":58,"address":[1386771],"length":1,"stats":{"Line":3}},{"line":60,"address":[2329603],"length":1,"stats":{"Line":2}},{"line":63,"address":[1386800],"length":1,"stats":{"Line":1}},{"line":64,"address":[1386814],"length":1,"stats":{"Line":1}},{"line":65,"address":[1386877],"length":1,"stats":{"Line":1}},{"line":67,"address":[2329695],"length":1,"stats":{"Line":1}},{"line":70,"address":[1386896],"length":1,"stats":{"Line":2}},{"line":71,"address":[1386928],"length":1,"stats":{"Line":3}},{"line":72,"address":[1386977],"length":1,"stats":{"Line":2}},{"line":73,"address":[1386994,1387137],"length":1,"stats":{"Line":2}},{"line":74,"address":[1387019,1387162],"length":1,"stats":{"Line":4}},{"line":75,"address":[1386961],"length":1,"stats":{"Line":1}},{"line":77,"address":[2329898],"length":1,"stats":{"Line":2}},{"line":78,"address":[1387087],"length":1,"stats":{"Line":4}},{"line":81,"address":[2330032],"length":1,"stats":{"Line":2}},{"line":82,"address":[1387189],"length":1,"stats":{"Line":4}},{"line":85,"address":[1387200],"length":1,"stats":{"Line":2}},{"line":86,"address":[1387205],"length":1,"stats":{"Line":2}},{"line":91,"address":[1387216],"length":1,"stats":{"Line":1}},{"line":92,"address":[1387224],"length":1,"stats":{"Line":1}},{"line":98,"address":[1387290,1387248],"length":1,"stats":{"Line":1}},{"line":99,"address":[1387267,1387306],"length":1,"stats":{"Line":2}},{"line":104,"address":[1387386,1387344,1387444],"length":1,"stats":{"Line":2}},{"line":105,"address":[2330230,2330195],"length":1,"stats":{"Line":6}},{"line":113,"address":[1387472,1387536,1388035,1388041],"length":1,"stats":{"Line":1}},{"line":114,"address":[2330374,2330345],"length":1,"stats":{"Line":2}},{"line":115,"address":[1387574],"length":1,"stats":{"Line":1}},{"line":120,"address":[1387557,1387598],"length":1,"stats":{"Line":0}},{"line":121,"address":[1387614],"length":1,"stats":{"Line":0}},{"line":122,"address":[2330483],"length":1,"stats":{"Line":0}},{"line":123,"address":[1387641],"length":1,"stats":{"Line":0}},{"line":126,"address":[1387681],"length":1,"stats":{"Line":0}},{"line":127,"address":[1387799,1388019,1387745],"length":1,"stats":{"Line":0}},{"line":128,"address":[2330555],"length":1,"stats":{"Line":0}},{"line":137,"address":[2330928,2331190,2330997],"length":1,"stats":{"Line":2}},{"line":142,"address":[2330982,2331007],"length":1,"stats":{"Line":4}},{"line":143,"address":[2331024,2331271],"length":1,"stats":{"Line":2}},{"line":148,"address":[2331056],"length":1,"stats":{"Line":1}},{"line":149,"address":[2331119,2331231],"length":1,"stats":{"Line":2}},{"line":154,"address":[1389168,1388595,1389127,1388544],"length":1,"stats":{"Line":1}},{"line":155,"address":[2331340,2331375],"length":1,"stats":{"Line":2}},{"line":156,"address":[1388761,1388675,1388807],"length":1,"stats":{"Line":0}},{"line":157,"address":[2331568,2331629],"length":1,"stats":{"Line":0}},{"line":160,"address":[1389209],"length":1,"stats":{"Line":1}},{"line":168,"address":[2332572,2332002,2332613,2331920],"length":1,"stats":{"Line":1}},{"line":174,"address":[2332012,2331987],"length":1,"stats":{"Line":2}},{"line":175,"address":[2332029],"length":1,"stats":{"Line":1}},{"line":178,"address":[1389355],"length":1,"stats":{"Line":1}},{"line":179,"address":[1389624,1389464,1389559],"length":1,"stats":{"Line":8}},{"line":182,"address":[1389729,1389654],"length":1,"stats":{"Line":8}},{"line":183,"address":[1389761],"length":1,"stats":{"Line":4}},{"line":186,"address":[1390024],"length":1,"stats":{"Line":0}},{"line":191,"address":[2332672,2333223,2332719,2333148],"length":1,"stats":{"Line":2}},{"line":192,"address":[1390076,1390115],"length":1,"stats":{"Line":4}},{"line":193,"address":[1390179,1390311,1390265],"length":1,"stats":{"Line":9}},{"line":194,"address":[1390329,1390396],"length":1,"stats":{"Line":6}},{"line":195,"address":[2333046],"length":1,"stats":{"Line":3}},{"line":199,"address":[1390691],"length":1,"stats":{"Line":1}},{"line":204,"address":[1390704,1391322,1391239,1390755],"length":1,"stats":{"Line":1}},{"line":205,"address":[2333327,2333292],"length":1,"stats":{"Line":4}},{"line":206,"address":[2333499,2333392,2333466],"length":1,"stats":{"Line":3}},{"line":207,"address":[2333522,2333573],"length":1,"stats":{"Line":2}},{"line":208,"address":[1391121],"length":1,"stats":{"Line":1}},{"line":212,"address":[1391347],"length":1,"stats":{"Line":1}},{"line":217,"address":[2334325,2334285,2333856,2333900],"length":1,"stats":{"Line":2}},{"line":218,"address":[2333916,2333881],"length":1,"stats":{"Line":4}},{"line":219,"address":[2334055,2334088,2333981],"length":1,"stats":{"Line":9}},{"line":220,"address":[2334162,2334111],"length":1,"stats":{"Line":6}},{"line":223,"address":[1391922],"length":1,"stats":{"Line":1}},{"line":228,"address":[1392442,1392417,1392008,1391936],"length":1,"stats":{"Line":2}},{"line":229,"address":[2334452,2334417],"length":1,"stats":{"Line":4}},{"line":230,"address":[2334624,2334517,2334591],"length":1,"stats":{"Line":6}},{"line":231,"address":[2334647,2334707],"length":1,"stats":{"Line":4}},{"line":238,"address":[1392943,1392984,1392528,1392480],"length":1,"stats":{"Line":2}},{"line":239,"address":[2334924,2334889],"length":1,"stats":{"Line":4}},{"line":240,"address":[1392608,1392694,1392740],"length":1,"stats":{"Line":8}},{"line":241,"address":[1392758,1392822],"length":1,"stats":{"Line":8}},{"line":244,"address":[1393025],"length":1,"stats":{"Line":1}},{"line":249,"address":[1393040,1393097],"length":1,"stats":{"Line":1}},{"line":250,"address":[1393064],"length":1,"stats":{"Line":1}},{"line":251,"address":[1393071,1393179,1393118],"length":1,"stats":{"Line":3}},{"line":252,"address":[1393135,1393186],"length":1,"stats":{"Line":2}},{"line":254,"address":[2335491],"length":1,"stats":{"Line":1}},{"line":259,"address":[1393274,1393216],"length":1,"stats":{"Line":1}},{"line":260,"address":[2335544],"length":1,"stats":{"Line":1}},{"line":261,"address":[1393351,1393248,1393295],"length":1,"stats":{"Line":3}},{"line":262,"address":[2335660,2335615],"length":1,"stats":{"Line":2}},{"line":264,"address":[1393343],"length":1,"stats":{"Line":1}},{"line":269,"address":[2335737,2335680],"length":1,"stats":{"Line":1}},{"line":270,"address":[1393400],"length":1,"stats":{"Line":1}},{"line":271,"address":[1393407,1393515,1393454],"length":1,"stats":{"Line":3}},{"line":272,"address":[1393522,1393471],"length":1,"stats":{"Line":2}},{"line":274,"address":[1393508],"length":1,"stats":{"Line":1}},{"line":279,"address":[1393552,1393610],"length":1,"stats":{"Line":1}},{"line":280,"address":[1393576],"length":1,"stats":{"Line":1}},{"line":281,"address":[1393584,1393687,1393631],"length":1,"stats":{"Line":3}},{"line":282,"address":[1393648,1393693],"length":1,"stats":{"Line":2}},{"line":284,"address":[1393679],"length":1,"stats":{"Line":1}}],"covered":110,"coverable":120},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","async_io.rs"],"content":"//! Async I/O utilities using Tokio\n//!\n//! This module provides asynchronous I/O operations for PDF processing,\n//! enabling non-blocking file operations and concurrent processing.\n\nuse std::path::Path;\nuse tokio::fs::File;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader};\nuse bytes::{Bytes, BytesMut};\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::{Error, Result};\n\n/// Read a file asynchronously into a Buffer.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::read_file;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let buffer = read_file(\"document.pdf\").await.unwrap();\n///     println!(\"Read {} bytes\", buffer.len());\n/// }\n/// ```\npub async fn read_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cBuffer\u003e {\n    let mut file = File::open(path).await.map_err(Error::System)?;\n    let mut data = Vec::new();\n    file.read_to_end(\u0026mut data).await.map_err(Error::System)?;\n    Ok(Buffer::from_data(data))\n}\n\n/// Read a file asynchronously with a size limit.\npub async fn read_file_limited\u003cP: AsRef\u003cPath\u003e\u003e(path: P, max_size: usize) -\u003e Result\u003cBuffer\u003e {\n    let file = File::open(path).await.map_err(Error::System)?;\n    let mut reader = BufReader::new(file);\n    let mut data = Vec::with_capacity(max_size.min(8192));\n    let mut chunk = [0u8; 8192];\n\n    loop {\n        let n = reader.read(\u0026mut chunk).await.map_err(Error::System)?;\n        if n == 0 {\n            break;\n        }\n        if data.len() + n \u003e max_size {\n            return Err(Error::generic(\"File size exceeds limit\"));\n        }\n        data.extend_from_slice(\u0026chunk[..n]);\n    }\n\n    Ok(Buffer::from_data(data))\n}\n\n/// Write a buffer to a file asynchronously.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::write_file;\n/// use micropdf::fitz::buffer::Buffer;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let buffer = Buffer::from_slice(b\"Hello, PDF!\");\n///     write_file(\"output.txt\", \u0026buffer).await.unwrap();\n/// }\n/// ```\npub async fn write_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, buffer: \u0026Buffer) -\u003e Result\u003c()\u003e {\n    let mut file = File::create(path).await.map_err(Error::System)?;\n    file.write_all(\u0026buffer.to_vec()).await.map_err(Error::System)?;\n    file.flush().await.map_err(Error::System)?;\n    Ok(())\n}\n\n/// Copy a file asynchronously.\npub async fn copy_file\u003cP: AsRef\u003cPath\u003e, Q: AsRef\u003cPath\u003e\u003e(src: P, dst: Q) -\u003e Result\u003cu64\u003e {\n    tokio::fs::copy(src, dst).await.map_err(Error::System)\n}\n\n/// Check if a file exists asynchronously.\npub async fn file_exists\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e bool {\n    tokio::fs::metadata(path).await.is_ok()\n}\n\n/// Get file size asynchronously.\npub async fn file_size\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cu64\u003e {\n    let metadata = tokio::fs::metadata(path).await.map_err(Error::System)?;\n    Ok(metadata.len())\n}\n\n/// Read multiple files concurrently.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::async_io::read_files_concurrent;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let paths = vec![\"file1.pdf\", \"file2.pdf\", \"file3.pdf\"];\n///     let results = read_files_concurrent(\u0026paths).await;\n/// }\n/// ```\npub async fn read_files_concurrent\u003cP: AsRef\u003cPath\u003e + Send + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n    let futures: Vec\u003c_\u003e = paths\n        .iter()\n        .map(|path| {\n            let path = path.as_ref().to_path_buf();\n            async move { read_file(\u0026path).await }\n        })\n        .collect();\n\n    futures::future::join_all(futures).await\n}\n\n/// Write multiple buffers to files concurrently.\npub async fn write_files_concurrent\u003cP: AsRef\u003cPath\u003e + Send + Sync\u003e(\n    paths: \u0026[P],\n    buffers: \u0026[Buffer],\n) -\u003e Vec\u003cResult\u003c()\u003e\u003e {\n    if paths.len() != buffers.len() {\n        return vec![Err(Error::generic(\"Mismatched paths and buffers count\"))];\n    }\n\n    let futures: Vec\u003c_\u003e = paths\n        .iter()\n        .zip(buffers.iter())\n        .map(|(path, buffer)| {\n            let path = path.as_ref().to_path_buf();\n            let data = buffer.to_vec();\n            async move {\n                let mut file = File::create(\u0026path).await.map_err(Error::System)?;\n                file.write_all(\u0026data).await.map_err(Error::System)?;\n                file.flush().await.map_err(Error::System)?;\n                Ok(())\n            }\n        })\n        .collect();\n\n    futures::future::join_all(futures).await\n}\n\n/// Async buffer for streaming data.\npub struct AsyncBuffer {\n    inner: BytesMut,\n}\n\nimpl AsyncBuffer {\n    /// Create a new async buffer.\n    pub fn new() -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(8192),\n        }\n    }\n\n    /// Create with a specific capacity.\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(capacity),\n        }\n    }\n\n    /// Append data.\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\n        self.inner.extend_from_slice(data);\n    }\n\n    /// Get the length.\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Check if empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n\n    /// Clear the buffer.\n    pub fn clear(\u0026mut self) {\n        self.inner.clear();\n    }\n\n    /// Convert to Buffer.\n    pub fn into_buffer(self) -\u003e Buffer {\n        Buffer::from_bytes_mut(self.inner)\n    }\n\n    /// Convert to Bytes.\n    pub fn freeze(self) -\u003e Bytes {\n        self.inner.freeze()\n    }\n\n    /// Get as slice.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.inner\n    }\n}\n\nimpl Default for AsyncBuffer {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Run an async operation with a timeout.\npub async fn with_timeout\u003cF, T\u003e(duration: std::time::Duration, future: F) -\u003e Result\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    match tokio::time::timeout(duration, future).await {\n        Ok(result) =\u003e result,\n        Err(_) =\u003e Err(Error::generic(\"Operation timed out\")),\n    }\n}\n\n/// Spawn a task to run in the background.\npub fn spawn\u003cF\u003e(future: F) -\u003e tokio::task::JoinHandle\u003cF::Output\u003e\nwhere\n    F: std::future::Future + Send + 'static,\n    F::Output: Send + 'static,\n{\n    tokio::spawn(future)\n}\n\n/// Run multiple async operations concurrently and collect results.\npub async fn concurrent\u003cF, T\u003e(futures: Vec\u003cF\u003e) -\u003e Vec\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = T\u003e,\n    T: Send,\n{\n    futures::future::join_all(futures).await\n}\n\n/// Run multiple async operations concurrently with a limit on parallelism.\npub async fn concurrent_limited\u003cF, T\u003e(futures: Vec\u003cF\u003e, limit: usize) -\u003e Vec\u003cT\u003e\nwhere\n    F: std::future::Future\u003cOutput = T\u003e + Send,\n    T: Send,\n{\n    use futures::stream::{self, StreamExt};\n\n    stream::iter(futures)\n        .buffer_unordered(limit)\n        .collect()\n        .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn test_async_buffer() {\n        let mut buf = AsyncBuffer::new();\n        assert!(buf.is_empty());\n\n        buf.append(b\"Hello\");\n        assert_eq!(buf.len(), 5);\n\n        buf.append(b\" World\");\n        assert_eq!(buf.len(), 11);\n\n        let buffer = buf.into_buffer();\n        assert_eq!(buffer.as_slice(), b\"Hello World\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_with_capacity() {\n        let buf = AsyncBuffer::with_capacity(1024);\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_clear() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Hello\");\n        assert_eq!(buf.len(), 5);\n        buf.clear();\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_as_slice() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Test\");\n        assert_eq!(buf.as_slice(), b\"Test\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_freeze() {\n        let mut buf = AsyncBuffer::new();\n        buf.append(b\"Freeze\");\n        let bytes = buf.freeze();\n        assert_eq!(\u0026bytes[..], b\"Freeze\");\n    }\n\n    #[tokio::test]\n    async fn test_async_buffer_default() {\n        let buf: AsyncBuffer = Default::default();\n        assert!(buf.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_read_write_file() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        let buffer = Buffer::from_slice(b\"Hello, World!\");\n        write_file(\u0026path, \u0026buffer).await.unwrap();\n\n        let read_buffer = read_file(\u0026path).await.unwrap();\n        assert_eq!(read_buffer.as_slice(), b\"Hello, World!\");\n    }\n\n    #[tokio::test]\n    async fn test_file_exists() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        assert!(!file_exists(\u0026path).await);\n\n        write_file(\u0026path, \u0026Buffer::from_slice(b\"test\")).await.unwrap();\n\n        assert!(file_exists(\u0026path).await);\n    }\n\n    #[tokio::test]\n    async fn test_file_size() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"test.txt\");\n\n        let data = b\"Hello, World!\";\n        write_file(\u0026path, \u0026Buffer::from_slice(data)).await.unwrap();\n\n        let size = file_size(\u0026path).await.unwrap();\n        assert_eq!(size, data.len() as u64);\n    }\n\n    #[tokio::test]\n    async fn test_copy_file() {\n        let dir = tempdir().unwrap();\n        let src = dir.path().join(\"src.txt\");\n        let dst = dir.path().join(\"dst.txt\");\n\n        let data = b\"Copy me!\";\n        write_file(\u0026src, \u0026Buffer::from_slice(data)).await.unwrap();\n\n        let copied = copy_file(\u0026src, \u0026dst).await.unwrap();\n        assert_eq!(copied, data.len() as u64);\n\n        let read_buffer = read_file(\u0026dst).await.unwrap();\n        assert_eq!(read_buffer.as_slice(), data);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent() {\n        async fn task_1() -\u003e i32 { 1 }\n        async fn task_2() -\u003e i32 { 2 }\n        async fn task_3() -\u003e i32 { 3 }\n\n        let futures: Vec\u003cstd::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = i32\u003e + Send\u003e\u003e\u003e = vec![\n            Box::pin(task_1()),\n            Box::pin(task_2()),\n            Box::pin(task_3()),\n        ];\n\n        let results = concurrent(futures).await;\n        assert_eq!(results, vec![1, 2, 3]);\n    }\n\n    #[tokio::test]\n    async fn test_with_timeout_success() {\n        let result = with_timeout(\n            std::time::Duration::from_secs(1),\n            async { Ok::\u003c_, Error\u003e(42) },\n        ).await;\n\n        assert_eq!(result.unwrap(), 42);\n    }\n\n    #[tokio::test]\n    async fn test_with_timeout_failure() {\n        let result = with_timeout(\n            std::time::Duration::from_millis(1),\n            async {\n                tokio::time::sleep(std::time::Duration::from_secs(10)).await;\n                Ok::\u003c_, Error\u003e(42)\n            },\n        ).await;\n\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_read_files_concurrent() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"file1.txt\");\n        let path2 = dir.path().join(\"file2.txt\");\n\n        write_file(\u0026path1, \u0026Buffer::from_slice(b\"File 1\")).await.unwrap();\n        write_file(\u0026path2, \u0026Buffer::from_slice(b\"File 2\")).await.unwrap();\n\n        let paths = vec![path1, path2];\n        let results = read_files_concurrent(\u0026paths).await;\n\n        assert_eq!(results.len(), 2);\n        assert!(results[0].is_ok());\n        assert!(results[1].is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_write_files_concurrent() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"write1.txt\");\n        let path2 = dir.path().join(\"write2.txt\");\n\n        let buf1 = Buffer::from_slice(b\"Content 1\");\n        let buf2 = Buffer::from_slice(b\"Content 2\");\n\n        let paths = vec![path1.clone(), path2.clone()];\n        let buffers = vec![buf1, buf2];\n        let results = write_files_concurrent(\u0026paths, \u0026buffers).await;\n\n        assert_eq!(results.len(), 2);\n        assert!(results[0].is_ok());\n        assert!(results[1].is_ok());\n\n        let read1 = read_file(\u0026path1).await.unwrap();\n        let read2 = read_file(\u0026path2).await.unwrap();\n        assert_eq!(read1.as_slice(), b\"Content 1\");\n        assert_eq!(read2.as_slice(), b\"Content 2\");\n    }\n\n    #[tokio::test]\n    async fn test_write_files_concurrent_mismatch() {\n        let dir = tempdir().unwrap();\n        let path1 = dir.path().join(\"write1.txt\");\n\n        let buf1 = Buffer::from_slice(b\"Content 1\");\n        let buf2 = Buffer::from_slice(b\"Content 2\");\n\n        let paths = vec![path1];\n        let buffers = vec![buf1, buf2];\n        let results = write_files_concurrent(\u0026paths, \u0026buffers).await;\n\n        // Should return error because of mismatch\n        assert_eq!(results.len(), 1);\n        assert!(results[0].is_err());\n    }\n\n    #[tokio::test]\n    async fn test_read_file_limited() {\n        let dir = tempdir().unwrap();\n        let path = dir.path().join(\"large.txt\");\n\n        let data = vec![b'X'; 1000];\n        write_file(\u0026path, \u0026Buffer::from_slice(\u0026data)).await.unwrap();\n\n        // Read with limit\n        let result = read_file_limited(\u0026path, 100).await;\n        assert!(result.is_err()); // Should exceed limit\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_limited() {\n        let futures: Vec\u003cstd::pin::Pin\u003cBox\u003cdyn std::future::Future\u003cOutput = i32\u003e + Send\u003e\u003e\u003e = vec![\n            Box::pin(async { 1 }),\n            Box::pin(async { 2 }),\n            Box::pin(async { 3 }),\n            Box::pin(async { 4 }),\n        ];\n\n        let results = concurrent_limited(futures, 2).await;\n        assert_eq!(results.len(), 4);\n        // Note: order may not be preserved due to unordered buffering\n    }\n\n    #[tokio::test]\n    async fn test_spawn() {\n        let handle = spawn(async { 42 });\n        let result = handle.await.unwrap();\n        assert_eq!(result, 42);\n    }\n}\n\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":12}},{"line":68,"address":[1274929,1275137,1275044,1276049,1274895],"length":1,"stats":{"Line":8}},{"line":69,"address":[1756772],"length":1,"stats":{"Line":12}},{"line":70,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[1757025],"length":1,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[2228192],"length":1,"stats":{"Line":1}},{"line":150,"address":[2228206],"length":1,"stats":{"Line":1}},{"line":155,"address":[2228272],"length":1,"stats":{"Line":0}},{"line":157,"address":[2228290],"length":1,"stats":{"Line":0}},{"line":162,"address":[2228352],"length":1,"stats":{"Line":1}},{"line":163,"address":[2228370],"length":1,"stats":{"Line":1}},{"line":167,"address":[2228384],"length":1,"stats":{"Line":1}},{"line":168,"address":[2228389],"length":1,"stats":{"Line":1}},{"line":172,"address":[2228400],"length":1,"stats":{"Line":1}},{"line":173,"address":[2228405],"length":1,"stats":{"Line":1}},{"line":177,"address":[2228416],"length":1,"stats":{"Line":0}},{"line":178,"address":[2228421],"length":1,"stats":{"Line":0}},{"line":182,"address":[2228432],"length":1,"stats":{"Line":1}},{"line":183,"address":[2228443],"length":1,"stats":{"Line":1}},{"line":187,"address":[2228512],"length":1,"stats":{"Line":0}},{"line":188,"address":[2228523],"length":1,"stats":{"Line":0}},{"line":192,"address":[2228592],"length":1,"stats":{"Line":0}},{"line":193,"address":[2228597],"length":1,"stats":{"Line":0}},{"line":198,"address":[2228608],"length":1,"stats":{"Line":0}},{"line":199,"address":[2228616],"length":1,"stats":{"Line":0}},{"line":204,"address":[1279128,1278992],"length":1,"stats":{"Line":2}},{"line":208,"address":[1279385,1279169,1279307,1279237],"length":1,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[1280037,1279920],"length":1,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":32,"coverable":79},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","buffer.rs"],"content":"//! Buffer - Dynamic byte array wrapper using the `bytes` crate\n//!\n//! This module provides a high-performance buffer implementation backed by\n//! `bytes::Bytes` and `bytes::BytesMut` for efficient zero-copy operations.\n\nuse crate::fitz::error::{Error, Result};\nuse bytes::{Buf, BufMut, Bytes, BytesMut};\nuse std::fmt;\nuse std::io::{self, Read, Write};\nuse std::sync::Arc;\n\n/// A reference-counted buffer for efficient byte storage.\n///\n/// Uses `bytes::Bytes` for immutable shared data and `bytes::BytesMut` for\n/// mutable operations with copy-on-write semantics.\n#[derive(Clone)]\npub struct Buffer {\n    /// Immutable shared data (for reading)\n    data: Bytes,\n    /// Mutable buffer for writes (lazy initialized)\n    mutable: Option\u003cArc\u003cstd::sync::Mutex\u003cBytesMut\u003e\u003e\u003e,\n}\n\nimpl Buffer {\n    /// Create a new empty buffer with the specified capacity.\n    pub fn new(capacity: usize) -\u003e Self {\n        Self {\n            data: Bytes::new(),\n            mutable: Some(Arc::new(std::sync::Mutex::new(BytesMut::with_capacity(capacity)))),\n        }\n    }\n\n    /// Create a buffer from owned data (zero-copy).\n    pub fn from_data(data: Vec\u003cu8\u003e) -\u003e Self {\n        Self {\n            data: Bytes::from(data),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a byte slice (copies data).\n    pub fn from_slice(data: \u0026[u8]) -\u003e Self {\n        Self {\n            data: Bytes::copy_from_slice(data),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a `Bytes` instance (zero-copy).\n    pub fn from_bytes(data: Bytes) -\u003e Self {\n        Self {\n            data,\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from a `BytesMut` instance (zero-copy).\n    pub fn from_bytes_mut(data: BytesMut) -\u003e Self {\n        Self {\n            data: data.freeze(),\n            mutable: None,\n        }\n    }\n\n    /// Create a buffer from base64-encoded data.\n    pub fn from_base64(data: \u0026str) -\u003e Result\u003cSelf\u003e {\n        use base64::Engine;\n        let decoded = base64::engine::general_purpose::STANDARD\n            .decode(data.as_bytes())\n            .map_err(|e| Error::format(format!(\"Invalid base64: {}\", e)))?;\n        Ok(Self::from_data(decoded))\n    }\n\n    /// Returns the number of bytes in the buffer.\n    #[inline]\n    pub fn len(\u0026self) -\u003e usize {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    return self.data.len() + guard.len();\n                }\n            }\n        }\n        self.data.len()\n    }\n\n    /// Returns true if the buffer is empty.\n    #[inline]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    /// Returns the capacity of the buffer.\n    pub fn capacity(\u0026self) -\u003e usize {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                return self.data.len() + guard.capacity();\n            }\n        }\n        self.data.len()\n    }\n\n    /// Returns the buffer contents as a byte slice.\n    ///\n    /// If there are pending mutable writes, this will consolidate them first.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        // If we have no mutable data, return the immutable slice directly\n        if self.mutable.is_none() {\n            return \u0026self.data;\n        }\n\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if guard.is_empty() {\n                    return \u0026self.data;\n                }\n            }\n        }\n\n        // For simplicity, return the base data\n        // Full consolidation would require interior mutability\n        \u0026self.data\n    }\n\n    /// Returns the buffer as a UTF-8 string slice.\n    pub fn as_str(\u0026self) -\u003e Result\u003c\u0026str\u003e {\n        std::str::from_utf8(self.as_slice())\n            .map_err(|e| Error::format(format!(\"Invalid UTF-8: {}\", e)))\n    }\n\n    /// Returns a copy of the buffer contents as a Vec.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut result = self.data.to_vec();\n                    result.extend_from_slice(\u0026guard);\n                    return result;\n                }\n            }\n        }\n        self.data.to_vec()\n    }\n\n    /// Returns the buffer contents as `Bytes` (zero-copy if no mutable data).\n    pub fn to_bytes(\u0026self) -\u003e Bytes {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut result = BytesMut::with_capacity(self.data.len() + guard.len());\n                    result.extend_from_slice(\u0026self.data);\n                    result.extend_from_slice(\u0026guard);\n                    return result.freeze();\n                }\n            }\n        }\n        self.data.clone()\n    }\n\n    /// Consolidate any mutable data into the immutable buffer.\n    fn consolidate(\u0026mut self) {\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                if !guard.is_empty() {\n                    let mut new_data = BytesMut::with_capacity(self.data.len() + guard.len());\n                    new_data.extend_from_slice(\u0026self.data);\n                    new_data.extend_from_slice(\u0026guard);\n                    self.data = new_data.freeze();\n                }\n            }\n        }\n        self.mutable = None;\n    }\n\n    /// Ensure we have a mutable buffer for writes.\n    fn ensure_mutable(\u0026mut self) {\n        if self.mutable.is_none() {\n            self.mutable = Some(Arc::new(std::sync::Mutex::new(BytesMut::with_capacity(256))));\n        }\n    }\n\n    /// Resize the buffer to the specified size.\n    pub fn resize(\u0026mut self, new_len: usize) {\n        self.consolidate();\n        let mut data = BytesMut::from(self.data.as_ref());\n        data.resize(new_len, 0);\n        self.data = data.freeze();\n    }\n\n    /// Clear all data from the buffer.\n    pub fn clear(\u0026mut self) {\n        self.data = Bytes::new();\n        self.mutable = None;\n    }\n\n    /// Append a byte slice to the buffer.\n    pub fn append_data(\u0026mut self, data: \u0026[u8]) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.extend_from_slice(data);\n            }\n        }\n    }\n\n    /// Append a single byte to the buffer.\n    pub fn append_byte(\u0026mut self, byte: u8) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_u8(byte);\n            }\n        }\n    }\n\n    /// Append a string to the buffer.\n    pub fn append_string(\u0026mut self, s: \u0026str) {\n        self.append_data(s.as_bytes());\n    }\n\n    /// Append a 16-bit integer in little-endian format.\n    pub fn append_int16_le(\u0026mut self, value: i16) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i16_le(value);\n            }\n        }\n    }\n\n    /// Append a 32-bit integer in little-endian format.\n    pub fn append_int32_le(\u0026mut self, value: i32) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i32_le(value);\n            }\n        }\n    }\n\n    /// Append a 16-bit integer in big-endian format.\n    pub fn append_int16_be(\u0026mut self, value: i16) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i16(value);\n            }\n        }\n    }\n\n    /// Append a 32-bit integer in big-endian format.\n    pub fn append_int32_be(\u0026mut self, value: i32) {\n        self.ensure_mutable();\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(mut guard) = mutable.lock() {\n                guard.put_i32(value);\n            }\n        }\n    }\n\n    /// Compute the MD5 digest of the buffer contents.\n    pub fn md5_digest(\u0026self) -\u003e [u8; 16] {\n        use md5::{Digest, Md5};\n        let mut hasher = Md5::new();\n        hasher.update(\u0026self.data);\n        if let Some(ref mutable) = self.mutable {\n            if let Ok(guard) = mutable.lock() {\n                hasher.update(\u0026*guard);\n            }\n        }\n        hasher.finalize().into()\n    }\n\n    /// Encode the buffer contents as base64.\n    pub fn to_base64(\u0026self) -\u003e String {\n        use base64::Engine;\n        base64::engine::general_purpose::STANDARD.encode(self.to_vec())\n    }\n\n    /// Get a slice of the buffer.\n    pub fn slice(\u0026self, start: usize, end: usize) -\u003e Buffer {\n        let data = self.to_bytes();\n        if start \u003e= data.len() {\n            return Buffer::new(0);\n        }\n        let end = end.min(data.len());\n        Buffer::from_bytes(data.slice(start..end))\n    }\n\n    /// Split the buffer at the given index.\n    pub fn split_at(\u0026self, mid: usize) -\u003e (Buffer, Buffer) {\n        let data = self.to_bytes();\n        if mid \u003e= data.len() {\n            return (Buffer::from_bytes(data), Buffer::new(0));\n        }\n        let first = data.slice(..mid);\n        let second = data.slice(mid..);\n        (Buffer::from_bytes(first), Buffer::from_bytes(second))\n    }\n}\n\nimpl Default for Buffer {\n    fn default() -\u003e Self {\n        Self::new(0)\n    }\n}\n\nimpl fmt::Debug for Buffer {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Buffer\").field(\"len\", \u0026self.len()).finish()\n    }\n}\n\nimpl AsRef\u003c[u8]\u003e for Buffer {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        self.as_slice()\n    }\n}\n\nimpl From\u003cVec\u003cu8\u003e\u003e for Buffer {\n    fn from(data: Vec\u003cu8\u003e) -\u003e Self {\n        Self::from_data(data)\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Buffer {\n    fn from(data: \u0026[u8]) -\u003e Self {\n        Self::from_slice(data)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Buffer {\n    fn from(s: \u0026str) -\u003e Self {\n        Self::from_slice(s.as_bytes())\n    }\n}\n\nimpl From\u003cBytes\u003e for Buffer {\n    fn from(data: Bytes) -\u003e Self {\n        Self::from_bytes(data)\n    }\n}\n\nimpl From\u003cBytesMut\u003e for Buffer {\n    fn from(data: BytesMut) -\u003e Self {\n        Self::from_bytes_mut(data)\n    }\n}\n\nimpl From\u003cBuffer\u003e for Bytes {\n    fn from(buf: Buffer) -\u003e Bytes {\n        buf.to_bytes()\n    }\n}\n\n/// A reader for consuming buffer contents.\npub struct BufferReader {\n    data: Bytes,\n    position: usize,\n}\n\nimpl BufferReader {\n    /// Create a new reader from a buffer.\n    pub fn new(buffer: Buffer) -\u003e Self {\n        Self {\n            data: buffer.to_bytes(),\n            position: 0,\n        }\n    }\n\n    /// Returns the current read position.\n    pub fn position(\u0026self) -\u003e usize {\n        self.position\n    }\n\n    /// Returns the number of bytes remaining.\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.data.len().saturating_sub(self.position)\n    }\n\n    /// Check if we've reached the end.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.position \u003e= self.data.len()\n    }\n\n    /// Peek at the next byte without consuming it.\n    pub fn peek(\u0026self) -\u003e Option\u003cu8\u003e {\n        self.data.get(self.position).copied()\n    }\n\n    /// Read a byte.\n    pub fn read_byte(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        if self.position \u003c self.data.len() {\n            let byte = self.data[self.position];\n            self.position += 1;\n            Some(byte)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 16-bit unsigned integer in big-endian format.\n    pub fn read_u16_be(\u0026mut self) -\u003e Option\u003cu16\u003e {\n        if self.remaining() \u003e= 2 {\n            let value = u16::from_be_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n            ]);\n            self.position += 2;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 32-bit unsigned integer in big-endian format.\n    pub fn read_u32_be(\u0026mut self) -\u003e Option\u003cu32\u003e {\n        if self.remaining() \u003e= 4 {\n            let value = u32::from_be_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n                self.data[self.position + 2],\n                self.data[self.position + 3],\n            ]);\n            self.position += 4;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 16-bit unsigned integer in little-endian format.\n    pub fn read_u16_le(\u0026mut self) -\u003e Option\u003cu16\u003e {\n        if self.remaining() \u003e= 2 {\n            let value = u16::from_le_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n            ]);\n            self.position += 2;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Read a 32-bit unsigned integer in little-endian format.\n    pub fn read_u32_le(\u0026mut self) -\u003e Option\u003cu32\u003e {\n        if self.remaining() \u003e= 4 {\n            let value = u32::from_le_bytes([\n                self.data[self.position],\n                self.data[self.position + 1],\n                self.data[self.position + 2],\n                self.data[self.position + 3],\n            ]);\n            self.position += 4;\n            Some(value)\n        } else {\n            None\n        }\n    }\n\n    /// Seek to a position.\n    pub fn seek(\u0026mut self, pos: usize) {\n        self.position = pos.min(self.data.len());\n    }\n\n    /// Skip n bytes.\n    pub fn skip(\u0026mut self, n: usize) {\n        self.position = (self.position + n).min(self.data.len());\n    }\n}\n\nimpl Read for BufferReader {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        let remaining = \u0026self.data[self.position..];\n        let to_read = buf.len().min(remaining.len());\n        buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n        self.position += to_read;\n        Ok(to_read)\n    }\n}\n\n/// A writer that accumulates data into a buffer.\npub struct BufferWriter {\n    inner: BytesMut,\n}\n\nimpl BufferWriter {\n    /// Create a new buffer writer.\n    pub fn new() -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(256),\n        }\n    }\n\n    /// Create a new buffer writer with the specified capacity.\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        Self {\n            inner: BytesMut::with_capacity(capacity),\n        }\n    }\n\n    /// Convert the writer into a Buffer.\n    pub fn into_buffer(self) -\u003e Buffer {\n        Buffer::from_bytes_mut(self.inner)\n    }\n\n    /// Get a reference to the accumulated data.\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.inner\n    }\n\n    /// Get the current length.\n    pub fn len(\u0026self) -\u003e usize {\n        self.inner.len()\n    }\n\n    /// Check if empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.is_empty()\n    }\n\n    /// Write a byte.\n    pub fn write_byte(\u0026mut self, byte: u8) {\n        self.inner.put_u8(byte);\n    }\n\n    /// Write a 16-bit integer in big-endian format.\n    pub fn write_u16_be(\u0026mut self, value: u16) {\n        self.inner.put_u16(value);\n    }\n\n    /// Write a 32-bit integer in big-endian format.\n    pub fn write_u32_be(\u0026mut self, value: u32) {\n        self.inner.put_u32(value);\n    }\n\n    /// Write a 16-bit integer in little-endian format.\n    pub fn write_u16_le(\u0026mut self, value: u16) {\n        self.inner.put_u16_le(value);\n    }\n\n    /// Write a 32-bit integer in little-endian format.\n    pub fn write_u32_le(\u0026mut self, value: u32) {\n        self.inner.put_u32_le(value);\n    }\n}\n\nimpl Default for BufferWriter {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Write for BufferWriter {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\n// Parallel buffer operations (when rayon feature is enabled)\n#[cfg(feature = \"parallel\")]\npub mod parallel {\n    use super::*;\n    use rayon::prelude::*;\n\n    /// Process multiple buffers in parallel.\n    pub fn process_buffers\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cR\u003e\n    where\n        F: Fn(\u0026Buffer) -\u003e R + Sync + Send,\n        R: Send,\n    {\n        buffers.par_iter().map(f).collect()\n    }\n\n    /// Apply a transformation to buffer data in parallel chunks.\n    pub fn parallel_transform\u003cF\u003e(buffer: \u0026Buffer, chunk_size: usize, f: F) -\u003e Buffer\n    where\n        F: Fn(\u0026[u8]) -\u003e Vec\u003cu8\u003e + Sync + Send,\n    {\n        let data = buffer.to_vec();\n        let chunks: Vec\u003cVec\u003cu8\u003e\u003e = data\n            .par_chunks(chunk_size)\n            .map(f)\n            .collect();\n\n        let total_len: usize = chunks.iter().map(|c| c.len()).sum();\n        let mut result = BytesMut::with_capacity(total_len);\n        for chunk in chunks {\n            result.extend_from_slice(\u0026chunk);\n        }\n        Buffer::from_bytes_mut(result)\n    }\n}\n\n// Async buffer operations (when async feature is enabled)\n#[cfg(feature = \"async\")]\npub mod async_ops {\n    use super::*;\n    use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};\n    use std::pin::Pin;\n    use std::task::{Context, Poll};\n\n    /// Read a buffer from an async reader.\n    pub async fn read_buffer\u003cR: AsyncRead + Unpin\u003e(\n        reader: \u0026mut R,\n        max_size: usize,\n    ) -\u003e Result\u003cBuffer\u003e {\n        let mut data = Vec::with_capacity(max_size.min(8192));\n        let mut chunk = [0u8; 8192];\n\n        loop {\n            let n = reader.read(\u0026mut chunk).await.map_err(Error::System)?;\n            if n == 0 {\n                break;\n            }\n            if data.len() + n \u003e max_size {\n                return Err(Error::generic(\"Buffer size limit exceeded\"));\n            }\n            data.extend_from_slice(\u0026chunk[..n]);\n        }\n\n        Ok(Buffer::from_data(data))\n    }\n\n    /// Write a buffer to an async writer.\n    pub async fn write_buffer\u003cW: AsyncWrite + Unpin\u003e(\n        writer: \u0026mut W,\n        buffer: \u0026Buffer,\n    ) -\u003e Result\u003c()\u003e {\n        writer.write_all(\u0026buffer.to_vec()).await.map_err(Error::System)\n    }\n\n    /// Async buffer reader.\n    pub struct AsyncBufferReader {\n        data: Bytes,\n        position: usize,\n    }\n\n    impl AsyncBufferReader {\n        pub fn new(buffer: Buffer) -\u003e Self {\n            Self {\n                data: buffer.to_bytes(),\n                position: 0,\n            }\n        }\n    }\n\n    impl AsyncRead for AsyncBufferReader {\n        fn poll_read(\n            mut self: Pin\u003c\u0026mut Self\u003e,\n            _cx: \u0026mut Context\u003c'_\u003e,\n            buf: \u0026mut tokio::io::ReadBuf\u003c'_\u003e,\n        ) -\u003e Poll\u003cio::Result\u003c()\u003e\u003e {\n            let remaining = \u0026self.data[self.position..];\n            let to_read = buf.remaining().min(remaining.len());\n            buf.put_slice(\u0026remaining[..to_read]);\n            self.position += to_read;\n            Poll::Ready(Ok(()))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Read, Write};\n\n    #[test]\n    fn test_buffer_new() {\n        let b = Buffer::new(100);\n        assert_eq!(b.len(), 0);\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_from_data() {\n        let data = vec![1, 2, 3, 4, 5];\n        let b = Buffer::from_data(data.clone());\n        assert_eq!(b.len(), 5);\n        assert!(!b.is_empty());\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_from_slice() {\n        let data = [1u8, 2, 3, 4, 5];\n        let b = Buffer::from_slice(\u0026data);\n        assert_eq!(b.as_slice(), \u0026data);\n    }\n\n    #[test]\n    fn test_buffer_from_bytes() {\n        let bytes = Bytes::from_static(\u0026[1, 2, 3]);\n        let b = Buffer::from_bytes(bytes);\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_base64() {\n        let b = Buffer::from_base64(\"SGVsbG8gV29ybGQ=\").unwrap();\n        assert_eq!(b.as_str().unwrap(), \"Hello World\");\n    }\n\n    #[test]\n    fn test_buffer_from_base64_invalid() {\n        let result = Buffer::from_base64(\"!!!invalid!!!\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_buffer_as_str() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        assert_eq!(b.as_str().unwrap(), \"Hello World\");\n    }\n\n    #[test]\n    fn test_buffer_as_str_invalid_utf8() {\n        let b = Buffer::from_slice(\u0026[0xFF, 0xFE, 0x00, 0x01]);\n        assert!(b.as_str().is_err());\n    }\n\n    #[test]\n    fn test_buffer_to_vec() {\n        let data = vec![1, 2, 3];\n        let b = Buffer::from_data(data.clone());\n        assert_eq!(b.to_vec(), data);\n    }\n\n    #[test]\n    fn test_buffer_resize() {\n        let mut b = Buffer::from_slice(\u0026[1, 2, 3]);\n        b.resize(5);\n        assert_eq!(b.len(), 5);\n        assert_eq!(b.to_vec(), vec![1, 2, 3, 0, 0]);\n    }\n\n    #[test]\n    fn test_buffer_clear() {\n        let mut b = Buffer::from_slice(\u0026[1, 2, 3]);\n        b.clear();\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_append_data() {\n        let mut b = Buffer::from_slice(\u0026[1, 2]);\n        b.append_data(\u0026[3, 4, 5]);\n        assert_eq!(b.to_vec(), vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_append_byte() {\n        let mut b = Buffer::new(0);\n        b.append_byte(0x42);\n        assert_eq!(b.to_vec(), vec![0x42]);\n    }\n\n    #[test]\n    fn test_buffer_append_string() {\n        let mut b = Buffer::new(0);\n        b.append_string(\"Hello\");\n        assert_eq!(b.to_vec(), b\"Hello\".to_vec());\n    }\n\n    #[test]\n    fn test_buffer_append_int16_le() {\n        let mut b = Buffer::new(0);\n        b.append_int16_le(0x0102);\n        assert_eq!(b.to_vec(), vec![0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_append_int32_le() {\n        let mut b = Buffer::new(0);\n        b.append_int32_le(0x01020304);\n        assert_eq!(b.to_vec(), vec![0x04, 0x03, 0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_append_int16_be() {\n        let mut b = Buffer::new(0);\n        b.append_int16_be(0x0102);\n        assert_eq!(b.to_vec(), vec![0x01, 0x02]);\n    }\n\n    #[test]\n    fn test_buffer_append_int32_be() {\n        let mut b = Buffer::new(0);\n        b.append_int32_be(0x01020304);\n        assert_eq!(b.to_vec(), vec![0x01, 0x02, 0x03, 0x04]);\n    }\n\n    #[test]\n    fn test_buffer_to_bytes() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let bytes = b.to_bytes();\n        assert_eq!(\u0026bytes[..], \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_md5_digest() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        let digest = b.md5_digest();\n        assert_eq!(digest[0], 0xb1);\n        assert_eq!(digest[1], 0x0a);\n    }\n\n    #[test]\n    fn test_buffer_to_base64() {\n        let b = Buffer::from_slice(b\"Hello World\");\n        assert_eq!(b.to_base64(), \"SGVsbG8gV29ybGQ=\");\n    }\n\n    #[test]\n    fn test_buffer_slice() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let slice = b.slice(1, 4);\n        assert_eq!(slice.to_vec(), vec![2, 3, 4]);\n    }\n\n    #[test]\n    fn test_buffer_split_at() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let (first, second) = b.split_at(3);\n        assert_eq!(first.to_vec(), vec![1, 2, 3]);\n        assert_eq!(second.to_vec(), vec![4, 5]);\n    }\n\n    #[test]\n    fn test_buffer_default() {\n        let b: Buffer = Default::default();\n        assert!(b.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_debug() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let debug = format!(\"{:?}\", b);\n        assert!(debug.contains(\"Buffer\"));\n        assert!(debug.contains(\"len\"));\n    }\n\n    #[test]\n    fn test_buffer_as_ref() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let slice: \u0026[u8] = b.as_ref();\n        assert_eq!(slice, \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_vec() {\n        let b: Buffer = vec![1, 2, 3].into();\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_slice_trait() {\n        let data: \u0026[u8] = \u0026[1, 2, 3];\n        let b: Buffer = data.into();\n        assert_eq!(b.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_from_str() {\n        let b: Buffer = \"Hello\".into();\n        assert_eq!(b.as_str().unwrap(), \"Hello\");\n    }\n\n    // BufferReader tests\n    #[test]\n    fn test_buffer_reader_new() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let reader = BufferReader::new(b);\n        assert_eq!(reader.position(), 0);\n        assert_eq!(reader.remaining(), 5);\n    }\n\n    #[test]\n    fn test_buffer_reader_read() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        let mut buf = [0u8; 3];\n        let n = reader.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, \u0026[1, 2, 3]);\n        assert_eq!(reader.position(), 3);\n        assert_eq!(reader.remaining(), 2);\n    }\n\n    #[test]\n    fn test_buffer_reader_read_byte() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_byte(), Some(1));\n        assert_eq!(reader.read_byte(), Some(2));\n        assert_eq!(reader.read_byte(), Some(3));\n        assert_eq!(reader.read_byte(), None);\n    }\n\n    #[test]\n    fn test_buffer_reader_peek() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3]);\n        let reader = BufferReader::new(b);\n        assert_eq!(reader.peek(), Some(1));\n        assert_eq!(reader.peek(), Some(1)); // Should not advance\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u16_be() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u16_be(), Some(0x0102));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u32_be() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02, 0x03, 0x04]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u32_be(), Some(0x01020304));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u16_le() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u16_le(), Some(0x0201));\n    }\n\n    #[test]\n    fn test_buffer_reader_read_u32_le() {\n        let b = Buffer::from_slice(\u0026[0x01, 0x02, 0x03, 0x04]);\n        let mut reader = BufferReader::new(b);\n        assert_eq!(reader.read_u32_le(), Some(0x04030201));\n    }\n\n    #[test]\n    fn test_buffer_reader_seek() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        reader.seek(3);\n        assert_eq!(reader.position(), 3);\n        assert_eq!(reader.read_byte(), Some(4));\n    }\n\n    #[test]\n    fn test_buffer_reader_skip() {\n        let b = Buffer::from_slice(\u0026[1, 2, 3, 4, 5]);\n        let mut reader = BufferReader::new(b);\n        reader.skip(2);\n        assert_eq!(reader.position(), 2);\n        assert_eq!(reader.read_byte(), Some(3));\n    }\n\n    #[test]\n    fn test_buffer_reader_is_eof() {\n        let b = Buffer::from_slice(\u0026[1]);\n        let mut reader = BufferReader::new(b);\n        assert!(!reader.is_eof());\n        reader.read_byte();\n        assert!(reader.is_eof());\n    }\n\n    // BufferWriter tests\n    #[test]\n    fn test_buffer_writer_new() {\n        let writer = BufferWriter::new();\n        assert!(writer.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_writer_write() {\n        let mut writer = BufferWriter::new();\n        writer.write_all(\u0026[1, 2, 3]).unwrap();\n        assert_eq!(writer.as_slice(), \u0026[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_buffer_writer_into_buffer() {\n        let mut writer = BufferWriter::new();\n        writer.write_all(b\"Hello\").unwrap();\n        let b = writer.into_buffer();\n        assert_eq!(b.as_str().unwrap(), \"Hello\");\n    }\n\n    #[test]\n    fn test_buffer_writer_write_byte() {\n        let mut writer = BufferWriter::new();\n        writer.write_byte(0x42);\n        assert_eq!(writer.as_slice(), \u0026[0x42]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u16_be() {\n        let mut writer = BufferWriter::new();\n        writer.write_u16_be(0x0102);\n        assert_eq!(writer.as_slice(), \u0026[0x01, 0x02]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u32_be() {\n        let mut writer = BufferWriter::new();\n        writer.write_u32_be(0x01020304);\n        assert_eq!(writer.as_slice(), \u0026[0x01, 0x02, 0x03, 0x04]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u16_le() {\n        let mut writer = BufferWriter::new();\n        writer.write_u16_le(0x0102);\n        assert_eq!(writer.as_slice(), \u0026[0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_writer_write_u32_le() {\n        let mut writer = BufferWriter::new();\n        writer.write_u32_le(0x01020304);\n        assert_eq!(writer.as_slice(), \u0026[0x04, 0x03, 0x02, 0x01]);\n    }\n\n    #[test]\n    fn test_buffer_writer_default() {\n        let writer: BufferWriter = Default::default();\n        assert!(writer.is_empty());\n    }\n\n    #[test]\n    fn test_buffer_writer_flush() {\n        let mut writer = BufferWriter::new();\n        assert!(writer.flush().is_ok());\n    }\n\n    #[test]\n    fn test_buffer_clone() {\n        let b1 = Buffer::from_slice(\u0026[1, 2, 3]);\n        let b2 = b1.clone();\n        assert_eq!(b1.to_vec(), b2.to_vec());\n    }\n}\n","traces":[{"line":26,"address":[1377296,1377504,1377498],"length":1,"stats":{"Line":2}},{"line":28,"address":[1377331],"length":1,"stats":{"Line":2}},{"line":29,"address":[1377404,1377346],"length":1,"stats":{"Line":4}},{"line":34,"address":[1710304],"length":1,"stats":{"Line":1}},{"line":36,"address":[1377533],"length":1,"stats":{"Line":1}},{"line":42,"address":[1710400],"length":1,"stats":{"Line":4}},{"line":44,"address":[1710423],"length":1,"stats":{"Line":1}},{"line":50,"address":[1710512],"length":1,"stats":{"Line":1}},{"line":58,"address":[1377792],"length":1,"stats":{"Line":1}},{"line":60,"address":[1710589],"length":1,"stats":{"Line":1}},{"line":66,"address":[1711128,1710672,1711157],"length":1,"stats":{"Line":1}},{"line":68,"address":[1710731,1710895,1710929,1710757],"length":1,"stats":{"Line":4}},{"line":69,"address":[1377955],"length":1,"stats":{"Line":1}},{"line":70,"address":[1754304,1754288],"length":1,"stats":{"Line":3}},{"line":71,"address":[1378201,1378297],"length":1,"stats":{"Line":2}},{"line":76,"address":[1711168,1711637,1711631],"length":1,"stats":{"Line":1}},{"line":77,"address":[1711185],"length":1,"stats":{"Line":1}},{"line":78,"address":[1711226,1711292],"length":1,"stats":{"Line":2}},{"line":79,"address":[1711374,1711310],"length":1,"stats":{"Line":2}},{"line":80,"address":[1711431,1711516,1711400],"length":1,"stats":{"Line":0}},{"line":84,"address":[1711264],"length":1,"stats":{"Line":1}},{"line":89,"address":[1711664],"length":1,"stats":{"Line":1}},{"line":90,"address":[1711669],"length":1,"stats":{"Line":1}},{"line":94,"address":[1379231,1379237,1378896],"length":1,"stats":{"Line":0}},{"line":95,"address":[1711710],"length":1,"stats":{"Line":0}},{"line":96,"address":[1711751,1711822],"length":1,"stats":{"Line":0}},{"line":97,"address":[1379037,1379154,1379082],"length":1,"stats":{"Line":0}},{"line":100,"address":[1711789],"length":1,"stats":{"Line":0}},{"line":106,"address":[1379264,1379704,1379698],"length":1,"stats":{"Line":1}},{"line":108,"address":[1712097],"length":1,"stats":{"Line":1}},{"line":109,"address":[1712150],"length":1,"stats":{"Line":1}},{"line":112,"address":[1712116,1712175],"length":1,"stats":{"Line":0}},{"line":113,"address":[1712255,1712184],"length":1,"stats":{"Line":0}},{"line":114,"address":[1379458,1379506],"length":1,"stats":{"Line":0}},{"line":115,"address":[1712376,1712470],"length":1,"stats":{"Line":0}},{"line":122,"address":[1712222],"length":1,"stats":{"Line":0}},{"line":126,"address":[1712576],"length":1,"stats":{"Line":2}},{"line":127,"address":[1712606],"length":1,"stats":{"Line":2}},{"line":128,"address":[1754448,1754432],"length":1,"stats":{"Line":2}},{"line":132,"address":[1379808,1380379,1380343],"length":1,"stats":{"Line":4}},{"line":133,"address":[1712686],"length":1,"stats":{"Line":3}},{"line":134,"address":[1379882,1379954],"length":1,"stats":{"Line":7}},{"line":135,"address":[1712823,1712890],"length":1,"stats":{"Line":7}},{"line":136,"address":[1712962,1712916],"length":1,"stats":{"Line":7}},{"line":137,"address":[1713051,1712981],"length":1,"stats":{"Line":7}},{"line":138,"address":[1380242],"length":1,"stats":{"Line":4}},{"line":142,"address":[1712768],"length":1,"stats":{"Line":4}},{"line":146,"address":[1380416,1381182,1381146],"length":1,"stats":{"Line":1}},{"line":147,"address":[1713326],"length":1,"stats":{"Line":2}},{"line":148,"address":[1713378,1713444],"length":1,"stats":{"Line":0}},{"line":149,"address":[1713547,1713474],"length":1,"stats":{"Line":0}},{"line":150,"address":[1713607,1713573],"length":1,"stats":{"Line":0}},{"line":151,"address":[1713724,1713800],"length":1,"stats":{"Line":0}},{"line":152,"address":[1713807],"length":1,"stats":{"Line":0}},{"line":153,"address":[1713883],"length":1,"stats":{"Line":0}},{"line":157,"address":[1713421],"length":1,"stats":{"Line":1}},{"line":161,"address":[1715023,1714128,1714954],"length":1,"stats":{"Line":1}},{"line":162,"address":[1714148],"length":1,"stats":{"Line":1}},{"line":163,"address":[1714200,1714281],"length":1,"stats":{"Line":0}},{"line":164,"address":[1714305,1714927,1714378],"length":1,"stats":{"Line":0}},{"line":165,"address":[1714404,1714438],"length":1,"stats":{"Line":0}},{"line":166,"address":[1714555,1714631],"length":1,"stats":{"Line":0}},{"line":167,"address":[1714638],"length":1,"stats":{"Line":0}},{"line":168,"address":[1714709,1714793],"length":1,"stats":{"Line":0}},{"line":172,"address":[1715057,1714238],"length":1,"stats":{"Line":1}},{"line":176,"address":[1382176,1382299],"length":1,"stats":{"Line":1}},{"line":177,"address":[1715299,1715137],"length":1,"stats":{"Line":4}},{"line":178,"address":[1382229,1382290,1382333],"length":1,"stats":{"Line":2}},{"line":183,"address":[1715646,1715675,1715312],"length":1,"stats":{"Line":1}},{"line":184,"address":[1382385],"length":1,"stats":{"Line":1}},{"line":185,"address":[1715363],"length":1,"stats":{"Line":1}},{"line":186,"address":[1715408],"length":1,"stats":{"Line":1}},{"line":187,"address":[1715462,1715528],"length":1,"stats":{"Line":1}},{"line":191,"address":[1715885,1715696],"length":1,"stats":{"Line":1}},{"line":192,"address":[1715714,1715738],"length":1,"stats":{"Line":1}},{"line":193,"address":[1382852,1382876],"length":1,"stats":{"Line":1}},{"line":197,"address":[1715904,1716210,1716204],"length":1,"stats":{"Line":1}},{"line":198,"address":[1715938],"length":1,"stats":{"Line":1}},{"line":199,"address":[1715948],"length":1,"stats":{"Line":1}},{"line":200,"address":[1383077,1383029],"length":1,"stats":{"Line":2}},{"line":201,"address":[1716058,1716124],"length":1,"stats":{"Line":4}},{"line":207,"address":[1383546,1383540,1383264],"length":1,"stats":{"Line":1}},{"line":208,"address":[1716265],"length":1,"stats":{"Line":1}},{"line":209,"address":[1716275],"length":1,"stats":{"Line":1}},{"line":210,"address":[1716316,1716367],"length":1,"stats":{"Line":2}},{"line":211,"address":[1716445,1716385],"length":1,"stats":{"Line":2}},{"line":217,"address":[1716576],"length":1,"stats":{"Line":1}},{"line":218,"address":[1716626],"length":1,"stats":{"Line":1}},{"line":222,"address":[1716656,1716957,1716951],"length":1,"stats":{"Line":1}},{"line":223,"address":[1716683],"length":1,"stats":{"Line":1}},{"line":224,"address":[1716693],"length":1,"stats":{"Line":1}},{"line":225,"address":[1716785,1716734],"length":1,"stats":{"Line":2}},{"line":226,"address":[1716864,1716803],"length":1,"stats":{"Line":2}},{"line":232,"address":[1717278,1716992,1717284],"length":1,"stats":{"Line":1}},{"line":233,"address":[1717014],"length":1,"stats":{"Line":1}},{"line":234,"address":[1717024],"length":1,"stats":{"Line":1}},{"line":235,"address":[1717065,1717116],"length":1,"stats":{"Line":2}},{"line":236,"address":[1717134,1717194],"length":1,"stats":{"Line":2}},{"line":242,"address":[1717613,1717312,1717607],"length":1,"stats":{"Line":1}},{"line":243,"address":[1717339],"length":1,"stats":{"Line":1}},{"line":244,"address":[1717349],"length":1,"stats":{"Line":1}},{"line":245,"address":[1384398,1384350],"length":1,"stats":{"Line":2}},{"line":246,"address":[1717520,1717459],"length":1,"stats":{"Line":2}},{"line":252,"address":[1717940,1717934,1717648],"length":1,"stats":{"Line":1}},{"line":253,"address":[1717670],"length":1,"stats":{"Line":1}},{"line":254,"address":[1717680],"length":1,"stats":{"Line":1}},{"line":255,"address":[1717772,1717721],"length":1,"stats":{"Line":2}},{"line":256,"address":[1717790,1717850],"length":1,"stats":{"Line":2}},{"line":262,"address":[1717968,1718424,1718418],"length":1,"stats":{"Line":1}},{"line":264,"address":[1717998],"length":1,"stats":{"Line":1}},{"line":265,"address":[1718014],"length":1,"stats":{"Line":1}},{"line":266,"address":[1718030],"length":1,"stats":{"Line":1}},{"line":267,"address":[1718213,1718074],"length":1,"stats":{"Line":0}},{"line":268,"address":[1718311,1718243],"length":1,"stats":{"Line":0}},{"line":271,"address":[1718113],"length":1,"stats":{"Line":1}},{"line":275,"address":[1718464],"length":1,"stats":{"Line":1}},{"line":277,"address":[1718483],"length":1,"stats":{"Line":1}},{"line":281,"address":[1718831,1718837,1718528],"length":1,"stats":{"Line":1}},{"line":282,"address":[1718579],"length":1,"stats":{"Line":1}},{"line":283,"address":[1718666,1718603],"length":1,"stats":{"Line":2}},{"line":284,"address":[1718693],"length":1,"stats":{"Line":0}},{"line":286,"address":[1718718,1718676],"length":1,"stats":{"Line":2}},{"line":287,"address":[1718752],"length":1,"stats":{"Line":1}},{"line":291,"address":[1719680,1718864,1719506],"length":1,"stats":{"Line":1}},{"line":292,"address":[1718901],"length":1,"stats":{"Line":1}},{"line":293,"address":[1719019,1718957],"length":1,"stats":{"Line":2}},{"line":294,"address":[1719556,1719052],"length":1,"stats":{"Line":0}},{"line":296,"address":[1385917,1385979],"length":1,"stats":{"Line":2}},{"line":297,"address":[1386048,1386000],"length":1,"stats":{"Line":2}},{"line":298,"address":[1719300,1719192],"length":1,"stats":{"Line":2}},{"line":303,"address":[1386560],"length":1,"stats":{"Line":1}},{"line":304,"address":[1719720],"length":1,"stats":{"Line":1}},{"line":309,"address":[1386592],"length":1,"stats":{"Line":1}},{"line":310,"address":[1719763],"length":1,"stats":{"Line":1}},{"line":315,"address":[1386704],"length":1,"stats":{"Line":1}},{"line":316,"address":[1386709],"length":1,"stats":{"Line":1}},{"line":321,"address":[1719872],"length":1,"stats":{"Line":1}},{"line":322,"address":[1386728],"length":1,"stats":{"Line":1}},{"line":327,"address":[1386752],"length":1,"stats":{"Line":1}},{"line":328,"address":[1386773],"length":1,"stats":{"Line":1}},{"line":333,"address":[1719952],"length":1,"stats":{"Line":1}},{"line":334,"address":[1386850],"length":1,"stats":{"Line":1}},{"line":339,"address":[1386880],"length":1,"stats":{"Line":0}},{"line":340,"address":[1720040],"length":1,"stats":{"Line":0}},{"line":345,"address":[1720064],"length":1,"stats":{"Line":0}},{"line":346,"address":[1386920],"length":1,"stats":{"Line":0}},{"line":351,"address":[1821361,1821280],"length":1,"stats":{"Line":0}},{"line":352,"address":[1821297],"length":1,"stats":{"Line":0}},{"line":364,"address":[1386944,1387068],"length":1,"stats":{"Line":2}},{"line":366,"address":[1720114],"length":1,"stats":{"Line":2}},{"line":372,"address":[1387088],"length":1,"stats":{"Line":1}},{"line":373,"address":[1720261],"length":1,"stats":{"Line":1}},{"line":377,"address":[1720272],"length":1,"stats":{"Line":1}},{"line":378,"address":[1720286],"length":1,"stats":{"Line":1}},{"line":382,"address":[1387152],"length":1,"stats":{"Line":1}},{"line":383,"address":[1387161],"length":1,"stats":{"Line":1}},{"line":387,"address":[1720368],"length":1,"stats":{"Line":1}},{"line":388,"address":[1720382],"length":1,"stats":{"Line":1}},{"line":392,"address":[1720432],"length":1,"stats":{"Line":1}},{"line":393,"address":[1387278,1387310,1387465],"length":1,"stats":{"Line":3}},{"line":394,"address":[1720593,1720485,1720552],"length":1,"stats":{"Line":3}},{"line":395,"address":[1720563,1720620,1720635],"length":1,"stats":{"Line":3}},{"line":396,"address":[1387456],"length":1,"stats":{"Line":1}},{"line":398,"address":[1720473],"length":1,"stats":{"Line":1}},{"line":403,"address":[1720656],"length":1,"stats":{"Line":1}},{"line":404,"address":[1720670,1721005,1720689],"length":1,"stats":{"Line":2}},{"line":405,"address":[1387716],"length":1,"stats":{"Line":1}},{"line":406,"address":[1720825,1720696,1720765],"length":1,"stats":{"Line":2}},{"line":407,"address":[1720848,1720772,1720961],"length":1,"stats":{"Line":2}},{"line":409,"address":[1720989,1721010,1720931],"length":1,"stats":{"Line":2}},{"line":410,"address":[1387824],"length":1,"stats":{"Line":1}},{"line":412,"address":[1387513],"length":1,"stats":{"Line":0}},{"line":417,"address":[1387856],"length":1,"stats":{"Line":1}},{"line":418,"address":[1388549,1387879,1387901],"length":1,"stats":{"Line":2}},{"line":419,"address":[1721560],"length":1,"stats":{"Line":1}},{"line":420,"address":[1721240,1721171,1721080],"length":1,"stats":{"Line":2}},{"line":421,"address":[1388094,1388195,1388009],"length":1,"stats":{"Line":2}},{"line":422,"address":[1721387,1721308,1721488],"length":1,"stats":{"Line":2}},{"line":423,"address":[1388263,1388497,1388342],"length":1,"stats":{"Line":2}},{"line":425,"address":[1388554,1388467,1388527],"length":1,"stats":{"Line":2}},{"line":426,"address":[1388531],"length":1,"stats":{"Line":1}},{"line":428,"address":[1721059],"length":1,"stats":{"Line":0}},{"line":433,"address":[1388576],"length":1,"stats":{"Line":1}},{"line":434,"address":[1388608,1388590,1388924],"length":1,"stats":{"Line":2}},{"line":435,"address":[1388804],"length":1,"stats":{"Line":1}},{"line":436,"address":[1388684,1388615,1388744],"length":1,"stats":{"Line":2}},{"line":437,"address":[1388691,1388767,1388880],"length":1,"stats":{"Line":2}},{"line":439,"address":[1722077,1722098,1722019],"length":1,"stats":{"Line":2}},{"line":440,"address":[1722081],"length":1,"stats":{"Line":1}},{"line":442,"address":[1388601],"length":1,"stats":{"Line":0}},{"line":447,"address":[1722112],"length":1,"stats":{"Line":1}},{"line":448,"address":[1722135,1722158,1722806],"length":1,"stats":{"Line":2}},{"line":449,"address":[1722648],"length":1,"stats":{"Line":1}},{"line":450,"address":[1389090,1389159,1388999],"length":1,"stats":{"Line":2}},{"line":451,"address":[1722452,1722266,1722351],"length":1,"stats":{"Line":2}},{"line":452,"address":[1389407,1389306,1389227],"length":1,"stats":{"Line":2}},{"line":453,"address":[1389351,1389585,1389430],"length":1,"stats":{"Line":2}},{"line":455,"address":[1722724,1722784,1722811],"length":1,"stats":{"Line":2}},{"line":456,"address":[1389619],"length":1,"stats":{"Line":1}},{"line":458,"address":[1722147],"length":1,"stats":{"Line":0}},{"line":463,"address":[1389664],"length":1,"stats":{"Line":1}},{"line":464,"address":[1722856],"length":1,"stats":{"Line":1}},{"line":468,"address":[1389728],"length":1,"stats":{"Line":1}},{"line":469,"address":[1389747,1389802],"length":1,"stats":{"Line":1}},{"line":474,"address":[1389824],"length":1,"stats":{"Line":1}},{"line":475,"address":[1389861],"length":1,"stats":{"Line":1}},{"line":476,"address":[1389928],"length":1,"stats":{"Line":1}},{"line":477,"address":[1389960],"length":1,"stats":{"Line":1}},{"line":478,"address":[1723293,1723228],"length":1,"stats":{"Line":1}},{"line":479,"address":[1390093],"length":1,"stats":{"Line":1}},{"line":490,"address":[1723312],"length":1,"stats":{"Line":1}},{"line":492,"address":[1390158],"length":1,"stats":{"Line":1}},{"line":497,"address":[1723392],"length":1,"stats":{"Line":0}},{"line":499,"address":[1390242],"length":1,"stats":{"Line":0}},{"line":504,"address":[1723472],"length":1,"stats":{"Line":1}},{"line":505,"address":[1723483],"length":1,"stats":{"Line":1}},{"line":509,"address":[1390384],"length":1,"stats":{"Line":1}},{"line":510,"address":[1723557],"length":1,"stats":{"Line":2}},{"line":514,"address":[1390400],"length":1,"stats":{"Line":0}},{"line":515,"address":[1723573],"length":1,"stats":{"Line":0}},{"line":519,"address":[1723584],"length":1,"stats":{"Line":2}},{"line":520,"address":[1390421],"length":1,"stats":{"Line":2}},{"line":524,"address":[1390432],"length":1,"stats":{"Line":1}},{"line":525,"address":[1390448],"length":1,"stats":{"Line":1}},{"line":529,"address":[1390464],"length":1,"stats":{"Line":1}},{"line":530,"address":[1390481],"length":1,"stats":{"Line":1}},{"line":534,"address":[1390496],"length":1,"stats":{"Line":1}},{"line":535,"address":[1723677],"length":1,"stats":{"Line":1}},{"line":539,"address":[1723696],"length":1,"stats":{"Line":1}},{"line":540,"address":[1723713],"length":1,"stats":{"Line":1}},{"line":544,"address":[1723728],"length":1,"stats":{"Line":1}},{"line":545,"address":[1723741],"length":1,"stats":{"Line":1}},{"line":550,"address":[1723760],"length":1,"stats":{"Line":1}},{"line":551,"address":[1723768],"length":1,"stats":{"Line":1}},{"line":556,"address":[1723792],"length":1,"stats":{"Line":1}},{"line":557,"address":[1723816],"length":1,"stats":{"Line":2}},{"line":558,"address":[1723826],"length":1,"stats":{"Line":2}},{"line":561,"address":[1390688],"length":1,"stats":{"Line":1}},{"line":562,"address":[1723861],"length":1,"stats":{"Line":1}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[1605740,1605616],"length":1,"stats":{"Line":0}},{"line":648,"address":[1605639],"length":1,"stats":{"Line":0}},{"line":655,"address":[1605760],"length":1,"stats":{"Line":0}},{"line":660,"address":[1605787],"length":1,"stats":{"Line":0}},{"line":661,"address":[1605875],"length":1,"stats":{"Line":0}},{"line":662,"address":[1605920],"length":1,"stats":{"Line":0}},{"line":663,"address":[1605953,1606050],"length":1,"stats":{"Line":0}},{"line":664,"address":[1606004],"length":1,"stats":{"Line":0}}],"covered":198,"coverable":268},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","colorspace.rs"],"content":"//! Colorspace definitions\n\n#[derive(Debug, Clone)]\npub struct Colorspace { name: String, n: u8 }\n\nimpl Colorspace {\n    pub fn device_gray() -\u003e Self { Self { name: \"DeviceGray\".into(), n: 1 } }\n    pub fn device_rgb() -\u003e Self { Self { name: \"DeviceRGB\".into(), n: 3 } }\n    pub fn device_cmyk() -\u003e Self { Self { name: \"DeviceCMYK\".into(), n: 4 } }\n    pub fn name(\u0026self) -\u003e \u0026str { \u0026self.name }\n    pub fn n(\u0026self) -\u003e u8 { self.n }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_device_gray() {\n        let cs = Colorspace::device_gray();\n        assert_eq!(cs.name(), \"DeviceGray\");\n        assert_eq!(cs.n(), 1);\n    }\n\n    #[test]\n    fn test_device_rgb() {\n        let cs = Colorspace::device_rgb();\n        assert_eq!(cs.name(), \"DeviceRGB\");\n        assert_eq!(cs.n(), 3);\n    }\n\n    #[test]\n    fn test_device_cmyk() {\n        let cs = Colorspace::device_cmyk();\n        assert_eq!(cs.name(), \"DeviceCMYK\");\n        assert_eq!(cs.n(), 4);\n    }\n\n    #[test]\n    fn test_colorspace_clone() {\n        let cs1 = Colorspace::device_rgb();\n        let cs2 = cs1.clone();\n        assert_eq!(cs1.name(), cs2.name());\n        assert_eq!(cs1.n(), cs2.n());\n    }\n\n    #[test]\n    fn test_colorspace_debug() {\n        let cs = Colorspace::device_rgb();\n        let debug = format!(\"{:?}\", cs);\n        assert!(debug.contains(\"DeviceRGB\"));\n        assert!(debug.contains(\"3\"));\n    }\n}\n\n","traces":[{"line":7,"address":[1680656,1680669],"length":1,"stats":{"Line":2}},{"line":8,"address":[1680752,1680765],"length":1,"stats":{"Line":5}},{"line":9,"address":[1680861,1680848],"length":1,"stats":{"Line":2}},{"line":10,"address":[1680949,1680944],"length":1,"stats":{"Line":3}},{"line":11,"address":[1680965,1680960],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":5},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","device.rs"],"content":"//! Rendering device trait\nuse crate::fitz::geometry::{Matrix, Rect};\nuse crate::fitz::path::Path;\nuse crate::fitz::text::TextSpan;\nuse crate::fitz::image::Image;\nuse crate::fitz::colorspace::Colorspace;\n\npub trait Device {\n    fn fill_path(\u0026mut self, path: \u0026Path, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn stroke_path(\u0026mut self, path: \u0026Path, stroke: \u0026StrokeState, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn fill_text(\u0026mut self, text: \u0026TextSpan, ctm: Matrix, colorspace: \u0026Colorspace, color: \u0026[f32], alpha: f32);\n    fn fill_image(\u0026mut self, image: \u0026Image, ctm: Matrix, alpha: f32);\n}\n\npub struct StrokeState { pub linewidth: f32, pub linecap: u8, pub linejoin: u8 }\nimpl Default for StrokeState { fn default() -\u003e Self { Self { linewidth: 1.0, linecap: 0, linejoin: 0 } } }\n\npub struct NullDevice;\nimpl Device for NullDevice {\n    fn fill_path(\u0026mut self, _: \u0026Path, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn stroke_path(\u0026mut self, _: \u0026Path, _: \u0026StrokeState, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn fill_text(\u0026mut self, _: \u0026TextSpan, _: Matrix, _: \u0026Colorspace, _: \u0026[f32], _: f32) {}\n    fn fill_image(\u0026mut self, _: \u0026Image, _: Matrix, _: f32) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::fitz::geometry::Point;\n\n    #[test]\n    fn test_stroke_state_default() {\n        let ss: StrokeState = Default::default();\n        assert_eq!(ss.linewidth, 1.0);\n        assert_eq!(ss.linecap, 0);\n        assert_eq!(ss.linejoin, 0);\n    }\n\n    #[test]\n    fn test_stroke_state_custom() {\n        let ss = StrokeState {\n            linewidth: 2.5,\n            linecap: 1,\n            linejoin: 2,\n        };\n        assert_eq!(ss.linewidth, 2.5);\n        assert_eq!(ss.linecap, 1);\n        assert_eq!(ss.linejoin, 2);\n    }\n\n    #[test]\n    fn test_null_device_fill_path() {\n        let mut device = NullDevice;\n        let path = Path::new();\n        let cs = Colorspace::device_rgb();\n        let color = [1.0, 0.0, 0.0];\n\n        // Should not panic\n        device.fill_path(\u0026path, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_stroke_path() {\n        let mut device = NullDevice;\n        let path = Path::new();\n        let cs = Colorspace::device_rgb();\n        let color = [0.0, 1.0, 0.0];\n        let stroke = StrokeState::default();\n\n        // Should not panic\n        device.stroke_path(\u0026path, \u0026stroke, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_fill_text() {\n        let mut device = NullDevice;\n        let text = TextSpan::new();\n        let cs = Colorspace::device_rgb();\n        let color = [0.0, 0.0, 0.0];\n\n        // Should not panic\n        device.fill_text(\u0026text, Matrix::IDENTITY, \u0026cs, \u0026color, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_fill_image() {\n        let mut device = NullDevice;\n        let image = Image::new(100, 100, None);\n\n        // Should not panic\n        device.fill_image(\u0026image, Matrix::IDENTITY, 1.0);\n    }\n\n    #[test]\n    fn test_null_device_implements_device_trait() {\n        fn takes_device\u003cD: Device\u003e(_d: \u0026mut D) {}\n        let mut device = NullDevice;\n        takes_device(\u0026mut device);\n    }\n}\n\n","traces":[{"line":16,"address":[1892560],"length":1,"stats":{"Line":1}},{"line":20,"address":[1892623,1892592],"length":1,"stats":{"Line":2}},{"line":21,"address":[1892665,1892624],"length":1,"stats":{"Line":2}},{"line":22,"address":[1892703,1892672],"length":1,"stats":{"Line":2}},{"line":23,"address":[1892720,1892704],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","document.rs"],"content":"//! Document trait\nuse crate::fitz::error::Result;\nuse crate::fitz::page::Page;\n\npub trait Document {\n    fn page_count(\u0026self) -\u003e i32;\n    fn load_page(\u0026self, page_num: i32) -\u003e Result\u003cBox\u003cdyn Page + '_\u003e\u003e;\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","error.rs"],"content":"//! Error handling for MicroPDF\n\nuse std::io;\nuse thiserror::Error;\n\n/// The main error type for MicroPDF operations\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"{0}\")]\n    Generic(String),\n    #[error(\"System error: {0}\")]\n    System(#[from] io::Error),\n    #[error(\"Invalid argument: {0}\")]\n    Argument(String),\n    #[error(\"Limit exceeded: {0}\")]\n    Limit(String),\n    #[error(\"Unsupported: {0}\")]\n    Unsupported(String),\n    #[error(\"Format error: {0}\")]\n    Format(String),\n    #[error(\"Syntax error: {0}\")]\n    Syntax(String),\n    #[error(\"PDF error: {0}\")]\n    Pdf(String),\n    #[error(\"Encryption error: {0}\")]\n    Encryption(String),\n    #[error(\"Font error: {0}\")]\n    Font(String),\n    #[error(\"Image error: {0}\")]\n    Image(String),\n    #[error(\"Unexpected end of file\")]\n    Eof,\n    #[error(\"Operation aborted\")]\n    Abort,\n}\n\nimpl Error {\n    pub fn generic\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Generic(msg.into()) }\n    pub fn argument\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Argument(msg.into()) }\n    pub fn limit\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Limit(msg.into()) }\n    pub fn unsupported\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Unsupported(msg.into()) }\n    pub fn format\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Format(msg.into()) }\n    pub fn syntax\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Syntax(msg.into()) }\n    pub fn pdf\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Pdf(msg.into()) }\n    pub fn encryption\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Encryption(msg.into()) }\n    pub fn font\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Font(msg.into()) }\n    pub fn image\u003cS: Into\u003cString\u003e\u003e(msg: S) -\u003e Self { Error::Image(msg.into()) }\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_generic() {\n        let e = Error::generic(\"test error\");\n        assert!(matches!(e, Error::Generic(_)));\n        assert_eq!(format!(\"{}\", e), \"test error\");\n    }\n\n    #[test]\n    fn test_error_argument() {\n        let e = Error::argument(\"bad argument\");\n        assert!(matches!(e, Error::Argument(_)));\n        assert!(format!(\"{}\", e).contains(\"bad argument\"));\n    }\n\n    #[test]\n    fn test_error_limit() {\n        let e = Error::limit(\"size exceeded\");\n        assert!(matches!(e, Error::Limit(_)));\n        assert!(format!(\"{}\", e).contains(\"size exceeded\"));\n    }\n\n    #[test]\n    fn test_error_unsupported() {\n        let e = Error::unsupported(\"feature not supported\");\n        assert!(matches!(e, Error::Unsupported(_)));\n        assert!(format!(\"{}\", e).contains(\"feature not supported\"));\n    }\n\n    #[test]\n    fn test_error_format() {\n        let e = Error::format(\"invalid format\");\n        assert!(matches!(e, Error::Format(_)));\n        assert!(format!(\"{}\", e).contains(\"invalid format\"));\n    }\n\n    #[test]\n    fn test_error_syntax() {\n        let e = Error::syntax(\"syntax error at line 5\");\n        assert!(matches!(e, Error::Syntax(_)));\n        assert!(format!(\"{}\", e).contains(\"syntax error\"));\n    }\n\n    #[test]\n    fn test_error_pdf() {\n        let e = Error::pdf(\"invalid PDF structure\");\n        assert!(matches!(e, Error::Pdf(_)));\n        assert!(format!(\"{}\", e).contains(\"invalid PDF\"));\n    }\n\n    #[test]\n    fn test_error_encryption() {\n        let e = Error::encryption(\"wrong password\");\n        assert!(matches!(e, Error::Encryption(_)));\n        assert!(format!(\"{}\", e).contains(\"wrong password\"));\n    }\n\n    #[test]\n    fn test_error_font() {\n        let e = Error::font(\"font not found\");\n        assert!(matches!(e, Error::Font(_)));\n        assert!(format!(\"{}\", e).contains(\"font not found\"));\n    }\n\n    #[test]\n    fn test_error_image() {\n        let e = Error::image(\"corrupted image\");\n        assert!(matches!(e, Error::Image(_)));\n        assert!(format!(\"{}\", e).contains(\"corrupted image\"));\n    }\n\n    #[test]\n    fn test_error_eof() {\n        let e = Error::Eof;\n        assert!(matches!(e, Error::Eof));\n        assert!(format!(\"{}\", e).contains(\"end of file\"));\n    }\n\n    #[test]\n    fn test_error_abort() {\n        let e = Error::Abort;\n        assert!(matches!(e, Error::Abort));\n        assert!(format!(\"{}\", e).contains(\"aborted\"));\n    }\n\n    #[test]\n    fn test_error_from_io_error() {\n        let io_err = io::Error::new(io::ErrorKind::NotFound, \"file not found\");\n        let e: Error = io_err.into();\n        assert!(matches!(e, Error::System(_)));\n        assert!(format!(\"{}\", e).contains(\"file not found\"));\n    }\n\n    #[test]\n    fn test_error_debug() {\n        let e = Error::generic(\"test\");\n        let debug = format!(\"{:?}\", e);\n        assert!(debug.contains(\"Generic\"));\n    }\n\n    #[test]\n    fn test_result_type() {\n        fn returns_ok() -\u003e Result\u003ci32\u003e {\n            Ok(42)\n        }\n\n        fn returns_err() -\u003e Result\u003ci32\u003e {\n            Err(Error::generic(\"error\"))\n        }\n\n        assert_eq!(returns_ok().unwrap(), 42);\n        assert!(returns_err().is_err());\n    }\n}\n\n","traces":[{"line":38,"address":[1726880,1726903],"length":1,"stats":{"Line":2}},{"line":39,"address":[1726976,1726999],"length":1,"stats":{"Line":2}},{"line":40,"address":[1809719,1809696],"length":1,"stats":{"Line":2}},{"line":41,"address":[1809792,1809815],"length":1,"stats":{"Line":2}},{"line":42,"address":[1727072,1727085],"length":1,"stats":{"Line":5}},{"line":43,"address":[1810064,1810087],"length":1,"stats":{"Line":2}},{"line":44,"address":[1810183,1810160],"length":1,"stats":{"Line":2}},{"line":45,"address":[1810256,1810279],"length":1,"stats":{"Line":2}},{"line":46,"address":[1810375,1810352],"length":1,"stats":{"Line":2}},{"line":47,"address":[1810448,1810471],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","font.rs"],"content":"//! Font handling\npub struct Font { name: String }\nimpl Font {\n    pub fn new(name: \u0026str) -\u003e Self { Self { name: name.to_string() } }\n    pub fn name(\u0026self) -\u003e \u0026str { \u0026self.name }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_font_new() {\n        let font = Font::new(\"Helvetica\");\n        assert_eq!(font.name(), \"Helvetica\");\n    }\n\n    #[test]\n    fn test_font_empty_name() {\n        let font = Font::new(\"\");\n        assert_eq!(font.name(), \"\");\n    }\n\n    #[test]\n    fn test_font_unicode_name() {\n        let font = Font::new(\"Arial\");\n        assert_eq!(font.name(), \"Arial\");\n    }\n}\n\n","traces":[{"line":4,"address":[1370896,1370919],"length":1,"stats":{"Line":3}},{"line":5,"address":[1370981,1370976],"length":1,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","geometry.rs"],"content":"//! Geometry primitives - Point, Rect, Matrix, Quad\n\nuse std::f32::{INFINITY, NEG_INFINITY};\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Point { pub x: f32, pub y: f32 }\n\nimpl Point {\n    pub const ORIGIN: Point = Point { x: 0.0, y: 0.0 };\n    pub fn new(x: f32, y: f32) -\u003e Self { Self { x, y } }\n    pub fn transform(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            x: self.x * m.a + self.y * m.c + m.e,\n            y: self.x * m.b + self.y * m.d + m.f,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Rect { pub x0: f32, pub y0: f32, pub x1: f32, pub y1: f32 }\n\nimpl Rect {\n    pub const EMPTY: Rect = Rect { x0: INFINITY, y0: INFINITY, x1: NEG_INFINITY, y1: NEG_INFINITY };\n    pub const INFINITE: Rect = Rect { x0: NEG_INFINITY, y0: NEG_INFINITY, x1: INFINITY, y1: INFINITY };\n    pub const UNIT: Rect = Rect { x0: 0.0, y0: 0.0, x1: 1.0, y1: 1.0 };\n\n    pub fn new(x0: f32, y0: f32, x1: f32, y1: f32) -\u003e Self { Self { x0, y0, x1, y1 } }\n    pub fn width(\u0026self) -\u003e f32 { self.x1 - self.x0 }\n    pub fn height(\u0026self) -\u003e f32 { self.y1 - self.y0 }\n    pub fn is_empty(\u0026self) -\u003e bool { self.x0 \u003e= self.x1 || self.y0 \u003e= self.y1 }\n    pub fn is_infinite(\u0026self) -\u003e bool { self.x0 == NEG_INFINITY }\n    pub fn contains(\u0026self, x: f32, y: f32) -\u003e bool {\n        x \u003e= self.x0 \u0026\u0026 x \u003c self.x1 \u0026\u0026 y \u003e= self.y0 \u0026\u0026 y \u003c self.y1\n    }\n    pub fn union(\u0026self, other: \u0026Rect) -\u003e Rect {\n        Rect {\n            x0: self.x0.min(other.x0), y0: self.y0.min(other.y0),\n            x1: self.x1.max(other.x1), y1: self.y1.max(other.y1),\n        }\n    }\n    pub fn intersect(\u0026self, other: \u0026Rect) -\u003e Rect {\n        Rect {\n            x0: self.x0.max(other.x0), y0: self.y0.max(other.y0),\n            x1: self.x1.min(other.x1), y1: self.y1.min(other.y1),\n        }\n    }\n    pub fn include_point(\u0026mut self, p: Point) {\n        self.x0 = self.x0.min(p.x); self.y0 = self.y0.min(p.y);\n        self.x1 = self.x1.max(p.x); self.y1 = self.y1.max(p.y);\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct IRect { pub x0: i32, pub y0: i32, pub x1: i32, pub y1: i32 }\n\nimpl IRect {\n    pub fn new(x0: i32, y0: i32, x1: i32, y1: i32) -\u003e Self { Self { x0, y0, x1, y1 } }\n    pub fn width(\u0026self) -\u003e i32 { self.x1 - self.x0 }\n    pub fn height(\u0026self) -\u003e i32 { self.y1 - self.y0 }\n    pub fn is_empty(\u0026self) -\u003e bool { self.x0 \u003e= self.x1 || self.y0 \u003e= self.y1 }\n}\n\nimpl From\u003cRect\u003e for IRect {\n    fn from(r: Rect) -\u003e Self {\n        IRect { x0: r.x0.floor() as i32, y0: r.y0.floor() as i32,\n                x1: r.x1.ceil() as i32, y1: r.y1.ceil() as i32 }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Matrix { pub a: f32, pub b: f32, pub c: f32, pub d: f32, pub e: f32, pub f: f32 }\n\nimpl Default for Matrix {\n    fn default() -\u003e Self { Self::IDENTITY }\n}\n\nimpl Matrix {\n    pub const IDENTITY: Matrix = Matrix { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 };\n\n    pub fn new(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32) -\u003e Self { Self { a, b, c, d, e, f } }\n    pub fn translate(tx: f32, ty: f32) -\u003e Self { Self { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: tx, f: ty } }\n    pub fn scale(sx: f32, sy: f32) -\u003e Self { Self { a: sx, b: 0.0, c: 0.0, d: sy, e: 0.0, f: 0.0 } }\n    pub fn rotate(degrees: f32) -\u003e Self {\n        let rad = degrees * std::f32::consts::PI / 180.0;\n        let (s, c) = (rad.sin(), rad.cos());\n        Self { a: c, b: s, c: -s, d: c, e: 0.0, f: 0.0 }\n    }\n    pub fn concat(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            a: self.a * m.a + self.b * m.c,\n            b: self.a * m.b + self.b * m.d,\n            c: self.c * m.a + self.d * m.c,\n            d: self.c * m.b + self.d * m.d,\n            e: self.e * m.a + self.f * m.c + m.e,\n            f: self.e * m.b + self.f * m.d + m.f,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Default)]\npub struct Quad { pub ul: Point, pub ur: Point, pub ll: Point, pub lr: Point }\n\nimpl Quad {\n    pub fn from_rect(r: \u0026Rect) -\u003e Self {\n        Self {\n            ul: Point::new(r.x0, r.y0), ur: Point::new(r.x1, r.y0),\n            ll: Point::new(r.x0, r.y1), lr: Point::new(r.x1, r.y1),\n        }\n    }\n    pub fn transform(\u0026self, m: \u0026Matrix) -\u003e Self {\n        Self {\n            ul: self.ul.transform(m), ur: self.ur.transform(m),\n            ll: self.ll.transform(m), lr: self.lr.transform(m),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Point tests\n    #[test]\n    fn test_point_origin() {\n        assert_eq!(Point::ORIGIN.x, 0.0);\n        assert_eq!(Point::ORIGIN.y, 0.0);\n    }\n\n    #[test]\n    fn test_point_new() {\n        let p = Point::new(3.0, 4.0);\n        assert_eq!(p.x, 3.0);\n        assert_eq!(p.y, 4.0);\n    }\n\n    #[test]\n    fn test_point_transform_identity() {\n        let p = Point::new(5.0, 10.0);\n        let transformed = p.transform(\u0026Matrix::IDENTITY);\n        assert_eq!(transformed.x, 5.0);\n        assert_eq!(transformed.y, 10.0);\n    }\n\n    #[test]\n    fn test_point_transform_translate() {\n        let p = Point::new(5.0, 10.0);\n        let m = Matrix::translate(2.0, 3.0);\n        let transformed = p.transform(\u0026m);\n        assert!((transformed.x - 7.0).abs() \u003c 0.001);\n        assert!((transformed.y - 13.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_point_transform_scale() {\n        let p = Point::new(5.0, 10.0);\n        let m = Matrix::scale(2.0, 3.0);\n        let transformed = p.transform(\u0026m);\n        assert!((transformed.x - 10.0).abs() \u003c 0.001);\n        assert!((transformed.y - 30.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_point_default() {\n        let p: Point = Default::default();\n        assert_eq!(p.x, 0.0);\n        assert_eq!(p.y, 0.0);\n    }\n\n    // Rect tests\n    #[test]\n    fn test_rect_new() {\n        let r = Rect::new(1.0, 2.0, 10.0, 20.0);\n        assert_eq!(r.x0, 1.0);\n        assert_eq!(r.y0, 2.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 20.0);\n    }\n\n    #[test]\n    fn test_rect_width_height() {\n        let r = Rect::new(0.0, 0.0, 10.0, 20.0);\n        assert_eq!(r.width(), 10.0);\n        assert_eq!(r.height(), 20.0);\n    }\n\n    #[test]\n    fn test_rect_is_empty() {\n        assert!(Rect::EMPTY.is_empty());\n        assert!(!Rect::UNIT.is_empty());\n        assert!(Rect::new(10.0, 10.0, 5.0, 5.0).is_empty()); // inverted\n    }\n\n    #[test]\n    fn test_rect_is_infinite() {\n        assert!(Rect::INFINITE.is_infinite());\n        assert!(!Rect::UNIT.is_infinite());\n    }\n\n    #[test]\n    fn test_rect_contains() {\n        let r = Rect::new(0.0, 0.0, 10.0, 10.0);\n        assert!(r.contains(5.0, 5.0));\n        assert!(r.contains(0.0, 0.0));\n        assert!(!r.contains(10.0, 10.0)); // exclusive upper bound\n        assert!(!r.contains(-1.0, 5.0));\n        assert!(!r.contains(5.0, -1.0));\n        assert!(!r.contains(11.0, 5.0));\n        assert!(!r.contains(5.0, 11.0));\n    }\n\n    #[test]\n    fn test_rect_union() {\n        let r1 = Rect::new(0.0, 0.0, 5.0, 5.0);\n        let r2 = Rect::new(3.0, 3.0, 10.0, 10.0);\n        let u = r1.union(\u0026r2);\n        assert_eq!(u.x0, 0.0);\n        assert_eq!(u.y0, 0.0);\n        assert_eq!(u.x1, 10.0);\n        assert_eq!(u.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_intersect() {\n        let r1 = Rect::new(0.0, 0.0, 10.0, 10.0);\n        let r2 = Rect::new(5.0, 5.0, 15.0, 15.0);\n        let i = r1.intersect(\u0026r2);\n        assert_eq!(i.x0, 5.0);\n        assert_eq!(i.y0, 5.0);\n        assert_eq!(i.x1, 10.0);\n        assert_eq!(i.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_include_point() {\n        let mut r = Rect::EMPTY;\n        r.include_point(Point::new(5.0, 5.0));\n        r.include_point(Point::new(0.0, 0.0));\n        r.include_point(Point::new(10.0, 10.0));\n        assert_eq!(r.x0, 0.0);\n        assert_eq!(r.y0, 0.0);\n        assert_eq!(r.x1, 10.0);\n        assert_eq!(r.y1, 10.0);\n    }\n\n    #[test]\n    fn test_rect_constants() {\n        assert!(Rect::EMPTY.is_empty());\n        assert!(Rect::INFINITE.is_infinite());\n        assert_eq!(Rect::UNIT.width(), 1.0);\n        assert_eq!(Rect::UNIT.height(), 1.0);\n    }\n\n    // IRect tests\n    #[test]\n    fn test_irect_new() {\n        let r = IRect::new(1, 2, 10, 20);\n        assert_eq!(r.x0, 1);\n        assert_eq!(r.y0, 2);\n        assert_eq!(r.x1, 10);\n        assert_eq!(r.y1, 20);\n    }\n\n    #[test]\n    fn test_irect_width_height() {\n        let r = IRect::new(0, 0, 10, 20);\n        assert_eq!(r.width(), 10);\n        assert_eq!(r.height(), 20);\n    }\n\n    #[test]\n    fn test_irect_is_empty() {\n        assert!(IRect::new(5, 5, 5, 5).is_empty());\n        assert!(IRect::new(10, 10, 5, 5).is_empty());\n        assert!(!IRect::new(0, 0, 10, 10).is_empty());\n    }\n\n    #[test]\n    fn test_irect_from_rect() {\n        let r = Rect::new(0.5, 1.5, 9.5, 19.5);\n        let ir: IRect = r.into();\n        assert_eq!(ir.x0, 0);\n        assert_eq!(ir.y0, 1);\n        assert_eq!(ir.x1, 10);\n        assert_eq!(ir.y1, 20);\n    }\n\n    // Matrix tests\n    #[test]\n    fn test_matrix_identity() {\n        let m = Matrix::IDENTITY;\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 0.0);\n        assert_eq!(m.c, 0.0);\n        assert_eq!(m.d, 1.0);\n        assert_eq!(m.e, 0.0);\n        assert_eq!(m.f, 0.0);\n    }\n\n    #[test]\n    fn test_matrix_new() {\n        let m = Matrix::new(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.b, 2.0);\n        assert_eq!(m.c, 3.0);\n        assert_eq!(m.d, 4.0);\n        assert_eq!(m.e, 5.0);\n        assert_eq!(m.f, 6.0);\n    }\n\n    #[test]\n    fn test_matrix_translate() {\n        let m = Matrix::translate(10.0, 20.0);\n        assert_eq!(m.e, 10.0);\n        assert_eq!(m.f, 20.0);\n        // Should be identity otherwise\n        assert_eq!(m.a, 1.0);\n        assert_eq!(m.d, 1.0);\n    }\n\n    #[test]\n    fn test_matrix_scale() {\n        let m = Matrix::scale(2.0, 3.0);\n        assert_eq!(m.a, 2.0);\n        assert_eq!(m.d, 3.0);\n    }\n\n    #[test]\n    fn test_matrix_rotate() {\n        let m = Matrix::rotate(90.0);\n        // cos(90)  0, sin(90) = 1\n        assert!((m.a - 0.0).abs() \u003c 0.001);\n        assert!((m.b - 1.0).abs() \u003c 0.001);\n        assert!((m.c - (-1.0)).abs() \u003c 0.001);\n        assert!((m.d - 0.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_matrix_concat_identity() {\n        let m1 = Matrix::scale(2.0, 3.0);\n        let m2 = Matrix::IDENTITY;\n        let result = m1.concat(\u0026m2);\n        assert_eq!(result.a, 2.0);\n        assert_eq!(result.d, 3.0);\n    }\n\n    #[test]\n    fn test_matrix_concat_scale_translate() {\n        let scale = Matrix::scale(2.0, 2.0);\n        let translate = Matrix::translate(10.0, 10.0);\n        let result = scale.concat(\u0026translate);\n        // Scaling first, then translating\n        assert_eq!(result.e, 10.0);\n        assert_eq!(result.f, 10.0);\n    }\n\n    #[test]\n    fn test_matrix_default() {\n        let m: Matrix = Default::default();\n        assert_eq!(m, Matrix::IDENTITY);\n    }\n\n    // Quad tests\n    #[test]\n    fn test_quad_from_rect() {\n        let r = Rect::new(0.0, 0.0, 10.0, 20.0);\n        let q = Quad::from_rect(\u0026r);\n        assert_eq!(q.ul.x, 0.0);\n        assert_eq!(q.ul.y, 0.0);\n        assert_eq!(q.ur.x, 10.0);\n        assert_eq!(q.ur.y, 0.0);\n        assert_eq!(q.ll.x, 0.0);\n        assert_eq!(q.ll.y, 20.0);\n        assert_eq!(q.lr.x, 10.0);\n        assert_eq!(q.lr.y, 20.0);\n    }\n\n    #[test]\n    fn test_quad_transform() {\n        let r = Rect::new(0.0, 0.0, 10.0, 10.0);\n        let q = Quad::from_rect(\u0026r);\n        let m = Matrix::translate(5.0, 5.0);\n        let transformed = q.transform(\u0026m);\n        assert_eq!(transformed.ul.x, 5.0);\n        assert_eq!(transformed.ul.y, 5.0);\n        assert_eq!(transformed.lr.x, 15.0);\n        assert_eq!(transformed.lr.y, 15.0);\n    }\n\n    #[test]\n    fn test_quad_default() {\n        let q: Quad = Default::default();\n        assert_eq!(q.ul, Point::default());\n        assert_eq!(q.ur, Point::default());\n        assert_eq!(q.ll, Point::default());\n        assert_eq!(q.lr, Point::default());\n    }\n}\n\n","traces":[{"line":10,"address":[1581312,1581324],"length":1,"stats":{"Line":3}},{"line":11,"address":[1581328],"length":1,"stats":{"Line":2}},{"line":13,"address":[1581356,1581338],"length":1,"stats":{"Line":2}},{"line":14,"address":[1581388,1581351],"length":1,"stats":{"Line":3}},{"line":27,"address":[1581424,1581451],"length":1,"stats":{"Line":2}},{"line":28,"address":[1581477,1581472],"length":1,"stats":{"Line":2}},{"line":29,"address":[1581493,1581488],"length":1,"stats":{"Line":2}},{"line":30,"address":[1581504,1581514],"length":1,"stats":{"Line":3}},{"line":31,"address":[1581568,1581573],"length":1,"stats":{"Line":3}},{"line":32,"address":[1581600],"length":1,"stats":{"Line":1}},{"line":33,"address":[1581634],"length":1,"stats":{"Line":1}},{"line":35,"address":[1581728],"length":1,"stats":{"Line":1}},{"line":37,"address":[1581762],"length":1,"stats":{"Line":1}},{"line":38,"address":[1581822],"length":1,"stats":{"Line":1}},{"line":41,"address":[1581920],"length":1,"stats":{"Line":1}},{"line":43,"address":[1581954],"length":1,"stats":{"Line":1}},{"line":44,"address":[1582014],"length":1,"stats":{"Line":1}},{"line":47,"address":[1582112],"length":1,"stats":{"Line":1}},{"line":48,"address":[1582165],"length":1,"stats":{"Line":1}},{"line":49,"address":[1582215],"length":1,"stats":{"Line":1}},{"line":57,"address":[1582292,1582272],"length":1,"stats":{"Line":3}},{"line":58,"address":[1582320,1582329],"length":1,"stats":{"Line":2}},{"line":59,"address":[1582377,1582368],"length":1,"stats":{"Line":2}},{"line":60,"address":[1582416,1582426],"length":1,"stats":{"Line":2}},{"line":64,"address":[1582480],"length":1,"stats":{"Line":1}},{"line":65,"address":[1582498,1582712],"length":1,"stats":{"Line":2}},{"line":66,"address":[1582595],"length":1,"stats":{"Line":1}},{"line":74,"address":[1582739,1582736],"length":1,"stats":{"Line":2}},{"line":80,"address":[1582823,1582784],"length":1,"stats":{"Line":2}},{"line":81,"address":[1582879,1582864],"length":1,"stats":{"Line":2}},{"line":82,"address":[1582944,1582959],"length":1,"stats":{"Line":2}},{"line":83,"address":[1583008],"length":1,"stats":{"Line":1}},{"line":84,"address":[1583028],"length":1,"stats":{"Line":1}},{"line":85,"address":[1583063],"length":1,"stats":{"Line":1}},{"line":86,"address":[1583115],"length":1,"stats":{"Line":1}},{"line":88,"address":[1583184],"length":1,"stats":{"Line":1}},{"line":90,"address":[1583197],"length":1,"stats":{"Line":1}},{"line":91,"address":[1583219],"length":1,"stats":{"Line":1}},{"line":92,"address":[1583242],"length":1,"stats":{"Line":1}},{"line":93,"address":[1583265],"length":1,"stats":{"Line":1}},{"line":94,"address":[1583289],"length":1,"stats":{"Line":1}},{"line":95,"address":[1583317],"length":1,"stats":{"Line":1}},{"line":104,"address":[1583376],"length":1,"stats":{"Line":1}},{"line":106,"address":[1583399],"length":1,"stats":{"Line":1}},{"line":107,"address":[1583460],"length":1,"stats":{"Line":1}},{"line":110,"address":[1583600],"length":1,"stats":{"Line":1}},{"line":112,"address":[1583648],"length":1,"stats":{"Line":1}},{"line":113,"address":[1583704],"length":1,"stats":{"Line":1}}],"covered":48,"coverable":48},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","image.rs"],"content":"//! Image handling\nuse crate::fitz::colorspace::Colorspace;\nuse crate::fitz::pixmap::Pixmap;\n\npub struct Image { width: i32, height: i32, pixmap: Option\u003cPixmap\u003e }\n\nimpl Image {\n    pub fn new(width: i32, height: i32, pixmap: Option\u003cPixmap\u003e) -\u003e Self {\n        Self { width, height, pixmap }\n    }\n    pub fn width(\u0026self) -\u003e i32 { self.width }\n    pub fn height(\u0026self) -\u003e i32 { self.height }\n    pub fn pixmap(\u0026self) -\u003e Option\u003c\u0026Pixmap\u003e { self.pixmap.as_ref() }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_image_new_without_pixmap() {\n        let img = Image::new(100, 50, None);\n        assert_eq!(img.width(), 100);\n        assert_eq!(img.height(), 50);\n        assert!(img.pixmap().is_none());\n    }\n\n    #[test]\n    fn test_image_new_with_pixmap() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, false).unwrap();\n        let img = Image::new(100, 50, Some(pm));\n\n        assert_eq!(img.width(), 100);\n        assert_eq!(img.height(), 50);\n        assert!(img.pixmap().is_some());\n\n        let pm_ref = img.pixmap().unwrap();\n        assert_eq!(pm_ref.width(), 100);\n        assert_eq!(pm_ref.height(), 50);\n    }\n\n    #[test]\n    fn test_image_dimensions() {\n        let img = Image::new(1920, 1080, None);\n        assert_eq!(img.width(), 1920);\n        assert_eq!(img.height(), 1080);\n    }\n}\n\n","traces":[{"line":8,"address":[1893712],"length":1,"stats":{"Line":1}},{"line":11,"address":[1893744,1893749],"length":1,"stats":{"Line":4}},{"line":12,"address":[1893765,1893760],"length":1,"stats":{"Line":4}},{"line":13,"address":[1893776,1893781],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","mod.rs"],"content":"//! Fitz - Core rendering and document infrastructure\n//!\n//! This module provides foundational types for document handling,\n//! geometry, rendering, and I/O operations.\n\npub mod error;\npub mod geometry;\npub mod buffer;\npub mod stream;\npub mod colorspace;\npub mod pixmap;\npub mod font;\npub mod path;\npub mod text;\npub mod image;\npub mod device;\npub mod document;\npub mod page;\n\n#[cfg(feature = \"parallel\")]\npub mod parallel;\n\n#[cfg(feature = \"async\")]\npub mod async_io;\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","page.rs"],"content":"//! Page abstraction\nuse crate::fitz::geometry::Rect;\n\npub trait Page {\n    fn bounds(\u0026self) -\u003e Rect;\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","parallel.rs"],"content":"//! Parallel processing utilities using Rayon\n//!\n//! This module provides utilities for parallel processing of PDF operations,\n//! enabling significant performance improvements on multi-core systems.\n\nuse rayon::prelude::*;\nuse std::path::Path;\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::Result;\nuse crate::fitz::pixmap::Pixmap;\nuse crate::fitz::stream::Stream;\n\n/// Process multiple buffers in parallel using a custom function.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::parallel::process_buffers;\n/// use micropdf::fitz::buffer::Buffer;\n///\n/// let buffers = vec![Buffer::from_slice(b\"data1\"), Buffer::from_slice(b\"data2\")];\n/// let results: Vec\u003cusize\u003e = process_buffers(\u0026buffers, |b| b.len());\n/// ```\npub fn process_buffers\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cR\u003e\nwhere\n    F: Fn(\u0026Buffer) -\u003e R + Sync + Send,\n    R: Send,\n{\n    buffers.par_iter().map(f).collect()\n}\n\n/// Process multiple buffers with results in parallel.\npub fn process_buffers_result\u003cF, R\u003e(buffers: \u0026[Buffer], f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\nwhere\n    F: Fn(\u0026Buffer) -\u003e Result\u003cR\u003e + Sync + Send,\n    R: Send,\n{\n    buffers.par_iter().map(f).collect()\n}\n\n/// Transform buffer data in parallel chunks.\n///\n/// Splits the buffer into chunks and applies the transformation function\n/// to each chunk in parallel, then reassembles the results.\npub fn parallel_transform\u003cF\u003e(buffer: \u0026Buffer, chunk_size: usize, f: F) -\u003e Buffer\nwhere\n    F: Fn(\u0026[u8]) -\u003e Vec\u003cu8\u003e + Sync + Send,\n{\n    let data = buffer.to_vec();\n    let chunks: Vec\u003cVec\u003cu8\u003e\u003e = data\n        .par_chunks(chunk_size)\n        .map(f)\n        .collect();\n\n    let total_len: usize = chunks.iter().map(|c| c.len()).sum();\n    let mut result = Vec::with_capacity(total_len);\n    for chunk in chunks {\n        result.extend(chunk);\n    }\n    Buffer::from_data(result)\n}\n\n/// Read multiple files in parallel.\n///\n/// # Example\n/// ```ignore\n/// use micropdf::fitz::parallel::read_files;\n///\n/// let paths = vec![\"file1.pdf\", \"file2.pdf\", \"file3.pdf\"];\n/// let results = read_files(\u0026paths);\n/// ```\npub fn read_files\u003cP: AsRef\u003cPath\u003e + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n    paths\n        .par_iter()\n        .map(|path| {\n            let mut stream = Stream::open_file(path)?;\n            stream.read_all(0)\n        })\n        .collect()\n}\n\n/// Process multiple pixmaps in parallel.\npub fn process_pixmaps\u003cF, R\u003e(pixmaps: \u0026[Pixmap], f: F) -\u003e Vec\u003cR\u003e\nwhere\n    F: Fn(\u0026Pixmap) -\u003e R + Sync + Send,\n    R: Send,\n{\n    pixmaps.par_iter().map(f).collect()\n}\n\n/// Apply a pixel transformation to multiple pixmaps in parallel.\npub fn transform_pixmaps\u003cF\u003e(pixmaps: Vec\u003cPixmap\u003e, f: F) -\u003e Vec\u003cPixmap\u003e\nwhere\n    F: Fn(Pixmap) -\u003e Pixmap + Sync + Send,\n{\n    pixmaps.into_par_iter().map(f).collect()\n}\n\n/// Batch process items with a parallel iterator.\npub fn batch_process\u003cT, F, R\u003e(items: Vec\u003cT\u003e, f: F) -\u003e Vec\u003cR\u003e\nwhere\n    T: Send,\n    F: Fn(T) -\u003e R + Sync + Send,\n    R: Send,\n{\n    items.into_par_iter().map(f).collect()\n}\n\n/// Batch process items with results.\npub fn batch_process_result\u003cT, F, R\u003e(items: Vec\u003cT\u003e, f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\nwhere\n    T: Send,\n    F: Fn(T) -\u003e Result\u003cR\u003e + Sync + Send,\n    R: Send,\n{\n    items.into_par_iter().map(f).collect()\n}\n\n/// Filter items in parallel.\npub fn parallel_filter\u003cT, F\u003e(items: Vec\u003cT\u003e, predicate: F) -\u003e Vec\u003cT\u003e\nwhere\n    T: Send,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.into_par_iter().filter(predicate).collect()\n}\n\n/// Find items in parallel that match a predicate.\npub fn parallel_find\u003cT, F\u003e(items: \u0026[T], predicate: F) -\u003e Option\u003c\u0026T\u003e\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.par_iter().find_any(|item| predicate(item))\n}\n\n/// Count items matching a predicate in parallel.\npub fn parallel_count\u003cT, F\u003e(items: \u0026[T], predicate: F) -\u003e usize\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e bool + Sync + Send,\n{\n    items.par_iter().filter(|item| predicate(*item)).count()\n}\n\n/// Sum values extracted from items in parallel.\npub fn parallel_sum\u003cT, F\u003e(items: \u0026[T], f: F) -\u003e i64\nwhere\n    T: Sync,\n    F: Fn(\u0026T) -\u003e i64 + Sync + Send,\n{\n    items.par_iter().map(f).sum()\n}\n\n/// Get the number of available parallel threads.\npub fn num_threads() -\u003e usize {\n    rayon::current_num_threads()\n}\n\n/// Execute work with a specific thread pool size.\npub fn with_thread_count\u003cF, R\u003e(num_threads: usize, f: F) -\u003e R\nwhere\n    F: FnOnce() -\u003e R + Send,\n    R: Send,\n{\n    let pool = rayon::ThreadPoolBuilder::new()\n        .num_threads(num_threads)\n        .build()\n        .expect(\"Failed to create thread pool\");\n    pool.install(f)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_process_buffers() {\n        let buffers = vec![\n            Buffer::from_slice(\u0026[1, 2, 3]),\n            Buffer::from_slice(\u0026[4, 5]),\n            Buffer::from_slice(\u0026[6, 7, 8, 9]),\n        ];\n\n        let lengths: Vec\u003cusize\u003e = process_buffers(\u0026buffers, |b| b.len());\n        assert_eq!(lengths, vec![3, 2, 4]);\n    }\n\n    #[test]\n    fn test_parallel_transform() {\n        let buffer = Buffer::from_slice(\u0026[1, 2, 3, 4, 5, 6, 7, 8]);\n\n        let result = parallel_transform(\u0026buffer, 2, |chunk| {\n            chunk.iter().map(|b| b * 2).collect()\n        });\n\n        assert_eq!(result.to_vec(), vec![2, 4, 6, 8, 10, 12, 14, 16]);\n    }\n\n    #[test]\n    fn test_batch_process() {\n        let items = vec![1, 2, 3, 4, 5];\n        let results: Vec\u003ci32\u003e = batch_process(items, |x| x * x);\n        assert_eq!(results, vec![1, 4, 9, 16, 25]);\n    }\n\n    #[test]\n    fn test_parallel_filter() {\n        let items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let evens = parallel_filter(items, |x| x % 2 == 0);\n        assert_eq!(evens, vec![2, 4, 6, 8, 10]);\n    }\n\n    #[test]\n    fn test_parallel_count() {\n        let items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let count = parallel_count(\u0026items, |x| *x \u003e 5);\n        assert_eq!(count, 5);\n    }\n\n    #[test]\n    fn test_parallel_sum() {\n        let items = vec![1i64, 2, 3, 4, 5];\n        let sum = parallel_sum(\u0026items, |x| *x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_num_threads() {\n        let threads = num_threads();\n        assert!(threads \u003e 0);\n    }\n\n    #[test]\n    fn test_with_thread_count() {\n        let result = with_thread_count(2, || {\n            assert!(rayon::current_num_threads() \u003c= 2);\n            42\n        });\n        assert_eq!(result, 42);\n    }\n}\n\n","traces":[{"line":24,"address":[1373152,1373318],"length":1,"stats":{"Line":1}},{"line":29,"address":[1373202,1373264],"length":1,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[1374278,1374324,1373344],"length":1,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[1373638,1374352,1374377,1373706],"length":1,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[1374508,1374400],"length":1,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[1374528,1374636],"length":1,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[1374687,1374656],"length":1,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[1374800,1374928],"length":1,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[1983024],"length":1,"stats":{"Line":1}},{"line":157,"address":[1983025],"length":1,"stats":{"Line":1}},{"line":161,"address":[1375235,1374944,1375229],"length":1,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":1}}],"covered":24,"coverable":36},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","path.rs"],"content":"//! Vector paths\nuse crate::fitz::geometry::{Point, Rect};\n\npub struct Path { elements: Vec\u003cPathElement\u003e }\npub enum PathElement { MoveTo(Point), LineTo(Point), CurveTo(Point, Point, Point), Close }\n\nimpl Path {\n    pub fn new() -\u003e Self { Self { elements: Vec::new() } }\n    pub fn move_to(\u0026mut self, p: Point) { self.elements.push(PathElement::MoveTo(p)); }\n    pub fn line_to(\u0026mut self, p: Point) { self.elements.push(PathElement::LineTo(p)); }\n    pub fn curve_to(\u0026mut self, p1: Point, p2: Point, p3: Point) {\n        self.elements.push(PathElement::CurveTo(p1, p2, p3));\n    }\n    pub fn close(\u0026mut self) { self.elements.push(PathElement::Close); }\n    pub fn bounds(\u0026self) -\u003e Rect {\n        let mut bbox = Rect::EMPTY;\n        for el in \u0026self.elements {\n            match el {\n                PathElement::MoveTo(p) | PathElement::LineTo(p) =\u003e bbox.include_point(*p),\n                PathElement::CurveTo(p1, p2, p3) =\u003e {\n                    bbox.include_point(*p1); bbox.include_point(*p2); bbox.include_point(*p3);\n                }\n                PathElement::Close =\u003e {}\n            }\n        }\n        bbox\n    }\n    pub fn len(\u0026self) -\u003e usize { self.elements.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.elements.is_empty() }\n}\nimpl Default for Path { fn default() -\u003e Self { Self::new() } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_path_new() {\n        let path = Path::new();\n        assert!(path.is_empty());\n        assert_eq!(path.len(), 0);\n    }\n\n    #[test]\n    fn test_path_default() {\n        let path: Path = Default::default();\n        assert!(path.is_empty());\n    }\n\n    #[test]\n    fn test_path_move_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(10.0, 20.0));\n        assert_eq!(path.len(), 1);\n        assert!(!path.is_empty());\n    }\n\n    #[test]\n    fn test_path_line_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        assert_eq!(path.len(), 2);\n    }\n\n    #[test]\n    fn test_path_curve_to() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.curve_to(\n            Point::new(5.0, 10.0),\n            Point::new(15.0, 10.0),\n            Point::new(20.0, 0.0),\n        );\n        assert_eq!(path.len(), 2);\n    }\n\n    #[test]\n    fn test_path_close() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        path.close();\n        assert_eq!(path.len(), 4);\n    }\n\n    #[test]\n    fn test_path_bounds_simple() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(100.0, 50.0));\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 100.0);\n        assert_eq!(bounds.y1, 50.0);\n    }\n\n    #[test]\n    fn test_path_bounds_with_curve() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.curve_to(\n            Point::new(50.0, 100.0),\n            Point::new(100.0, 100.0),\n            Point::new(150.0, 0.0),\n        );\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 150.0);\n        assert_eq!(bounds.y1, 100.0);\n    }\n\n    #[test]\n    fn test_path_bounds_empty() {\n        let path = Path::new();\n        let bounds = path.bounds();\n        assert!(bounds.is_empty());\n    }\n\n    #[test]\n    fn test_path_bounds_with_close() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(10.0, 10.0));\n        path.close();\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.x0, 0.0);\n        assert_eq!(bounds.y0, 0.0);\n        assert_eq!(bounds.x1, 10.0);\n        assert_eq!(bounds.y1, 10.0);\n    }\n\n    #[test]\n    fn test_path_rectangle() {\n        let mut path = Path::new();\n        path.move_to(Point::new(0.0, 0.0));\n        path.line_to(Point::new(100.0, 0.0));\n        path.line_to(Point::new(100.0, 50.0));\n        path.line_to(Point::new(0.0, 50.0));\n        path.close();\n\n        let bounds = path.bounds();\n        assert_eq!(bounds.width(), 100.0);\n        assert_eq!(bounds.height(), 50.0);\n    }\n}\n\n","traces":[{"line":8,"address":[1601037,1601024],"length":1,"stats":{"Line":2}},{"line":9,"address":[1601088,1601109],"length":1,"stats":{"Line":5}},{"line":10,"address":[1601173,1601152],"length":1,"stats":{"Line":5}},{"line":11,"address":[1601216],"length":1,"stats":{"Line":1}},{"line":12,"address":[1601261],"length":1,"stats":{"Line":1}},{"line":14,"address":[1601328,1601337],"length":1,"stats":{"Line":3}},{"line":15,"address":[1601376],"length":1,"stats":{"Line":1}},{"line":16,"address":[1601411],"length":1,"stats":{"Line":1}},{"line":17,"address":[1601450,1601435],"length":1,"stats":{"Line":3}},{"line":18,"address":[1601606,1601508,1601587],"length":1,"stats":{"Line":4}},{"line":19,"address":[1601578,1601597,1601727],"length":1,"stats":{"Line":3}},{"line":20,"address":[1601613],"length":1,"stats":{"Line":1}},{"line":21,"address":[1601652],"length":1,"stats":{"Line":1}},{"line":26,"address":[1601546],"length":1,"stats":{"Line":1}},{"line":28,"address":[1601765,1601760],"length":1,"stats":{"Line":2}},{"line":29,"address":[1601776,1601781],"length":1,"stats":{"Line":3}},{"line":31,"address":[1601792,1601800],"length":1,"stats":{"Line":2}}],"covered":17,"coverable":17},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","pixmap.rs"],"content":"//! Pixmap - Pixel buffer for rendering\n\nuse crate::fitz::colorspace::Colorspace;\nuse crate::fitz::error::{Error, Result};\nuse crate::fitz::geometry::IRect;\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct Pixmap { inner: Arc\u003cPixmapInner\u003e }\n\n#[derive(Clone)]\nstruct PixmapInner {\n    x: i32, y: i32, w: i32, h: i32, n: u8, alpha: u8,\n    stride: usize, colorspace: Option\u003cColorspace\u003e, samples: Vec\u003cu8\u003e,\n}\n\nimpl Pixmap {\n    pub fn new(colorspace: Option\u003cColorspace\u003e, w: i32, h: i32, alpha: bool) -\u003e Result\u003cSelf\u003e {\n        if w \u003c= 0 || h \u003c= 0 { return Err(Error::argument(\"Invalid dimensions\")); }\n        let n = match \u0026colorspace {\n            Some(cs) =\u003e cs.n() + if alpha { 1 } else { 0 },\n            None if alpha =\u003e 1,\n            None =\u003e return Err(Error::argument(\"Pixmap must have colorspace or alpha\")),\n        };\n        let stride = (w as usize) * (n as usize);\n        Ok(Self { inner: Arc::new(PixmapInner {\n            x: 0, y: 0, w, h, n, alpha: if alpha { 1 } else { 0 },\n            stride, colorspace, samples: vec![0; stride * (h as usize)],\n        }) })\n    }\n    pub fn width(\u0026self) -\u003e i32 { self.inner.w }\n    pub fn height(\u0026self) -\u003e i32 { self.inner.h }\n    pub fn n(\u0026self) -\u003e u8 { self.inner.n }\n    pub fn has_alpha(\u0026self) -\u003e bool { self.inner.alpha \u003e 0 }\n    pub fn stride(\u0026self) -\u003e usize { self.inner.stride }\n    pub fn colorspace(\u0026self) -\u003e Option\u003c\u0026Colorspace\u003e { self.inner.colorspace.as_ref() }\n    pub fn samples(\u0026self) -\u003e \u0026[u8] { \u0026self.inner.samples }\n    pub fn samples_mut(\u0026mut self) -\u003e \u0026mut [u8] { \u0026mut Arc::make_mut(\u0026mut self.inner).samples }\n    pub fn clear(\u0026mut self, value: u8) {\n        let inner = Arc::make_mut(\u0026mut self.inner);\n        inner.samples.fill(value);\n    }\n    pub fn get_pixel(\u0026self, x: i32, y: i32) -\u003e Option\u003c\u0026[u8]\u003e {\n        if x \u003c 0 || x \u003e= self.inner.w || y \u003c 0 || y \u003e= self.inner.h { return None; }\n        let offset = (y as usize) * self.inner.stride + (x as usize) * (self.inner.n as usize);\n        Some(\u0026self.inner.samples[offset..offset + self.inner.n as usize])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pixmap_new_rgb() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, false).unwrap();\n        assert_eq!(pm.width(), 100);\n        assert_eq!(pm.height(), 50);\n        assert_eq!(pm.n(), 3); // RGB\n        assert!(!pm.has_alpha());\n        assert_eq!(pm.stride(), 300); // 100 * 3\n    }\n\n    #[test]\n    fn test_pixmap_new_rgb_with_alpha() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 100, 50, true).unwrap();\n        assert_eq!(pm.n(), 4); // RGBA\n        assert!(pm.has_alpha());\n        assert_eq!(pm.stride(), 400); // 100 * 4\n    }\n\n    #[test]\n    fn test_pixmap_new_gray() {\n        let cs = Colorspace::device_gray();\n        let pm = Pixmap::new(Some(cs), 100, 100, false).unwrap();\n        assert_eq!(pm.n(), 1);\n        assert!(!pm.has_alpha());\n    }\n\n    #[test]\n    fn test_pixmap_new_cmyk() {\n        let cs = Colorspace::device_cmyk();\n        let pm = Pixmap::new(Some(cs), 50, 50, false).unwrap();\n        assert_eq!(pm.n(), 4);\n    }\n\n    #[test]\n    fn test_pixmap_new_alpha_only() {\n        let pm = Pixmap::new(None, 100, 100, true).unwrap();\n        assert_eq!(pm.n(), 1);\n        assert!(pm.has_alpha());\n        assert!(pm.colorspace().is_none());\n    }\n\n    #[test]\n    fn test_pixmap_new_invalid_dimensions() {\n        let cs = Colorspace::device_rgb();\n        assert!(Pixmap::new(Some(cs.clone()), 0, 100, false).is_err());\n        assert!(Pixmap::new(Some(cs.clone()), 100, 0, false).is_err());\n        assert!(Pixmap::new(Some(cs), -1, 100, false).is_err());\n    }\n\n    #[test]\n    fn test_pixmap_new_no_colorspace_no_alpha() {\n        // Must have either colorspace or alpha\n        assert!(Pixmap::new(None, 100, 100, false).is_err());\n    }\n\n    #[test]\n    fn test_pixmap_samples() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let samples = pm.samples();\n        assert_eq!(samples.len(), 10 * 10 * 3);\n        // Should be initialized to 0\n        assert!(samples.iter().all(|\u0026b| b == 0));\n    }\n\n    #[test]\n    fn test_pixmap_samples_mut() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let samples = pm.samples_mut();\n        samples[0] = 255;\n        samples[1] = 128;\n        samples[2] = 64;\n\n        let samples_read = pm.samples();\n        assert_eq!(samples_read[0], 255);\n        assert_eq!(samples_read[1], 128);\n        assert_eq!(samples_read[2], 64);\n    }\n\n    #[test]\n    fn test_pixmap_clear() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        pm.clear(128);\n\n        assert!(pm.samples().iter().all(|\u0026b| b == 128));\n    }\n\n    #[test]\n    fn test_pixmap_get_pixel() {\n        let cs = Colorspace::device_rgb();\n        let mut pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        // Set pixel at (2, 3)\n        let offset = 3 * 30 + 2 * 3; // y * stride + x * n\n        pm.samples_mut()[offset] = 255;\n        pm.samples_mut()[offset + 1] = 128;\n        pm.samples_mut()[offset + 2] = 64;\n\n        let pixel = pm.get_pixel(2, 3).unwrap();\n        assert_eq!(pixel, \u0026[255, 128, 64]);\n    }\n\n    #[test]\n    fn test_pixmap_get_pixel_out_of_bounds() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        assert!(pm.get_pixel(-1, 0).is_none());\n        assert!(pm.get_pixel(0, -1).is_none());\n        assert!(pm.get_pixel(10, 0).is_none());\n        assert!(pm.get_pixel(0, 10).is_none());\n    }\n\n    #[test]\n    fn test_pixmap_colorspace() {\n        let cs = Colorspace::device_rgb();\n        let pm = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n\n        let cs_ref = pm.colorspace().unwrap();\n        assert_eq!(cs_ref.name(), \"DeviceRGB\");\n    }\n\n    #[test]\n    fn test_pixmap_clone() {\n        let cs = Colorspace::device_rgb();\n        let pm1 = Pixmap::new(Some(cs), 10, 10, false).unwrap();\n        let pm2 = pm1.clone();\n\n        assert_eq!(pm1.width(), pm2.width());\n        assert_eq!(pm1.height(), pm2.height());\n        assert_eq!(pm1.n(), pm2.n());\n    }\n}\n\n","traces":[{"line":18,"address":[2497388,2497439,2496512],"length":1,"stats":{"Line":1}},{"line":19,"address":[1748876,1749724],"length":1,"stats":{"Line":2}},{"line":20,"address":[1748942],"length":1,"stats":{"Line":1}},{"line":21,"address":[1748979,1749192],"length":1,"stats":{"Line":2}},{"line":22,"address":[1749046,1749009],"length":1,"stats":{"Line":3}},{"line":23,"address":[1749099,1749015],"length":1,"stats":{"Line":2}},{"line":25,"address":[1749268,1749166,1749290],"length":1,"stats":{"Line":2}},{"line":26,"address":[1749526],"length":1,"stats":{"Line":1}},{"line":27,"address":[1749308,1749276],"length":1,"stats":{"Line":2}},{"line":28,"address":[1749340],"length":1,"stats":{"Line":1}},{"line":31,"address":[1749808,1749813],"length":1,"stats":{"Line":2}},{"line":32,"address":[1749824,1749829],"length":1,"stats":{"Line":2}},{"line":33,"address":[2497504,2497509],"length":1,"stats":{"Line":2}},{"line":34,"address":[1749861,1749856],"length":1,"stats":{"Line":3}},{"line":35,"address":[1749893,1749888],"length":1,"stats":{"Line":2}},{"line":36,"address":[1749920,1749925],"length":1,"stats":{"Line":2}},{"line":37,"address":[1749957,1749952],"length":1,"stats":{"Line":2}},{"line":38,"address":[1749989,1749984],"length":1,"stats":{"Line":2}},{"line":39,"address":[2497664],"length":1,"stats":{"Line":1}},{"line":40,"address":[1750036],"length":1,"stats":{"Line":1}},{"line":41,"address":[1750050],"length":1,"stats":{"Line":1}},{"line":43,"address":[1750080],"length":1,"stats":{"Line":1}},{"line":44,"address":[1750156,1750110],"length":1,"stats":{"Line":2}},{"line":45,"address":[1750392,1750193],"length":1,"stats":{"Line":1}},{"line":46,"address":[1750445,1750343,1750420],"length":1,"stats":{"Line":2}}],"covered":25,"coverable":25},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","stream.rs"],"content":"//! Stream - Buffered I/O abstraction using the `bytes` crate\n//!\n//! This module provides high-performance stream implementations for reading\n//! PDF data from files, memory, and other sources.\n\nuse crate::fitz::buffer::Buffer;\nuse crate::fitz::error::{Error, Result};\nuse bytes::{Buf, Bytes, BytesMut};\nuse std::fs::File;\nuse std::io::{self, BufReader, Read, Seek, SeekFrom};\nuse std::path::Path;\nuse std::sync::Arc;\n\n/// A buffered stream for reading PDF data.\npub struct Stream {\n    inner: Box\u003cdyn StreamSource\u003e,\n    buffer: BytesMut,\n    rp: usize,\n    wp: usize,\n    pos: i64,\n    eof: bool,\n    error: bool,\n    bits: u32,\n    avail: u8,\n    filename: Option\u003cString\u003e,\n}\n\n/// Trait for stream data sources.\npub trait StreamSource: Send + Sync {\n    /// Read data into the buffer.\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e;\n    /// Seek to a position.\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e;\n    /// Get current position.\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e;\n    /// Get total length if known.\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e;\n}\n\n/// File-based stream source.\nstruct FileSource {\n    reader: BufReader\u003cFile\u003e,\n    len: u64,\n}\n\nimpl StreamSource for FileSource {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.reader.read(buf)\n    }\n\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e {\n        self.reader.seek(pos)\n    }\n\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e {\n        self.reader.stream_position()\n    }\n\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        Some(self.len)\n    }\n}\n\n/// Memory-based stream source using `bytes::Bytes`.\nstruct MemorySource {\n    data: Bytes,\n    position: usize,\n}\n\nimpl StreamSource for MemorySource {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        let remaining = \u0026self.data[self.position..];\n        let to_read = buf.len().min(remaining.len());\n        buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n        self.position += to_read;\n        Ok(to_read)\n    }\n\n    fn seek(\u0026mut self, pos: SeekFrom) -\u003e io::Result\u003cu64\u003e {\n        let new_pos = match pos {\n            SeekFrom::Start(offset) =\u003e offset as i64,\n            SeekFrom::End(offset) =\u003e self.data.len() as i64 + offset,\n            SeekFrom::Current(offset) =\u003e self.position as i64 + offset,\n        };\n        if new_pos \u003c 0 {\n            return Err(io::Error::new(io::ErrorKind::InvalidInput, \"Seek before start\"));\n        }\n        self.position = (new_pos as usize).min(self.data.len());\n        Ok(self.position as u64)\n    }\n\n    fn tell(\u0026mut self) -\u003e io::Result\u003cu64\u003e {\n        Ok(self.position as u64)\n    }\n\n    fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        Some(self.data.len() as u64)\n    }\n}\n\nconst STREAM_BUFFER_SIZE: usize = 8192;\n\nimpl Stream {\n    /// Open a stream from a file path.\n    pub fn open_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        let file = File::open(path).map_err(Error::System)?;\n        let len = file.metadata().map_err(Error::System)?.len();\n        Ok(Self {\n            inner: Box::new(FileSource {\n                reader: BufReader::with_capacity(STREAM_BUFFER_SIZE, file),\n                len,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: Some(path.to_string_lossy().into_owned()),\n        })\n    }\n\n    /// Open a stream from a byte slice.\n    pub fn open_memory(data: \u0026[u8]) -\u003e Self {\n        Self {\n            inner: Box::new(MemorySource {\n                data: Bytes::copy_from_slice(data),\n                position: 0,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: None,\n        }\n    }\n\n    /// Open a stream from a `Bytes` instance (zero-copy).\n    pub fn open_bytes(data: Bytes) -\u003e Self {\n        Self {\n            inner: Box::new(MemorySource {\n                data,\n                position: 0,\n            }),\n            buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n            rp: 0,\n            wp: 0,\n            pos: 0,\n            eof: false,\n            error: false,\n            bits: 0,\n            avail: 0,\n            filename: None,\n        }\n    }\n\n    /// Open a stream from a Buffer.\n    pub fn open_buffer(buffer: \u0026Buffer) -\u003e Self {\n        Self::open_bytes(buffer.to_bytes())\n    }\n\n    /// Get the current read position.\n    pub fn tell(\u0026self) -\u003e i64 {\n        self.pos - (self.wp - self.rp) as i64\n    }\n\n    /// Get the total length of the stream if known.\n    pub fn len(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.inner.len()\n    }\n\n    /// Check if the stream is empty.\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.inner.len() == Some(0)\n    }\n\n    /// Check if we've reached EOF.\n    pub fn is_eof(\u0026self) -\u003e bool {\n        self.eof \u0026\u0026 self.rp \u003e= self.wp\n    }\n\n    /// Get the filename if this is a file stream.\n    pub fn filename(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.filename.as_deref()\n    }\n\n    /// Fill the internal buffer.\n    fn fill_buffer(\u0026mut self) -\u003e Result\u003cusize\u003e {\n        if self.eof {\n            return Ok(0);\n        }\n\n        // Compact the buffer\n        if self.rp \u003e 0 {\n            if self.rp \u003c self.wp {\n                // Move remaining data to the start\n                let remaining = self.wp - self.rp;\n                self.buffer.copy_within(self.rp..self.wp, 0);\n                self.buffer.truncate(remaining);\n                self.wp = remaining;\n            } else {\n                self.buffer.clear();\n                self.wp = 0;\n            }\n            self.rp = 0;\n        }\n\n        // Ensure buffer has space\n        if self.buffer.len() \u003c STREAM_BUFFER_SIZE {\n            self.buffer.resize(STREAM_BUFFER_SIZE, 0);\n        }\n\n        // Read more data\n        match self.inner.read(\u0026mut self.buffer[self.wp..]) {\n            Ok(0) =\u003e {\n                self.eof = true;\n                Ok(0)\n            }\n            Ok(n) =\u003e {\n                self.wp += n;\n                self.pos += n as i64;\n                Ok(n)\n            }\n            Err(e) =\u003e {\n                self.error = true;\n                Err(Error::System(e))\n            }\n        }\n    }\n\n    /// Read a single byte.\n    pub fn read_byte(\u0026mut self) -\u003e Result\u003cOption\u003cu8\u003e\u003e {\n        if self.rp \u003e= self.wp \u0026\u0026 self.fill_buffer()? == 0 {\n            return Ok(None);\n        }\n        let byte = self.buffer[self.rp];\n        self.rp += 1;\n        Ok(Some(byte))\n    }\n\n    /// Peek at the next byte without consuming it.\n    pub fn peek_byte(\u0026mut self) -\u003e Result\u003cOption\u003cu8\u003e\u003e {\n        if self.rp \u003e= self.wp \u0026\u0026 self.fill_buffer()? == 0 {\n            return Ok(None);\n        }\n        Ok(Some(self.buffer[self.rp]))\n    }\n\n    /// Read bytes into a buffer.\n    pub fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize\u003e {\n        let mut total = 0;\n        while total \u003c buf.len() {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                let to_copy = buffered.min(buf.len() - total);\n                buf[total..total + to_copy].copy_from_slice(\u0026self.buffer[self.rp..self.rp + to_copy]);\n                self.rp += to_copy;\n                total += to_copy;\n            } else if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(total)\n    }\n\n    /// Read exactly the specified number of bytes.\n    pub fn read_exact(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003c()\u003e {\n        if self.read(buf)? \u003c buf.len() {\n            return Err(Error::Eof);\n        }\n        Ok(())\n    }\n\n    /// Read all remaining data into a Buffer.\n    pub fn read_all(\u0026mut self, initial_capacity: usize) -\u003e Result\u003cBuffer\u003e {\n        let mut result = BytesMut::with_capacity(initial_capacity);\n        loop {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                result.extend_from_slice(\u0026self.buffer[self.rp..self.wp]);\n                self.rp = self.wp;\n            }\n            if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(Buffer::from_bytes_mut(result))\n    }\n\n    /// Read a line (up to and including newline).\n    pub fn read_line(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e {\n        let mut line = Vec::new();\n        loop {\n            match self.read_byte()? {\n                None =\u003e {\n                    if line.is_empty() {\n                        return Ok(None);\n                    }\n                    break;\n                }\n                Some(b'\\n') =\u003e {\n                    line.push(b'\\n');\n                    break;\n                }\n                Some(b) =\u003e {\n                    line.push(b);\n                }\n            }\n        }\n        Ok(Some(line))\n    }\n\n    /// Skip n bytes.\n    pub fn skip(\u0026mut self, mut n: usize) -\u003e Result\u003cusize\u003e {\n        let mut skipped = 0;\n        while n \u003e 0 {\n            let buffered = self.wp - self.rp;\n            if buffered \u003e 0 {\n                let to_skip = buffered.min(n);\n                self.rp += to_skip;\n                skipped += to_skip;\n                n -= to_skip;\n            } else if self.fill_buffer()? == 0 {\n                break;\n            }\n        }\n        Ok(skipped)\n    }\n\n    /// Seek to a position in the stream.\n    pub fn seek(\u0026mut self, pos: i64, whence: i32) -\u003e Result\u003c()\u003e {\n        let seek_from = match whence {\n            0 =\u003e SeekFrom::Start(pos as u64),\n            1 =\u003e SeekFrom::Current(pos),\n            2 =\u003e SeekFrom::End(pos),\n            _ =\u003e return Err(Error::generic(\"Invalid seek whence\")),\n        };\n\n        // Clear buffer and seek\n        self.rp = 0;\n        self.wp = 0;\n        self.eof = false;\n        self.pos = self.inner.seek(seek_from).map_err(Error::System)? as i64;\n        Ok(())\n    }\n\n    /// Read a 16-bit unsigned integer in big-endian format.\n    pub fn read_uint16(\u0026mut self) -\u003e Result\u003cu16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u16::from_be_bytes(buf))\n    }\n\n    /// Read a 24-bit unsigned integer in big-endian format.\n    pub fn read_uint24(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 3];\n        self.read_exact(\u0026mut buf)?;\n        Ok(((buf[0] as u32) \u003c\u003c 16) | ((buf[1] as u32) \u003c\u003c 8) | (buf[2] as u32))\n    }\n\n    /// Read a 32-bit unsigned integer in big-endian format.\n    pub fn read_uint32(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u32::from_be_bytes(buf))\n    }\n\n    /// Read a 16-bit signed integer in little-endian format.\n    pub fn read_int16_le(\u0026mut self) -\u003e Result\u003ci16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(i16::from_le_bytes(buf))\n    }\n\n    /// Read a 32-bit signed integer in little-endian format.\n    pub fn read_int32_le(\u0026mut self) -\u003e Result\u003ci32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(i32::from_le_bytes(buf))\n    }\n\n    /// Read a 16-bit unsigned integer in little-endian format.\n    pub fn read_uint16_le(\u0026mut self) -\u003e Result\u003cu16\u003e {\n        let mut buf = [0u8; 2];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u16::from_le_bytes(buf))\n    }\n\n    /// Read a 32-bit unsigned integer in little-endian format.\n    pub fn read_uint32_le(\u0026mut self) -\u003e Result\u003cu32\u003e {\n        let mut buf = [0u8; 4];\n        self.read_exact(\u0026mut buf)?;\n        Ok(u32::from_le_bytes(buf))\n    }\n\n    /// Read bits from the stream.\n    pub fn read_bits(\u0026mut self, n: u8) -\u003e Result\u003cu32\u003e {\n        while self.avail \u003c n {\n            match self.read_byte()? {\n                Some(b) =\u003e {\n                    self.bits = (self.bits \u003c\u003c 8) | (b as u32);\n                    self.avail += 8;\n                }\n                None =\u003e return Err(Error::Eof),\n            }\n        }\n        self.avail -= n;\n        let mask = (1u32 \u003c\u003c n) - 1;\n        Ok((self.bits \u003e\u003e self.avail) \u0026 mask)\n    }\n\n    /// Sync bits - discard any partial byte.\n    pub fn sync_bits(\u0026mut self) {\n        self.bits = 0;\n        self.avail = 0;\n    }\n}\n\nimpl std::fmt::Debug for Stream {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Stream\")\n            .field(\"pos\", \u0026self.tell())\n            .field(\"eof\", \u0026self.eof)\n            .field(\"filename\", \u0026self.filename)\n            .finish()\n    }\n}\n\n// Async stream support (when async feature is enabled)\n#[cfg(feature = \"async\")]\npub mod async_stream {\n    use super::*;\n    use bytes::Bytes;\n    use tokio::fs::File as AsyncFile;\n    use tokio::io::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt, BufReader as AsyncBufReader};\n    use std::pin::Pin;\n    use std::task::{Context, Poll};\n\n    /// Async stream for non-blocking I/O.\n    pub struct AsyncStream {\n        inner: AsyncStreamInner,\n        buffer: BytesMut,\n        pos: u64,\n        eof: bool,\n    }\n\n    enum AsyncStreamInner {\n        File(AsyncBufReader\u003cAsyncFile\u003e),\n        Memory { data: Bytes, position: usize },\n    }\n\n    impl AsyncStream {\n        /// Open a file asynchronously.\n        pub async fn open_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e Result\u003cSelf\u003e {\n            let file = AsyncFile::open(path).await.map_err(Error::System)?;\n            Ok(Self {\n                inner: AsyncStreamInner::File(AsyncBufReader::with_capacity(STREAM_BUFFER_SIZE, file)),\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            })\n        }\n\n        /// Open from memory.\n        pub fn open_memory(data: \u0026[u8]) -\u003e Self {\n            Self {\n                inner: AsyncStreamInner::Memory {\n                    data: Bytes::copy_from_slice(data),\n                    position: 0,\n                },\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            }\n        }\n\n        /// Open from Bytes (zero-copy).\n        pub fn open_bytes(data: Bytes) -\u003e Self {\n            Self {\n                inner: AsyncStreamInner::Memory {\n                    data,\n                    position: 0,\n                },\n                buffer: BytesMut::with_capacity(STREAM_BUFFER_SIZE),\n                pos: 0,\n                eof: false,\n            }\n        }\n\n        /// Read bytes asynchronously.\n        pub async fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize\u003e {\n            match \u0026mut self.inner {\n                AsyncStreamInner::File(reader) =\u003e {\n                    let n = reader.read(buf).await.map_err(Error::System)?;\n                    self.pos += n as u64;\n                    if n == 0 {\n                        self.eof = true;\n                    }\n                    Ok(n)\n                }\n                AsyncStreamInner::Memory { data, position } =\u003e {\n                    let remaining = \u0026data[*position..];\n                    let to_read = buf.len().min(remaining.len());\n                    buf[..to_read].copy_from_slice(\u0026remaining[..to_read]);\n                    *position += to_read;\n                    self.pos += to_read as u64;\n                    if to_read == 0 {\n                        self.eof = true;\n                    }\n                    Ok(to_read)\n                }\n            }\n        }\n\n        /// Read all data asynchronously.\n        pub async fn read_all(\u0026mut self) -\u003e Result\u003cBuffer\u003e {\n            let mut result = BytesMut::with_capacity(8192);\n            let mut chunk = [0u8; 8192];\n            loop {\n                let n = self.read(\u0026mut chunk).await?;\n                if n == 0 {\n                    break;\n                }\n                result.extend_from_slice(\u0026chunk[..n]);\n            }\n            Ok(Buffer::from_bytes_mut(result))\n        }\n\n        /// Seek asynchronously.\n        pub async fn seek(\u0026mut self, pos: SeekFrom) -\u003e Result\u003cu64\u003e {\n            match \u0026mut self.inner {\n                AsyncStreamInner::File(reader) =\u003e {\n                    let new_pos = reader.seek(pos).await.map_err(Error::System)?;\n                    self.pos = new_pos;\n                    self.eof = false;\n                    Ok(new_pos)\n                }\n                AsyncStreamInner::Memory { data, position } =\u003e {\n                    let new_pos = match pos {\n                        SeekFrom::Start(offset) =\u003e offset as i64,\n                        SeekFrom::End(offset) =\u003e data.len() as i64 + offset,\n                        SeekFrom::Current(offset) =\u003e *position as i64 + offset,\n                    };\n                    if new_pos \u003c 0 {\n                        return Err(Error::generic(\"Seek before start\"));\n                    }\n                    *position = (new_pos as usize).min(data.len());\n                    self.pos = *position as u64;\n                    self.eof = false;\n                    Ok(self.pos)\n                }\n            }\n        }\n\n        /// Get current position.\n        pub fn tell(\u0026self) -\u003e u64 {\n            self.pos\n        }\n\n        /// Check if EOF.\n        pub fn is_eof(\u0026self) -\u003e bool {\n            self.eof\n        }\n    }\n}\n\n// Parallel stream processing (when parallel feature is enabled)\n#[cfg(feature = \"parallel\")]\npub mod parallel {\n    use super::*;\n    use rayon::prelude::*;\n\n    /// Process multiple streams in parallel.\n    pub fn process_streams\u003cF, R\u003e(streams: Vec\u003cStream\u003e, f: F) -\u003e Vec\u003cResult\u003cR\u003e\u003e\n    where\n        F: Fn(Stream) -\u003e Result\u003cR\u003e + Sync + Send,\n        R: Send,\n    {\n        streams.into_par_iter().map(f).collect()\n    }\n\n    /// Read multiple files in parallel.\n    pub fn read_files\u003cP: AsRef\u003cPath\u003e + Sync\u003e(paths: \u0026[P]) -\u003e Vec\u003cResult\u003cBuffer\u003e\u003e {\n        paths\n            .par_iter()\n            .map(|path| {\n                let mut stream = Stream::open_file(path)?;\n                stream.read_all(0)\n            })\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stream_open_memory() {\n        let data = b\"Hello World\";\n        let stream = Stream::open_memory(data);\n        assert_eq!(stream.tell(), 0);\n        assert_eq!(stream.len(), Some(data.len() as u64));\n        assert!(!stream.is_empty());\n    }\n\n    #[test]\n    fn test_stream_open_memory_empty() {\n        let stream = Stream::open_memory(\u0026[]);\n        assert!(stream.is_empty());\n        assert_eq!(stream.len(), Some(0));\n    }\n\n    #[test]\n    fn test_stream_open_buffer() {\n        let buffer = Buffer::from_slice(b\"Test Data\");\n        let stream = Stream::open_buffer(\u0026buffer);\n        assert_eq!(stream.len(), Some(9));\n    }\n\n    #[test]\n    fn test_stream_open_bytes() {\n        let bytes = Bytes::from_static(b\"Hello World\");\n        let stream = Stream::open_bytes(bytes);\n        assert_eq!(stream.len(), Some(11));\n    }\n\n    #[test]\n    fn test_stream_read_byte() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.read_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.read_byte().unwrap(), Some(b'B'));\n        assert_eq!(stream.read_byte().unwrap(), Some(b'C'));\n        assert_eq!(stream.read_byte().unwrap(), None);\n    }\n\n    #[test]\n    fn test_stream_peek_byte() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'A')); // Should not advance\n        assert_eq!(stream.read_byte().unwrap(), Some(b'A'));\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'B'));\n    }\n\n    #[test]\n    fn test_stream_read() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 5];\n\n        let n = stream.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 5);\n        assert_eq!(\u0026buf, b\"Hello\");\n    }\n\n    #[test]\n    fn test_stream_read_exact() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 5];\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"Hello\");\n    }\n\n    #[test]\n    fn test_stream_read_exact_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n        let mut buf = [0u8; 10];\n\n        let result = stream.read_exact(\u0026mut buf);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_stream_read_all() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.as_slice(), data);\n    }\n\n    #[test]\n    fn test_stream_read_line() {\n        let data = b\"Hello\\nWorld\\n\";\n        let mut stream = Stream::open_memory(data);\n\n        let line1 = stream.read_line().unwrap().unwrap();\n        assert_eq!(line1, b\"Hello\\n\");\n\n        let line2 = stream.read_line().unwrap().unwrap();\n        assert_eq!(line2, b\"World\\n\");\n\n        let line3 = stream.read_line().unwrap();\n        assert!(line3.is_none());\n    }\n\n    #[test]\n    fn test_stream_skip() {\n        let data = b\"Hello World\";\n        let mut stream = Stream::open_memory(data);\n\n        let skipped = stream.skip(6).unwrap();\n        assert_eq!(skipped, 6);\n\n        let mut buf = [0u8; 5];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"World\");\n    }\n\n    #[test]\n    fn test_stream_read_uint16() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint16().unwrap(), 0x0102);\n    }\n\n    #[test]\n    fn test_stream_read_uint24() {\n        let data = [0x01, 0x02, 0x03];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint24().unwrap(), 0x010203);\n    }\n\n    #[test]\n    fn test_stream_read_uint32() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint32().unwrap(), 0x01020304);\n    }\n\n    #[test]\n    fn test_stream_read_int16_le() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_int16_le().unwrap(), 0x0201);\n    }\n\n    #[test]\n    fn test_stream_read_int32_le() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_int32_le().unwrap(), 0x04030201);\n    }\n\n    #[test]\n    fn test_stream_read_uint16_le() {\n        let data = [0x01, 0x02];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint16_le().unwrap(), 0x0201);\n    }\n\n    #[test]\n    fn test_stream_read_uint32_le() {\n        let data = [0x01, 0x02, 0x03, 0x04];\n        let mut stream = Stream::open_memory(\u0026data);\n        assert_eq!(stream.read_uint32_le().unwrap(), 0x04030201);\n    }\n\n    #[test]\n    fn test_stream_read_bits() {\n        let data = [0b10110100, 0b11001010];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        // Read 4 bits: 1011\n        assert_eq!(stream.read_bits(4).unwrap(), 0b1011);\n        // Read 4 bits: 0100\n        assert_eq!(stream.read_bits(4).unwrap(), 0b0100);\n        // Read 8 bits: 11001010\n        assert_eq!(stream.read_bits(8).unwrap(), 0b11001010);\n    }\n\n    #[test]\n    fn test_stream_sync_bits() {\n        let data = [0xFF, 0x00];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        stream.read_bits(4).unwrap();\n        stream.sync_bits();\n\n        // After sync, should read fresh byte\n        assert_eq!(stream.read_byte().unwrap(), Some(0x00));\n    }\n\n    #[test]\n    fn test_stream_tell() {\n        let data = b\"Hello\";\n        let mut stream = Stream::open_memory(data);\n\n        assert_eq!(stream.tell(), 0);\n        stream.read_byte().unwrap();\n    }\n\n    #[test]\n    fn test_stream_debug() {\n        let stream = Stream::open_memory(b\"test\");\n        let debug = format!(\"{:?}\", stream);\n        assert!(debug.contains(\"Stream\"));\n        assert!(debug.contains(\"pos\"));\n        assert!(debug.contains(\"eof\"));\n    }\n\n    #[test]\n    fn test_stream_sequential_reads() {\n        let data = b\"ABCDEFGHIJ\";\n        let mut stream = Stream::open_memory(data);\n\n        let mut buf = [0u8; 3];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"ABC\");\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"DEF\");\n\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"GHI\");\n    }\n\n    #[test]\n    fn test_stream_large_read() {\n        let data: Vec\u003cu8\u003e = (0..20000).map(|i| (i % 256) as u8).collect();\n        let mut stream = Stream::open_memory(\u0026data);\n\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.len(), data.len());\n        assert_eq!(buffer.as_slice(), \u0026data[..]);\n    }\n\n    #[test]\n    fn test_stream_is_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n\n        assert!(!stream.is_eof());\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap(); // Returns None, sets EOF\n        assert!(stream.is_eof());\n    }\n\n    #[test]\n    fn test_memory_source_seek() {\n        let data = b\"Hello World\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n\n        let pos = source.seek(SeekFrom::Start(6)).unwrap();\n        assert_eq!(pos, 6);\n        assert_eq!(source.position, 6);\n\n        let pos = source.seek(SeekFrom::Current(2)).unwrap();\n        assert_eq!(pos, 8);\n\n        let pos = source.seek(SeekFrom::End(-5)).unwrap();\n        assert_eq!(pos, 6);\n    }\n\n    #[test]\n    fn test_memory_source_seek_before_start() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 2,\n        };\n\n        let result = source.seek(SeekFrom::Current(-10));\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // Additional coverage tests\n    // ============================================================================\n\n    #[test]\n    fn test_memory_source_len() {\n        let data = b\"Hello\";\n        let source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n        assert_eq!(source.len(), Some(5));\n    }\n\n    #[test]\n    fn test_memory_source_tell() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 3,\n        };\n        assert_eq!(source.tell().unwrap(), 3);\n    }\n\n    #[test]\n    fn test_memory_source_read() {\n        let data = b\"Hello\";\n        let mut source = MemorySource {\n            data: Bytes::copy_from_slice(data),\n            position: 0,\n        };\n        let mut buf = [0u8; 3];\n        let n = source.read(\u0026mut buf).unwrap();\n        assert_eq!(n, 3);\n        assert_eq!(\u0026buf, b\"Hel\");\n    }\n\n    #[test]\n    fn test_stream_filename() {\n        let stream = Stream::open_memory(b\"Test\");\n        assert!(stream.filename().is_none());\n    }\n\n    #[test]\n    fn test_stream_read_at_eof() {\n        let mut stream = Stream::open_memory(b\"AB\");\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        let r = stream.read_byte().unwrap(); // Returns None at EOF\n        assert!(r.is_none());\n\n        let mut buf = [0u8; 10];\n        let result = stream.read(\u0026mut buf);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n\n    #[test]\n    fn test_stream_len() {\n        let stream = Stream::open_memory(b\"Hello World\");\n        assert_eq!(stream.len(), Some(11));\n    }\n\n    #[test]\n    fn test_stream_is_empty() {\n        let stream = Stream::open_memory(b\"\");\n        assert!(stream.is_empty());\n\n        let stream2 = Stream::open_memory(b\"Test\");\n        assert!(!stream2.is_empty());\n    }\n\n    #[test]\n    fn test_stream_seek_start() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        stream.read_byte().unwrap();\n        stream.read_byte().unwrap();\n        stream.seek(0, 0).unwrap(); // SEEK_SET\n        assert_eq!(stream.tell(), 0);\n    }\n\n    #[test]\n    fn test_stream_seek_end() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        stream.seek(-5, 2).unwrap(); // SEEK_END\n        let mut buf = [0u8; 5];\n        stream.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(\u0026buf, b\"World\");\n    }\n\n    #[test]\n    fn test_stream_read_all_with_hint() {\n        let mut stream = Stream::open_memory(b\"Hello World\");\n        let buffer = stream.read_all(20).unwrap();\n        assert_eq!(buffer.as_slice(), b\"Hello World\");\n    }\n\n    #[test]\n    fn test_stream_read_all_no_hint() {\n        let mut stream = Stream::open_memory(b\"Test\");\n        let buffer = stream.read_all(0).unwrap();\n        assert_eq!(buffer.as_slice(), b\"Test\");\n    }\n\n    #[test]\n    fn test_stream_read_line_crlf() {\n        let data = b\"Line1\\r\\nLine2\\r\\n\";\n        let mut stream = Stream::open_memory(data);\n\n        let line1 = stream.read_line().unwrap().unwrap();\n        assert_eq!(\u0026line1[..5], b\"Line1\");\n\n        let line2 = stream.read_line().unwrap().unwrap();\n        assert_eq!(\u0026line2[..5], b\"Line2\");\n    }\n\n    #[test]\n    fn test_stream_read_line_no_newline() {\n        let data = b\"NoNewline\";\n        let mut stream = Stream::open_memory(data);\n\n        // Should read all remaining data even without newline\n        let line = stream.read_line().unwrap();\n        assert!(line.is_none() || !line.unwrap().is_empty());\n    }\n\n    #[test]\n    fn test_stream_read_bits_cross_byte() {\n        let data = [0xFF, 0xFF];\n        let mut stream = Stream::open_memory(\u0026data);\n\n        // Read 12 bits spanning two bytes\n        let val = stream.read_bits(12).unwrap();\n        assert_eq!(val, 0xFFF);\n    }\n\n    #[test]\n    fn test_stream_peek_after_read() {\n        let data = b\"ABC\";\n        let mut stream = Stream::open_memory(data);\n        stream.read_byte().unwrap();\n        assert_eq!(stream.peek_byte().unwrap(), Some(b'B'));\n    }\n\n    #[test]\n    fn test_stream_skip_past_eof() {\n        let data = b\"Hi\";\n        let mut stream = Stream::open_memory(data);\n        let skipped = stream.skip(100).unwrap();\n        assert_eq!(skipped, 2);\n    }\n}\n","traces":[{"line":47,"address":[1701152],"length":1,"stats":{"Line":0}},{"line":48,"address":[1701170],"length":1,"stats":{"Line":0}},{"line":51,"address":[1701184],"length":1,"stats":{"Line":0}},{"line":52,"address":[1701202],"length":1,"stats":{"Line":0}},{"line":55,"address":[1701216],"length":1,"stats":{"Line":0}},{"line":56,"address":[1701221],"length":1,"stats":{"Line":0}},{"line":59,"address":[1701232],"length":1,"stats":{"Line":0}},{"line":60,"address":[1701237],"length":1,"stats":{"Line":0}},{"line":71,"address":[1701280],"length":1,"stats":{"Line":1}},{"line":72,"address":[1701317],"length":1,"stats":{"Line":1}},{"line":73,"address":[1701384],"length":1,"stats":{"Line":1}},{"line":74,"address":[1701416],"length":1,"stats":{"Line":1}},{"line":75,"address":[1701516,1701581],"length":1,"stats":{"Line":1}},{"line":76,"address":[1701549],"length":1,"stats":{"Line":1}},{"line":79,"address":[1701600],"length":1,"stats":{"Line":1}},{"line":80,"address":[1701627],"length":1,"stats":{"Line":1}},{"line":81,"address":[1701661],"length":1,"stats":{"Line":1}},{"line":82,"address":[1701772,1701683],"length":1,"stats":{"Line":2}},{"line":83,"address":[1701797,1701728],"length":1,"stats":{"Line":2}},{"line":85,"address":[1701757],"length":1,"stats":{"Line":1}},{"line":86,"address":[1701883],"length":1,"stats":{"Line":1}},{"line":88,"address":[1701822],"length":1,"stats":{"Line":1}},{"line":89,"address":[1701863],"length":1,"stats":{"Line":1}},{"line":92,"address":[1701952],"length":1,"stats":{"Line":1}},{"line":93,"address":[1701957],"length":1,"stats":{"Line":1}},{"line":96,"address":[1702000],"length":1,"stats":{"Line":1}},{"line":97,"address":[1702009],"length":1,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[1702048,1702383,1702377],"length":1,"stats":{"Line":3}},{"line":129,"address":[1702094],"length":1,"stats":{"Line":3}},{"line":133,"address":[1702160],"length":1,"stats":{"Line":6}},{"line":146,"address":[1702681,1702400],"length":1,"stats":{"Line":1}},{"line":148,"address":[1702416],"length":1,"stats":{"Line":1}},{"line":152,"address":[1702479],"length":1,"stats":{"Line":2}},{"line":165,"address":[1702704],"length":1,"stats":{"Line":1}},{"line":166,"address":[1702722],"length":1,"stats":{"Line":1}},{"line":170,"address":[1702768],"length":1,"stats":{"Line":1}},{"line":171,"address":[1702858,1702777],"length":1,"stats":{"Line":1}},{"line":175,"address":[1702880],"length":1,"stats":{"Line":1}},{"line":176,"address":[1702888],"length":1,"stats":{"Line":1}},{"line":180,"address":[1702912],"length":1,"stats":{"Line":2}},{"line":181,"address":[1702924],"length":1,"stats":{"Line":2}},{"line":185,"address":[1702976],"length":1,"stats":{"Line":1}},{"line":186,"address":[1702986],"length":1,"stats":{"Line":1}},{"line":190,"address":[1703040],"length":1,"stats":{"Line":1}},{"line":191,"address":[1703045],"length":1,"stats":{"Line":1}},{"line":195,"address":[1703056],"length":1,"stats":{"Line":2}},{"line":196,"address":[1703083],"length":1,"stats":{"Line":3}},{"line":197,"address":[1703108],"length":1,"stats":{"Line":1}},{"line":201,"address":[1703094,1703248],"length":1,"stats":{"Line":4}},{"line":202,"address":[1703202,1703164,1703348],"length":1,"stats":{"Line":4}},{"line":204,"address":[1703350,1703209,1703260],"length":1,"stats":{"Line":0}},{"line":205,"address":[1703268],"length":1,"stats":{"Line":0}},{"line":206,"address":[1703324],"length":1,"stats":{"Line":0}},{"line":207,"address":[1703344],"length":1,"stats":{"Line":0}},{"line":209,"address":[1703179],"length":1,"stats":{"Line":4}},{"line":210,"address":[1703194],"length":1,"stats":{"Line":3}},{"line":212,"address":[1703240],"length":1,"stats":{"Line":3}},{"line":216,"address":[1703133],"length":1,"stats":{"Line":3}},{"line":217,"address":[1703467],"length":1,"stats":{"Line":2}},{"line":221,"address":[1703368,1703564],"length":1,"stats":{"Line":6}},{"line":223,"address":[1703582],"length":1,"stats":{"Line":3}},{"line":224,"address":[1703586],"length":1,"stats":{"Line":4}},{"line":226,"address":[1703608],"length":1,"stats":{"Line":3}},{"line":227,"address":[1703689,1703670,1703626],"length":1,"stats":{"Line":6}},{"line":228,"address":[1703721,1703674,1703738],"length":1,"stats":{"Line":8}},{"line":229,"address":[1703725],"length":1,"stats":{"Line":5}},{"line":231,"address":[1703496],"length":1,"stats":{"Line":0}},{"line":232,"address":[1703509],"length":1,"stats":{"Line":0}},{"line":233,"address":[1703513],"length":1,"stats":{"Line":0}},{"line":239,"address":[1703760],"length":1,"stats":{"Line":1}},{"line":240,"address":[1703860,1703790],"length":1,"stats":{"Line":3}},{"line":241,"address":[1704017],"length":1,"stats":{"Line":1}},{"line":243,"address":[1704127,1704083,1703805],"length":1,"stats":{"Line":2}},{"line":244,"address":[1704213,1704159,1704097],"length":1,"stats":{"Line":4}},{"line":245,"address":[1704163],"length":1,"stats":{"Line":2}},{"line":249,"address":[1704240],"length":1,"stats":{"Line":1}},{"line":250,"address":[1704339,1704270],"length":1,"stats":{"Line":2}},{"line":251,"address":[1704487],"length":1,"stats":{"Line":0}},{"line":253,"address":[1704552,1704285,1704612],"length":1,"stats":{"Line":2}},{"line":257,"address":[1704640],"length":1,"stats":{"Line":1}},{"line":258,"address":[1704708],"length":1,"stats":{"Line":1}},{"line":259,"address":[1704725],"length":1,"stats":{"Line":1}},{"line":260,"address":[1704775,1704820],"length":1,"stats":{"Line":1}},{"line":261,"address":[1704812,1705472],"length":1,"stats":{"Line":5}},{"line":262,"address":[1704913,1705153,1705097],"length":1,"stats":{"Line":2}},{"line":263,"address":[1705189,1705116,1705391],"length":1,"stats":{"Line":2}},{"line":264,"address":[1705375,1705422,1705446],"length":1,"stats":{"Line":3}},{"line":265,"address":[1705464,1705426,1705477],"length":1,"stats":{"Line":5}},{"line":266,"address":[1704954,1704841],"length":1,"stats":{"Line":1}},{"line":270,"address":[1704743],"length":1,"stats":{"Line":2}},{"line":274,"address":[1705504],"length":1,"stats":{"Line":2}},{"line":275,"address":[1705549],"length":1,"stats":{"Line":2}},{"line":276,"address":[1705704],"length":1,"stats":{"Line":1}},{"line":278,"address":[1705690],"length":1,"stats":{"Line":3}},{"line":282,"address":[1706347,1705776,1706376],"length":1,"stats":{"Line":4}},{"line":283,"address":[1705827],"length":1,"stats":{"Line":2}},{"line":285,"address":[1705858,1705903],"length":1,"stats":{"Line":2}},{"line":286,"address":[1706096,1705895],"length":1,"stats":{"Line":4}},{"line":287,"address":[1705989],"length":1,"stats":{"Line":2}},{"line":288,"address":[1706088],"length":1,"stats":{"Line":2}},{"line":290,"address":[1705977,1706114],"length":1,"stats":{"Line":4}},{"line":294,"address":[1706225],"length":1,"stats":{"Line":2}},{"line":298,"address":[1706992,1706998,1706384],"length":1,"stats":{"Line":1}},{"line":299,"address":[1706414],"length":1,"stats":{"Line":2}},{"line":301,"address":[1706493,1706435,1706990],"length":1,"stats":{"Line":3}},{"line":303,"address":[1706645],"length":1,"stats":{"Line":1}},{"line":304,"address":[1706824],"length":1,"stats":{"Line":1}},{"line":309,"address":[1706967,1706898],"length":1,"stats":{"Line":2}},{"line":312,"address":[1706934],"length":1,"stats":{"Line":2}},{"line":313,"address":[1706926,1706944,1706985],"length":1,"stats":{"Line":4}},{"line":317,"address":[1706684],"length":1,"stats":{"Line":1}},{"line":321,"address":[1707024],"length":1,"stats":{"Line":2}},{"line":322,"address":[1707059],"length":1,"stats":{"Line":2}},{"line":323,"address":[1707068],"length":1,"stats":{"Line":2}},{"line":324,"address":[1707152,1707107],"length":1,"stats":{"Line":2}},{"line":325,"address":[1707509,1707144],"length":1,"stats":{"Line":4}},{"line":326,"address":[1707230],"length":1,"stats":{"Line":2}},{"line":327,"address":[1707435,1707259,1707414],"length":1,"stats":{"Line":4}},{"line":328,"address":[1707458,1707486,1707418],"length":1,"stats":{"Line":4}},{"line":329,"address":[1707514,1707463,1707504],"length":1,"stats":{"Line":4}},{"line":330,"address":[1707170,1707284],"length":1,"stats":{"Line":2}},{"line":334,"address":[1707081],"length":1,"stats":{"Line":2}},{"line":338,"address":[1707536],"length":1,"stats":{"Line":2}},{"line":339,"address":[1707590],"length":1,"stats":{"Line":2}},{"line":340,"address":[1707690],"length":1,"stats":{"Line":1}},{"line":341,"address":[1707711],"length":1,"stats":{"Line":0}},{"line":342,"address":[1707732],"length":1,"stats":{"Line":1}},{"line":343,"address":[1707618],"length":1,"stats":{"Line":0}},{"line":347,"address":[1707751],"length":1,"stats":{"Line":2}},{"line":348,"address":[1707759],"length":1,"stats":{"Line":2}},{"line":349,"address":[1707767],"length":1,"stats":{"Line":2}},{"line":350,"address":[1707771],"length":1,"stats":{"Line":2}},{"line":351,"address":[1707951],"length":1,"stats":{"Line":2}},{"line":355,"address":[1707984],"length":1,"stats":{"Line":1}},{"line":356,"address":[1708013],"length":1,"stats":{"Line":1}},{"line":357,"address":[1708035],"length":1,"stats":{"Line":1}},{"line":358,"address":[1708158],"length":1,"stats":{"Line":1}},{"line":362,"address":[1708240],"length":1,"stats":{"Line":1}},{"line":363,"address":[1708270],"length":1,"stats":{"Line":1}},{"line":364,"address":[1708292],"length":1,"stats":{"Line":1}},{"line":365,"address":[1708424],"length":1,"stats":{"Line":1}},{"line":369,"address":[1708480],"length":1,"stats":{"Line":1}},{"line":370,"address":[1708509],"length":1,"stats":{"Line":1}},{"line":371,"address":[1708531],"length":1,"stats":{"Line":1}},{"line":372,"address":[1708654],"length":1,"stats":{"Line":1}},{"line":376,"address":[1708720],"length":1,"stats":{"Line":1}},{"line":377,"address":[1708749],"length":1,"stats":{"Line":1}},{"line":378,"address":[1708771],"length":1,"stats":{"Line":1}},{"line":379,"address":[1708894],"length":1,"stats":{"Line":1}},{"line":383,"address":[1708976],"length":1,"stats":{"Line":1}},{"line":384,"address":[1709005],"length":1,"stats":{"Line":1}},{"line":385,"address":[1709027],"length":1,"stats":{"Line":1}},{"line":386,"address":[1709150],"length":1,"stats":{"Line":1}},{"line":390,"address":[1709216],"length":1,"stats":{"Line":1}},{"line":391,"address":[1709245],"length":1,"stats":{"Line":1}},{"line":392,"address":[1709267],"length":1,"stats":{"Line":1}},{"line":393,"address":[1709390],"length":1,"stats":{"Line":1}},{"line":397,"address":[1709472],"length":1,"stats":{"Line":1}},{"line":398,"address":[1709501],"length":1,"stats":{"Line":1}},{"line":399,"address":[1709523],"length":1,"stats":{"Line":1}},{"line":400,"address":[1709646],"length":1,"stats":{"Line":1}},{"line":404,"address":[1709712],"length":1,"stats":{"Line":1}},{"line":405,"address":[1710305,1709764],"length":1,"stats":{"Line":2}},{"line":406,"address":[1709800,1710060],"length":1,"stats":{"Line":1}},{"line":407,"address":[1710178],"length":1,"stats":{"Line":1}},{"line":408,"address":[1710192],"length":1,"stats":{"Line":1}},{"line":409,"address":[1710310,1710302,1710206],"length":1,"stats":{"Line":2}},{"line":411,"address":[1710229],"length":1,"stats":{"Line":0}},{"line":414,"address":[1709872,1709778,1709881],"length":1,"stats":{"Line":2}},{"line":415,"address":[1709875,1709975,1709898],"length":1,"stats":{"Line":2}},{"line":416,"address":[1710029,1709955,1710005],"length":1,"stats":{"Line":2}},{"line":420,"address":[1710336],"length":1,"stats":{"Line":1}},{"line":421,"address":[1710341],"length":1,"stats":{"Line":1}},{"line":422,"address":[1710348],"length":1,"stats":{"Line":1}},{"line":427,"address":[1710368],"length":1,"stats":{"Line":1}},{"line":428,"address":[1710425,1710472,1710387],"length":1,"stats":{"Line":3}},{"line":429,"address":[1710415],"length":1,"stats":{"Line":1}},{"line":430,"address":[1710468],"length":1,"stats":{"Line":1}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[2057272,2057008,2057278],"length":1,"stats":{"Line":0}},{"line":474,"address":[2057057],"length":1,"stats":{"Line":0}},{"line":478,"address":[2057114],"length":1,"stats":{"Line":0}},{"line":485,"address":[2057296,2057518],"length":1,"stats":{"Line":0}},{"line":487,"address":[2057312],"length":1,"stats":{"Line":0}},{"line":491,"address":[2057360],"length":1,"stats":{"Line":0}},{"line":498,"address":[2057552,2057570],"length":1,"stats":{"Line":0}},{"line":499,"address":[1391092],"length":1,"stats":{"Line":0}},{"line":500,"address":[1391273],"length":1,"stats":{"Line":0}},{"line":501,"address":[1392047,1391289,1391359,1391167,1392491],"length":1,"stats":{"Line":0}},{"line":502,"address":[1392353,1392421],"length":1,"stats":{"Line":0}},{"line":503,"address":[1392413],"length":1,"stats":{"Line":0}},{"line":504,"address":[1392442],"length":1,"stats":{"Line":0}},{"line":506,"address":[1392466],"length":1,"stats":{"Line":0}},{"line":508,"address":[1391188],"length":1,"stats":{"Line":0}},{"line":509,"address":[1391223,1391464],"length":1,"stats":{"Line":0}},{"line":510,"address":[1391557],"length":1,"stats":{"Line":0}},{"line":511,"address":[1391602],"length":1,"stats":{"Line":0}},{"line":512,"address":[1391811,1391744],"length":1,"stats":{"Line":0}},{"line":513,"address":[1391778,1391868,1391841],"length":1,"stats":{"Line":0}},{"line":514,"address":[1391860],"length":1,"stats":{"Line":0}},{"line":515,"address":[1391886],"length":1,"stats":{"Line":0}},{"line":517,"address":[1391910],"length":1,"stats":{"Line":0}},{"line":523,"address":[2057608,2057600],"length":1,"stats":{"Line":0}},{"line":524,"address":[1392615],"length":1,"stats":{"Line":0}},{"line":525,"address":[1392738],"length":1,"stats":{"Line":0}},{"line":527,"address":[1392767,1393471,1393098,1392828,1392666,1392852],"length":1,"stats":{"Line":0}},{"line":528,"address":[1393207],"length":1,"stats":{"Line":0}},{"line":531,"address":[1393288,1393446],"length":1,"stats":{"Line":0}},{"line":533,"address":[1393213,1393330],"length":1,"stats":{"Line":0}},{"line":537,"address":[2057650,2057632],"length":1,"stats":{"Line":0}},{"line":538,"address":[1393742],"length":1,"stats":{"Line":0}},{"line":539,"address":[1393920],"length":1,"stats":{"Line":0}},{"line":540,"address":[1393814,1394022,1393928,1394666,1395027],"length":1,"stats":{"Line":0}},{"line":541,"address":[1394964],"length":1,"stats":{"Line":0}},{"line":542,"address":[1394983],"length":1,"stats":{"Line":0}},{"line":543,"address":[1395002],"length":1,"stats":{"Line":0}},{"line":545,"address":[1393832],"length":1,"stats":{"Line":0}},{"line":546,"address":[1393869],"length":1,"stats":{"Line":0}},{"line":547,"address":[1394100],"length":1,"stats":{"Line":0}},{"line":548,"address":[1394223,1394131],"length":1,"stats":{"Line":0}},{"line":549,"address":[1394169,1394276],"length":1,"stats":{"Line":0}},{"line":551,"address":[1394200],"length":1,"stats":{"Line":0}},{"line":552,"address":[1394566,1394334],"length":1,"stats":{"Line":0}},{"line":554,"address":[1394309,1394374],"length":1,"stats":{"Line":0}},{"line":555,"address":[1394403],"length":1,"stats":{"Line":0}},{"line":556,"address":[1394425],"length":1,"stats":{"Line":0}},{"line":557,"address":[1394444],"length":1,"stats":{"Line":0}},{"line":563,"address":[2057680],"length":1,"stats":{"Line":0}},{"line":564,"address":[2057685],"length":1,"stats":{"Line":0}},{"line":568,"address":[2057696],"length":1,"stats":{"Line":0}},{"line":569,"address":[2057701],"length":1,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}}],"covered":159,"coverable":260},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","fitz","text.rs"],"content":"//! Text spans and pages\nuse crate::fitz::geometry::Quad;\n\npub struct TextSpan { chars: Vec\u003cTextChar\u003e }\npub struct TextChar { pub c: char, pub quad: Quad }\n\nimpl TextSpan {\n    pub fn new() -\u003e Self { Self { chars: Vec::new() } }\n    pub fn add_char(\u0026mut self, c: char, quad: Quad) { self.chars.push(TextChar { c, quad }); }\n    pub fn text(\u0026self) -\u003e String { self.chars.iter().map(|c| c.c).collect() }\n    pub fn len(\u0026self) -\u003e usize { self.chars.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.chars.is_empty() }\n}\nimpl Default for TextSpan { fn default() -\u003e Self { Self::new() } }\n\npub struct TextPage { spans: Vec\u003cTextSpan\u003e }\nimpl TextPage {\n    pub fn new() -\u003e Self { Self { spans: Vec::new() } }\n    pub fn add_span(\u0026mut self, span: TextSpan) { self.spans.push(span); }\n    pub fn spans(\u0026self) -\u003e \u0026[TextSpan] { \u0026self.spans }\n    pub fn len(\u0026self) -\u003e usize { self.spans.len() }\n    pub fn is_empty(\u0026self) -\u003e bool { self.spans.is_empty() }\n}\nimpl Default for TextPage { fn default() -\u003e Self { Self::new() } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::fitz::geometry::{Point, Rect};\n\n    fn make_quad(x: f32, y: f32, w: f32, h: f32) -\u003e Quad {\n        Quad::from_rect(\u0026Rect::new(x, y, x + w, y + h))\n    }\n\n    #[test]\n    fn test_text_span_new() {\n        let span = TextSpan::new();\n        assert!(span.is_empty());\n        assert_eq!(span.len(), 0);\n        assert_eq!(span.text(), \"\");\n    }\n\n    #[test]\n    fn test_text_span_default() {\n        let span: TextSpan = Default::default();\n        assert!(span.is_empty());\n    }\n\n    #[test]\n    fn test_text_span_add_char() {\n        let mut span = TextSpan::new();\n        span.add_char('H', make_quad(0.0, 0.0, 10.0, 12.0));\n        span.add_char('i', make_quad(10.0, 0.0, 5.0, 12.0));\n\n        assert_eq!(span.len(), 2);\n        assert!(!span.is_empty());\n        assert_eq!(span.text(), \"Hi\");\n    }\n\n    #[test]\n    fn test_text_span_unicode() {\n        let mut span = TextSpan::new();\n        span.add_char('', make_quad(0.0, 0.0, 12.0, 12.0));\n        span.add_char('', make_quad(12.0, 0.0, 12.0, 12.0));\n        span.add_char('', make_quad(24.0, 0.0, 12.0, 12.0));\n\n        assert_eq!(span.text(), \"\");\n    }\n\n    #[test]\n    fn test_text_page_new() {\n        let page = TextPage::new();\n        assert!(page.is_empty());\n        assert_eq!(page.len(), 0);\n    }\n\n    #[test]\n    fn test_text_page_default() {\n        let page: TextPage = Default::default();\n        assert!(page.is_empty());\n    }\n\n    #[test]\n    fn test_text_page_add_span() {\n        let mut page = TextPage::new();\n\n        let mut span1 = TextSpan::new();\n        span1.add_char('A', make_quad(0.0, 0.0, 10.0, 12.0));\n        page.add_span(span1);\n\n        let mut span2 = TextSpan::new();\n        span2.add_char('B', make_quad(0.0, 12.0, 10.0, 12.0));\n        page.add_span(span2);\n\n        assert_eq!(page.len(), 2);\n        assert!(!page.is_empty());\n    }\n\n    #[test]\n    fn test_text_page_spans() {\n        let mut page = TextPage::new();\n\n        let mut span = TextSpan::new();\n        span.add_char('X', make_quad(0.0, 0.0, 10.0, 12.0));\n        page.add_span(span);\n\n        let spans = page.spans();\n        assert_eq!(spans.len(), 1);\n        assert_eq!(spans[0].text(), \"X\");\n    }\n\n    #[test]\n    fn test_text_char_fields() {\n        let quad = make_quad(5.0, 10.0, 8.0, 12.0);\n        let tc = TextChar { c: 'Z', quad };\n\n        assert_eq!(tc.c, 'Z');\n        assert_eq!(tc.quad.ul.x, 5.0);\n        assert_eq!(tc.quad.ul.y, 10.0);\n    }\n}\n\n","traces":[{"line":8,"address":[2101965,2101952],"length":1,"stats":{"Line":2}},{"line":9,"address":[2102029,2102016],"length":1,"stats":{"Line":4}},{"line":10,"address":[1800938,1800928],"length":1,"stats":{"Line":4}},{"line":11,"address":[2102192,2102197],"length":1,"stats":{"Line":3}},{"line":12,"address":[2102208,2102213],"length":1,"stats":{"Line":2}},{"line":14,"address":[2102224,2102232],"length":1,"stats":{"Line":2}},{"line":18,"address":[2102269,2102256],"length":1,"stats":{"Line":3}},{"line":19,"address":[2102320,2102325],"length":1,"stats":{"Line":2}},{"line":20,"address":[2102352,2102357],"length":1,"stats":{"Line":2}},{"line":21,"address":[2102373,2102368],"length":1,"stats":{"Line":3}},{"line":22,"address":[2102389,2102384],"length":1,"stats":{"Line":3}},{"line":24,"address":[2102408,2102400],"length":1,"stats":{"Line":2}}],"covered":12,"coverable":12},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","lib.rs"],"content":"//! MicroPDF - A native Rust PDF library inspired by MuPDF\n//!\n//! This library provides PDF parsing, rendering, and manipulation capabilities.\n//!\n//! # FFI Module\n//!\n//! The `ffi` module provides C-compatible exports that match MuPDF's API.\n//! When compiled as a staticlib or cdylib, these functions can be called\n//! from C code using the same function signatures as MuPDF.\n\npub mod fitz;\npub mod pdf;\npub mod ffi;\n\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","annot.rs"],"content":"//! PDF annot module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","cmap.rs"],"content":"//! PDF cmap module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","colorspace.rs"],"content":"//! PDF colorspace module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","crypt.rs"],"content":"//! PDF encryption/decryption\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","document.rs"],"content":"//! PDF document implementation\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","filter.rs"],"content":"//! PDF Stream Filter/Compression Module\n//!\n//! This module implements all PDF stream filters for decompression and compression.\n//! Supports the complete set of PDF filters as defined in PDF 1.7 specification.\n\nuse std::io::{self, Read, Write};\nuse flate2::read::{ZlibDecoder, ZlibEncoder};\nuse flate2::Compression;\n\nuse crate::fitz::error::{Error, Result};\n\n/// PDF Filter types as defined in PDF specification\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FilterType {\n    /// FlateDecode - zlib/deflate compression (most common)\n    FlateDecode,\n    /// LZWDecode - Lempel-Ziv-Welch compression\n    LZWDecode,\n    /// ASCII85Decode - ASCII base-85 encoding\n    ASCII85Decode,\n    /// ASCIIHexDecode - Hexadecimal encoding\n    ASCIIHexDecode,\n    /// RunLengthDecode - Run-length encoding\n    RunLengthDecode,\n    /// CCITTFaxDecode - CCITT Group 3 and Group 4 fax encoding\n    CCITTFaxDecode,\n    /// DCTDecode - JPEG compression\n    DCTDecode,\n    /// JPXDecode - JPEG 2000 compression\n    JPXDecode,\n    /// JBIG2Decode - JBIG2 compression\n    JBIG2Decode,\n    /// Crypt - Encryption filter\n    Crypt,\n}\n\nimpl FilterType {\n    /// Parse filter type from PDF name\n    pub fn from_name(name: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match name {\n            \"FlateDecode\" | \"Fl\" =\u003e Some(FilterType::FlateDecode),\n            \"LZWDecode\" | \"LZW\" =\u003e Some(FilterType::LZWDecode),\n            \"ASCII85Decode\" | \"A85\" =\u003e Some(FilterType::ASCII85Decode),\n            \"ASCIIHexDecode\" | \"AHx\" =\u003e Some(FilterType::ASCIIHexDecode),\n            \"RunLengthDecode\" | \"RL\" =\u003e Some(FilterType::RunLengthDecode),\n            \"CCITTFaxDecode\" | \"CCF\" =\u003e Some(FilterType::CCITTFaxDecode),\n            \"DCTDecode\" | \"DCT\" =\u003e Some(FilterType::DCTDecode),\n            \"JPXDecode\" =\u003e Some(FilterType::JPXDecode),\n            \"JBIG2Decode\" =\u003e Some(FilterType::JBIG2Decode),\n            \"Crypt\" =\u003e Some(FilterType::Crypt),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the PDF name for this filter\n    pub fn to_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            FilterType::FlateDecode =\u003e \"FlateDecode\",\n            FilterType::LZWDecode =\u003e \"LZWDecode\",\n            FilterType::ASCII85Decode =\u003e \"ASCII85Decode\",\n            FilterType::ASCIIHexDecode =\u003e \"ASCIIHexDecode\",\n            FilterType::RunLengthDecode =\u003e \"RunLengthDecode\",\n            FilterType::CCITTFaxDecode =\u003e \"CCITTFaxDecode\",\n            FilterType::DCTDecode =\u003e \"DCTDecode\",\n            FilterType::JPXDecode =\u003e \"JPXDecode\",\n            FilterType::JBIG2Decode =\u003e \"JBIG2Decode\",\n            FilterType::Crypt =\u003e \"Crypt\",\n        }\n    }\n}\n\n/// Parameters for FlateDecode filter\n#[derive(Debug, Clone, Default)]\npub struct FlateDecodeParams {\n    /// PNG predictor algorithm (1 = None, 2 = TIFF, 10-15 = PNG)\n    pub predictor: i32,\n    /// Number of color components per sample\n    pub colors: i32,\n    /// Number of bits per color component\n    pub bits_per_component: i32,\n    /// Number of samples per row\n    pub columns: i32,\n}\n\n/// Parameters for LZWDecode filter\n#[derive(Debug, Clone, Default)]\npub struct LZWDecodeParams {\n    /// PNG predictor algorithm\n    pub predictor: i32,\n    /// Number of color components per sample\n    pub colors: i32,\n    /// Number of bits per color component\n    pub bits_per_component: i32,\n    /// Number of samples per row\n    pub columns: i32,\n    /// Early change parameter (0 or 1)\n    pub early_change: i32,\n}\n\n/// Parameters for CCITTFaxDecode filter\n#[derive(Debug, Clone)]\npub struct CCITTFaxDecodeParams {\n    /// Encoding scheme: 0 = Group 3 1D, \u003c0 = Group 3 2D, \u003e0 = Group 4\n    pub k: i32,\n    /// If true, end-of-line bit patterns are required\n    pub end_of_line: bool,\n    /// If true, byte-aligned encoding is expected\n    pub encoded_byte_align: bool,\n    /// Width of the image in pixels\n    pub columns: i32,\n    /// Height of the image in pixels\n    pub rows: i32,\n    /// If true, uncompressed data should be end-of-block\n    pub end_of_block: bool,\n    /// If true, 0 means white, 1 means black (default: false)\n    pub black_is_1: bool,\n    /// Number of damaged rows allowed\n    pub damaged_rows_before_error: i32,\n}\n\nimpl Default for CCITTFaxDecodeParams {\n    fn default() -\u003e Self {\n        Self {\n            k: 0,\n            end_of_line: false,\n            encoded_byte_align: false,\n            columns: 1728,\n            rows: 0,\n            end_of_block: true,\n            black_is_1: false,\n            damaged_rows_before_error: 0,\n        }\n    }\n}\n\n/// Parameters for DCTDecode filter (JPEG)\n#[derive(Debug, Clone, Default)]\npub struct DCTDecodeParams {\n    /// Color transform: 0 = no transform, 1 = YCbCr to RGB\n    pub color_transform: i32,\n}\n\n/// Parameters for JBIG2Decode filter\n#[derive(Debug, Clone, Default)]\npub struct JBIG2DecodeParams {\n    /// Global segment data\n    pub jbig2_globals: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n// ============================================================================\n// FlateDecode (zlib/deflate)\n// ============================================================================\n\n/// Decode FlateDecode (zlib/deflate) compressed data\npub fn decode_flate(data: \u0026[u8], params: Option\u003c\u0026FlateDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut decoder = ZlibDecoder::new(data);\n    let mut decompressed = Vec::new();\n    decoder.read_to_end(\u0026mut decompressed)\n        .map_err(|e| Error::Generic(format!(\"FlateDecode failed: {}\", e)))?;\n\n    // Apply predictor if specified\n    if let Some(params) = params {\n        if params.predictor \u003e 1 {\n            decompressed = apply_predictor_decode(\u0026decompressed, params)?;\n        }\n    }\n\n    Ok(decompressed)\n}\n\n/// Encode data with FlateDecode (zlib/deflate)\npub fn encode_flate(data: \u0026[u8], level: u32) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let compression = match level {\n        0 =\u003e Compression::none(),\n        1..=3 =\u003e Compression::fast(),\n        4..=6 =\u003e Compression::default(),\n        _ =\u003e Compression::best(),\n    };\n\n    let mut encoder = ZlibEncoder::new(data, compression);\n    let mut compressed = Vec::new();\n    encoder.read_to_end(\u0026mut compressed)\n        .map_err(|e| Error::Generic(format!(\"FlateDecode encode failed: {}\", e)))?;\n\n    Ok(compressed)\n}\n\n// ============================================================================\n// LZWDecode\n// ============================================================================\n\n/// Decode LZW compressed data\npub fn decode_lzw(data: \u0026[u8], params: Option\u003c\u0026LZWDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let early_change = params.map(|p| p.early_change != 0).unwrap_or(true);\n\n    let mut decoder = weezl::decode::Decoder::with_tiff_size_switch(\n        weezl::BitOrder::Msb,\n        if early_change { 8 } else { 9 },\n    );\n\n    let decompressed = decoder.decode(data)\n        .map_err(|e| Error::Generic(format!(\"LZWDecode failed: {:?}\", e)))?;\n\n    // Apply predictor if specified\n    let mut result = decompressed;\n    if let Some(params) = params {\n        if params.predictor \u003e 1 {\n            let flate_params = FlateDecodeParams {\n                predictor: params.predictor,\n                colors: params.colors,\n                bits_per_component: params.bits_per_component,\n                columns: params.columns,\n            };\n            result = apply_predictor_decode(\u0026result, \u0026flate_params)?;\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with LZW compression\npub fn encode_lzw(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut encoder = weezl::encode::Encoder::with_tiff_size_switch(weezl::BitOrder::Msb, 8);\n    encoder.encode(data)\n        .map_err(|e| Error::Generic(format!(\"LZWEncode failed: {:?}\", e)))\n}\n\n// ============================================================================\n// ASCII85Decode\n// ============================================================================\n\n/// Decode ASCII85 encoded data\npub fn decode_ascii85(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 4 / 5);\n    let mut group: u32 = 0;\n    let mut count = 0;\n\n    for \u0026byte in data {\n        // Skip whitespace\n        if byte.is_ascii_whitespace() {\n            continue;\n        }\n\n        // End of data marker\n        if byte == b'~' {\n            break;\n        }\n\n        // Special 'z' character represents 4 zero bytes\n        if byte == b'z' {\n            if count != 0 {\n                return Err(Error::Generic(\"Invalid 'z' in ASCII85 stream\".into()));\n            }\n            result.extend_from_slice(\u0026[0, 0, 0, 0]);\n            continue;\n        }\n\n        // Regular ASCII85 character\n        if !(b'!'..=b'u').contains(\u0026byte) {\n            return Err(Error::Generic(format!(\"Invalid ASCII85 character: {}\", byte)));\n        }\n\n        group = group * 85 + (byte - b'!') as u32;\n        count += 1;\n\n        if count == 5 {\n            result.push((group \u003e\u003e 24) as u8);\n            result.push((group \u003e\u003e 16) as u8);\n            result.push((group \u003e\u003e 8) as u8);\n            result.push(group as u8);\n            group = 0;\n            count = 0;\n        }\n    }\n\n    // Handle remaining bytes\n    if count \u003e 0 {\n        // Pad with 'u' characters\n        for _ in count..5 {\n            group = group * 85 + 84;\n        }\n\n        for i in 0..(count - 1) {\n            result.push((group \u003e\u003e (24 - i * 8)) as u8);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with ASCII85\npub fn encode_ascii85(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 5 / 4 + 10);\n\n    let mut i = 0;\n    while i \u003c data.len() {\n        let chunk_len = (data.len() - i).min(4);\n        let chunk = \u0026data[i..i + chunk_len];\n\n        let mut group: u32 = 0;\n        for (j, \u0026byte) in chunk.iter().enumerate() {\n            group |= (byte as u32) \u003c\u003c (24 - j * 8);\n        }\n\n        // Special case: all zeros (only for complete 4-byte chunks)\n        if group == 0 \u0026\u0026 chunk_len == 4 {\n            result.push(b'z');\n            i += 4;\n            continue;\n        }\n\n        let mut encoded = [0u8; 5];\n        let mut temp = group;\n        for j in (0..5).rev() {\n            encoded[j] = (temp % 85) as u8 + b'!';\n            temp /= 85;\n        }\n\n        // Output all 5 bytes for complete groups, or chunk_len + 1 for partial\n        let output_len = if chunk_len == 4 { 5 } else { chunk_len + 1 };\n        result.extend_from_slice(\u0026encoded[..output_len]);\n\n        i += chunk_len;\n    }\n\n    // Add end marker\n    result.extend_from_slice(b\"~\u003e\");\n\n    Ok(result)\n}\n\n// ============================================================================\n// ASCIIHexDecode\n// ============================================================================\n\n/// Decode ASCIIHex encoded data\npub fn decode_ascii_hex(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() / 2);\n    let mut high_nibble: Option\u003cu8\u003e = None;\n\n    for \u0026byte in data {\n        // Skip whitespace\n        if byte.is_ascii_whitespace() {\n            continue;\n        }\n\n        // End of data marker\n        if byte == b'\u003e' {\n            break;\n        }\n\n        let nibble = match byte {\n            b'0'..=b'9' =\u003e byte - b'0',\n            b'A'..=b'F' =\u003e byte - b'A' + 10,\n            b'a'..=b'f' =\u003e byte - b'a' + 10,\n            _ =\u003e return Err(Error::Generic(format!(\"Invalid hex character: {}\", byte))),\n        };\n\n        match high_nibble {\n            None =\u003e high_nibble = Some(nibble),\n            Some(high) =\u003e {\n                result.push((high \u003c\u003c 4) | nibble);\n                high_nibble = None;\n            }\n        }\n    }\n\n    // Handle odd number of hex digits\n    if let Some(high) = high_nibble {\n        result.push(high \u003c\u003c 4);\n    }\n\n    Ok(result)\n}\n\n/// Encode data with ASCIIHex\npub fn encode_ascii_hex(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len() * 2 + 1);\n\n    for \u0026byte in data {\n        let high = (byte \u003e\u003e 4) \u0026 0x0F;\n        let low = byte \u0026 0x0F;\n\n        result.push(if high \u003c 10 { b'0' + high } else { b'A' + high - 10 });\n        result.push(if low \u003c 10 { b'0' + low } else { b'A' + low - 10 });\n    }\n\n    result.push(b'\u003e');\n\n    Ok(result)\n}\n\n// ============================================================================\n// RunLengthDecode\n// ============================================================================\n\n/// Decode RunLength encoded data\npub fn decode_run_length(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::new();\n    let mut i = 0;\n\n    while i \u003c data.len() {\n        let length_byte = data[i];\n        i += 1;\n\n        if length_byte == 128 {\n            // End of data\n            break;\n        } else if length_byte \u003c 128 {\n            // Copy next (length_byte + 1) bytes literally\n            let count = length_byte as usize + 1;\n            if i + count \u003e data.len() {\n                return Err(Error::Generic(\"RunLengthDecode: unexpected end of data\".into()));\n            }\n            result.extend_from_slice(\u0026data[i..i + count]);\n            i += count;\n        } else {\n            // Repeat next byte (257 - length_byte) times\n            let count = 257 - length_byte as usize;\n            if i \u003e= data.len() {\n                return Err(Error::Generic(\"RunLengthDecode: unexpected end of data\".into()));\n            }\n            let byte = data[i];\n            i += 1;\n            result.resize(result.len() + count, byte);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Encode data with RunLength\npub fn encode_run_length(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::new();\n    let mut i = 0;\n\n    while i \u003c data.len() {\n        // Look for a run of identical bytes\n        let start = i;\n        let byte = data[i];\n        while i \u003c data.len() \u0026\u0026 data[i] == byte \u0026\u0026 i - start \u003c 128 {\n            i += 1;\n        }\n        let run_length = i - start;\n\n        if run_length \u003e= 2 {\n            // Encode as a run\n            result.push((257 - run_length) as u8);\n            result.push(byte);\n        } else {\n            // Look for literal bytes\n            i = start;\n            let literal_start = i;\n\n            while i \u003c data.len() {\n                // Check for a run of 3+ identical bytes\n                if i + 2 \u003c data.len() \u0026\u0026 data[i] == data[i + 1] \u0026\u0026 data[i] == data[i + 2] {\n                    break;\n                }\n                i += 1;\n                if i - literal_start \u003e= 128 {\n                    break;\n                }\n            }\n\n            let literal_length = i - literal_start;\n            if literal_length \u003e 0 {\n                result.push((literal_length - 1) as u8);\n                result.extend_from_slice(\u0026data[literal_start..i]);\n            }\n        }\n    }\n\n    // End of data marker\n    result.push(128);\n\n    Ok(result)\n}\n\n// ============================================================================\n// CCITTFaxDecode\n// ============================================================================\n\n/// Decode CCITT Group 3/4 fax encoded data\npub fn decode_ccitt_fax(data: \u0026[u8], params: \u0026CCITTFaxDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // CCITT fax decoding is complex - for now provide a stub\n    // Full implementation would require a dedicated CCITT decoder\n\n    let width = params.columns as usize;\n    let height = if params.rows \u003e 0 { params.rows as usize } else { 0 };\n\n    // For Group 4 (k \u003e 0), we need to implement the 2D coding scheme\n    // For Group 3 1D (k = 0), we need to implement the 1D coding scheme\n    // For Group 3 2D (k \u003c 0), we need to implement mixed 1D/2D\n\n    // Basic implementation using run-length decoding pattern\n    let bytes_per_row = (width + 7) / 8;\n    let estimated_rows = if height \u003e 0 { height } else { data.len() * 8 / width.max(1) };\n\n    let mut result = Vec::with_capacity(bytes_per_row * estimated_rows);\n\n    // Simplified: treat as raw bitmap if no compression recognized\n    // This is a fallback - real implementation needs full CCITT codec\n    if data.len() == bytes_per_row * estimated_rows {\n        result.extend_from_slice(data);\n    } else {\n        // Attempt basic decompression\n        result = decode_ccitt_g4(data, width, height, params)?;\n    }\n\n    // Apply black_is_1 transformation if needed\n    if !params.black_is_1 {\n        for byte in \u0026mut result {\n            *byte = !*byte;\n        }\n    }\n\n    Ok(result)\n}\n\n/// Basic CCITT Group 4 decoder\nfn decode_ccitt_g4(data: \u0026[u8], width: usize, height: usize, _params: \u0026CCITTFaxDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // Group 4 uses 2D coding exclusively\n    // This is a simplified implementation\n\n    let bytes_per_row = (width + 7) / 8;\n    let total_rows = if height \u003e 0 { height } else { 1000 }; // Max rows as fallback\n\n    let mut result = Vec::with_capacity(bytes_per_row * total_rows);\n    let mut reference_line = vec![0u8; bytes_per_row];\n    let mut current_line = vec![0u8; bytes_per_row];\n\n    let mut bit_reader = BitReader::new(data);\n    let mut row_count = 0;\n\n    while row_count \u003c total_rows {\n        // Try to decode a row\n        match decode_g4_row(\u0026mut bit_reader, \u0026reference_line, \u0026mut current_line, width) {\n            Ok(()) =\u003e {\n                result.extend_from_slice(\u0026current_line);\n                std::mem::swap(\u0026mut reference_line, \u0026mut current_line);\n                current_line.fill(0);\n                row_count += 1;\n            }\n            Err(_) =\u003e break, // End of data or error\n        }\n    }\n\n    Ok(result)\n}\n\n/// Bit reader for CCITT decoding\nstruct BitReader\u003c'a\u003e {\n    data: \u0026'a [u8],\n    byte_pos: usize,\n    bit_pos: u8,\n}\n\nimpl\u003c'a\u003e BitReader\u003c'a\u003e {\n    fn new(data: \u0026'a [u8]) -\u003e Self {\n        Self {\n            data,\n            byte_pos: 0,\n            bit_pos: 0,\n        }\n    }\n\n    fn read_bit(\u0026mut self) -\u003e Option\u003cbool\u003e {\n        if self.byte_pos \u003e= self.data.len() {\n            return None;\n        }\n\n        let bit = (self.data[self.byte_pos] \u003e\u003e (7 - self.bit_pos)) \u0026 1;\n        self.bit_pos += 1;\n        if self.bit_pos \u003e= 8 {\n            self.bit_pos = 0;\n            self.byte_pos += 1;\n        }\n\n        Some(bit != 0)\n    }\n\n    fn read_bits(\u0026mut self, count: usize) -\u003e Option\u003cu32\u003e {\n        let mut value = 0u32;\n        for _ in 0..count {\n            value = (value \u003c\u003c 1) | (self.read_bit()? as u32);\n        }\n        Some(value)\n    }\n}\n\n/// Decode a single Group 4 row\nfn decode_g4_row(\n    _reader: \u0026mut BitReader,\n    _reference: \u0026[u8],\n    current: \u0026mut [u8],\n    _width: usize,\n) -\u003e Result\u003c()\u003e {\n    // Simplified: fill with white\n    // Full implementation needs CCITT code tables\n    current.fill(0);\n    Ok(())\n}\n\n// ============================================================================\n// DCTDecode (JPEG)\n// ============================================================================\n\n/// Decode JPEG compressed data\npub fn decode_dct(data: \u0026[u8], _params: Option\u003c\u0026DCTDecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use image::io::Reader as ImageReader;\n    use std::io::Cursor;\n\n    let reader = ImageReader::with_format(\n        Cursor::new(data),\n        image::ImageFormat::Jpeg,\n    );\n\n    let img = reader.decode()\n        .map_err(|e| Error::Generic(format!(\"DCTDecode failed: {}\", e)))?;\n\n    Ok(img.into_bytes())\n}\n\n/// Encode data with JPEG compression\npub fn encode_dct(data: \u0026[u8], width: u32, height: u32, quality: u8) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use image::{ImageBuffer, Rgb};\n    use std::io::Cursor;\n\n    // Assume RGB data\n    let img: ImageBuffer\u003cRgb\u003cu8\u003e, _\u003e = ImageBuffer::from_raw(width, height, data.to_vec())\n        .ok_or_else(|| Error::Generic(\"Invalid image dimensions\".into()))?;\n\n    let mut output = Cursor::new(Vec::new());\n    img.write_to(\u0026mut output, image::ImageFormat::Jpeg)\n        .map_err(|e| Error::Generic(format!(\"DCTEncode failed: {}\", e)))?;\n\n    let _ = quality; // TODO: Use quality parameter\n\n    Ok(output.into_inner())\n}\n\n// ============================================================================\n// JPXDecode (JPEG 2000)\n// ============================================================================\n\n/// Decode JPEG 2000 compressed data\n#[cfg(feature = \"jpeg2000\")]\npub fn decode_jpx(data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    use jpeg2k::Image;\n\n    let image = Image::from_bytes(data)\n        .map_err(|e| Error::Generic(format!(\"JPXDecode failed: {:?}\", e)))?;\n\n    // Get the decoded image data\n    // The jpeg2k crate provides access to image data through its API\n    let mut result = Vec::new();\n\n    // Get dimensions\n    let width = image.width() as usize;\n    let height = image.height() as usize;\n    let num_components = image.components().len();\n\n    // Reserve space for the output\n    result.reserve(width * height * num_components);\n\n    // Extract data component by component\n    // JPEG2000 stores components separately, we need to interleave them\n    for y in 0..height {\n        for x in 0..width {\n            for comp in image.components() {\n                let comp_width = comp.width() as usize;\n                let idx = y * comp_width + x;\n                if let Some(\u0026val) = comp.data().get(idx) {\n                    // jpeg2k returns i32 values, convert to u8\n                    result.push(val.clamp(0, 255) as u8);\n                }\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n#[cfg(not(feature = \"jpeg2000\"))]\npub fn decode_jpx(_data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    Err(Error::Generic(\"JPEG 2000 support not enabled. Enable 'jpeg2000' feature.\".into()))\n}\n\n// ============================================================================\n// JBIG2Decode\n// ============================================================================\n\n/// Decode JBIG2 compressed data\npub fn decode_jbig2(data: \u0026[u8], _params: Option\u003c\u0026JBIG2DecodeParams\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // JBIG2 is a complex format for bi-level (black \u0026 white) images\n    // Full implementation would require a dedicated JBIG2 decoder\n    // For now, return the data as-is or error\n\n    #[cfg(feature = \"jbig2\")]\n    {\n        // Would use jbig2dec or similar library\n        Err(Error::Generic(\"JBIG2 decoder not yet implemented\".into()))\n    }\n\n    #[cfg(not(feature = \"jbig2\"))]\n    {\n        let _ = data;\n        Err(Error::Generic(\"JBIG2 support not enabled. Enable 'jbig2' feature.\".into()))\n    }\n}\n\n// ============================================================================\n// Predictor Functions\n// ============================================================================\n\n/// Apply PNG/TIFF predictor for decoding\nfn apply_predictor_decode(data: \u0026[u8], params: \u0026FlateDecodeParams) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let predictor = params.predictor;\n    let colors = params.colors.max(1) as usize;\n    let bits = params.bits_per_component.max(8) as usize;\n    let columns = params.columns.max(1) as usize;\n\n    // Calculate bytes per pixel and bytes per row\n    let bytes_per_pixel = (colors * bits + 7) / 8;\n    let bytes_per_row = (colors * bits * columns + 7) / 8;\n\n    match predictor {\n        1 =\u003e Ok(data.to_vec()), // No predictor\n        2 =\u003e apply_tiff_predictor_decode(data, bytes_per_row, bytes_per_pixel),\n        10..=15 =\u003e apply_png_predictor_decode(data, bytes_per_row, bytes_per_pixel),\n        _ =\u003e Err(Error::Generic(format!(\"Unsupported predictor: {}\", predictor))),\n    }\n}\n\n/// Apply TIFF predictor (horizontal differencing)\nfn apply_tiff_predictor_decode(data: \u0026[u8], bytes_per_row: usize, bytes_per_pixel: usize) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    let mut result = Vec::with_capacity(data.len());\n\n    for row in data.chunks(bytes_per_row) {\n        let mut prev = vec![0u8; bytes_per_pixel];\n\n        for pixel in row.chunks(bytes_per_pixel) {\n            for (i, \u0026byte) in pixel.iter().enumerate() {\n                let decoded = byte.wrapping_add(prev[i]);\n                result.push(decoded);\n                prev[i] = decoded;\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n/// Apply PNG predictor\nfn apply_png_predictor_decode(data: \u0026[u8], bytes_per_row: usize, bytes_per_pixel: usize) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n    // PNG predictor includes a filter type byte at the start of each row\n    let row_size = bytes_per_row + 1;\n    let mut result = Vec::with_capacity(data.len());\n    let mut prev_row = vec![0u8; bytes_per_row];\n\n    for row_data in data.chunks(row_size) {\n        if row_data.is_empty() {\n            continue;\n        }\n\n        let filter_type = row_data[0];\n        let row = \u0026row_data[1..];\n\n        if row.len() \u003c bytes_per_row {\n            // Incomplete row, pad with zeros\n            let mut padded = row.to_vec();\n            padded.resize(bytes_per_row, 0);\n            decode_png_filter(filter_type, \u0026padded, \u0026prev_row, bytes_per_pixel, \u0026mut result)?;\n        } else {\n            decode_png_filter(filter_type, \u0026row[..bytes_per_row], \u0026prev_row, bytes_per_pixel, \u0026mut result)?;\n        }\n\n        // Update previous row\n        let start = result.len().saturating_sub(bytes_per_row);\n        prev_row.copy_from_slice(\u0026result[start..]);\n    }\n\n    Ok(result)\n}\n\n/// Decode a single PNG filter row\nfn decode_png_filter(\n    filter_type: u8,\n    row: \u0026[u8],\n    prev_row: \u0026[u8],\n    bytes_per_pixel: usize,\n    output: \u0026mut Vec\u003cu8\u003e,\n) -\u003e Result\u003c()\u003e {\n    match filter_type {\n        0 =\u003e {\n            // None\n            output.extend_from_slice(row);\n        }\n        1 =\u003e {\n            // Sub\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel]\n                } else {\n                    0\n                };\n                output.push(byte.wrapping_add(left));\n            }\n        }\n        2 =\u003e {\n            // Up\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let up = prev_row.get(i).copied().unwrap_or(0);\n                output.push(byte.wrapping_add(up));\n            }\n        }\n        3 =\u003e {\n            // Average\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel] as u32\n                } else {\n                    0\n                };\n                let up = prev_row.get(i).copied().unwrap_or(0) as u32;\n                let avg = ((left + up) / 2) as u8;\n                output.push(byte.wrapping_add(avg));\n            }\n        }\n        4 =\u003e {\n            // Paeth\n            for (i, \u0026byte) in row.iter().enumerate() {\n                let left = if i \u003e= bytes_per_pixel {\n                    output[output.len() - bytes_per_pixel]\n                } else {\n                    0\n                };\n                let up = prev_row.get(i).copied().unwrap_or(0);\n                let up_left = if i \u003e= bytes_per_pixel {\n                    prev_row.get(i - bytes_per_pixel).copied().unwrap_or(0)\n                } else {\n                    0\n                };\n                let paeth = paeth_predictor(left, up, up_left);\n                output.push(byte.wrapping_add(paeth));\n            }\n        }\n        _ =\u003e {\n            return Err(Error::Generic(format!(\"Unknown PNG filter type: {}\", filter_type)));\n        }\n    }\n\n    Ok(())\n}\n\n/// Paeth predictor function\nfn paeth_predictor(a: u8, b: u8, c: u8) -\u003e u8 {\n    let a = a as i32;\n    let b = b as i32;\n    let c = c as i32;\n\n    let p = a + b - c;\n    let pa = (p - a).abs();\n    let pb = (p - b).abs();\n    let pc = (p - c).abs();\n\n    if pa \u003c= pb \u0026\u0026 pa \u003c= pc {\n        a as u8\n    } else if pb \u003c= pc {\n        b as u8\n    } else {\n        c as u8\n    }\n}\n\n// ============================================================================\n// Filter Chain\n// ============================================================================\n\n/// A chain of filters to apply\n#[derive(Debug, Clone)]\npub struct FilterChain {\n    filters: Vec\u003cFilterType\u003e,\n}\n\nimpl FilterChain {\n    pub fn new() -\u003e Self {\n        Self { filters: Vec::new() }\n    }\n\n    pub fn add(\u0026mut self, filter: FilterType) {\n        self.filters.push(filter);\n    }\n\n    /// Decode data through the filter chain (in order)\n    pub fn decode(\u0026self, mut data: Vec\u003cu8\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        for filter in \u0026self.filters {\n            data = match filter {\n                FilterType::FlateDecode =\u003e decode_flate(\u0026data, None)?,\n                FilterType::LZWDecode =\u003e decode_lzw(\u0026data, None)?,\n                FilterType::ASCII85Decode =\u003e decode_ascii85(\u0026data)?,\n                FilterType::ASCIIHexDecode =\u003e decode_ascii_hex(\u0026data)?,\n                FilterType::RunLengthDecode =\u003e decode_run_length(\u0026data)?,\n                FilterType::CCITTFaxDecode =\u003e decode_ccitt_fax(\u0026data, \u0026CCITTFaxDecodeParams::default())?,\n                FilterType::DCTDecode =\u003e decode_dct(\u0026data, None)?,\n                FilterType::JPXDecode =\u003e decode_jpx(\u0026data)?,\n                FilterType::JBIG2Decode =\u003e decode_jbig2(\u0026data, None)?,\n                FilterType::Crypt =\u003e data, // Encryption handled separately\n            };\n        }\n        Ok(data)\n    }\n\n    /// Encode data through the filter chain (in reverse order)\n    pub fn encode(\u0026self, mut data: Vec\u003cu8\u003e) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        for filter in self.filters.iter().rev() {\n            data = match filter {\n                FilterType::FlateDecode =\u003e encode_flate(\u0026data, 6)?,\n                FilterType::LZWDecode =\u003e encode_lzw(\u0026data)?,\n                FilterType::ASCII85Decode =\u003e encode_ascii85(\u0026data)?,\n                FilterType::ASCIIHexDecode =\u003e encode_ascii_hex(\u0026data)?,\n                FilterType::RunLengthDecode =\u003e encode_run_length(\u0026data)?,\n                FilterType::CCITTFaxDecode =\u003e {\n                    return Err(Error::Generic(\"CCITTFaxEncode not supported\".into()));\n                }\n                FilterType::DCTDecode =\u003e {\n                    return Err(Error::Generic(\"DCTEncode requires image dimensions\".into()));\n                }\n                FilterType::JPXDecode =\u003e {\n                    return Err(Error::Generic(\"JPXEncode not supported\".into()));\n                }\n                FilterType::JBIG2Decode =\u003e {\n                    return Err(Error::Generic(\"JBIG2Encode not supported\".into()));\n                }\n                FilterType::Crypt =\u003e data,\n            };\n        }\n        Ok(data)\n    }\n}\n\nimpl Default for FilterChain {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============================================================================\n    // FilterType Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_type_from_name() {\n        // Full names\n        assert_eq!(FilterType::from_name(\"FlateDecode\"), Some(FilterType::FlateDecode));\n        assert_eq!(FilterType::from_name(\"LZWDecode\"), Some(FilterType::LZWDecode));\n        assert_eq!(FilterType::from_name(\"ASCII85Decode\"), Some(FilterType::ASCII85Decode));\n        assert_eq!(FilterType::from_name(\"ASCIIHexDecode\"), Some(FilterType::ASCIIHexDecode));\n        assert_eq!(FilterType::from_name(\"RunLengthDecode\"), Some(FilterType::RunLengthDecode));\n        assert_eq!(FilterType::from_name(\"CCITTFaxDecode\"), Some(FilterType::CCITTFaxDecode));\n        assert_eq!(FilterType::from_name(\"DCTDecode\"), Some(FilterType::DCTDecode));\n        assert_eq!(FilterType::from_name(\"JPXDecode\"), Some(FilterType::JPXDecode));\n        assert_eq!(FilterType::from_name(\"JBIG2Decode\"), Some(FilterType::JBIG2Decode));\n        assert_eq!(FilterType::from_name(\"Crypt\"), Some(FilterType::Crypt));\n\n        // Abbreviated names\n        assert_eq!(FilterType::from_name(\"Fl\"), Some(FilterType::FlateDecode));\n        assert_eq!(FilterType::from_name(\"LZW\"), Some(FilterType::LZWDecode));\n        assert_eq!(FilterType::from_name(\"A85\"), Some(FilterType::ASCII85Decode));\n        assert_eq!(FilterType::from_name(\"AHx\"), Some(FilterType::ASCIIHexDecode));\n        assert_eq!(FilterType::from_name(\"RL\"), Some(FilterType::RunLengthDecode));\n        assert_eq!(FilterType::from_name(\"CCF\"), Some(FilterType::CCITTFaxDecode));\n        assert_eq!(FilterType::from_name(\"DCT\"), Some(FilterType::DCTDecode));\n\n        // Invalid\n        assert_eq!(FilterType::from_name(\"Invalid\"), None);\n        assert_eq!(FilterType::from_name(\"\"), None);\n    }\n\n    #[test]\n    fn test_filter_type_to_name() {\n        assert_eq!(FilterType::FlateDecode.to_name(), \"FlateDecode\");\n        assert_eq!(FilterType::LZWDecode.to_name(), \"LZWDecode\");\n        assert_eq!(FilterType::ASCII85Decode.to_name(), \"ASCII85Decode\");\n        assert_eq!(FilterType::ASCIIHexDecode.to_name(), \"ASCIIHexDecode\");\n        assert_eq!(FilterType::RunLengthDecode.to_name(), \"RunLengthDecode\");\n        assert_eq!(FilterType::CCITTFaxDecode.to_name(), \"CCITTFaxDecode\");\n        assert_eq!(FilterType::DCTDecode.to_name(), \"DCTDecode\");\n        assert_eq!(FilterType::JPXDecode.to_name(), \"JPXDecode\");\n        assert_eq!(FilterType::JBIG2Decode.to_name(), \"JBIG2Decode\");\n        assert_eq!(FilterType::Crypt.to_name(), \"Crypt\");\n    }\n\n    // ============================================================================\n    // FlateDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_roundtrip() {\n        let original = b\"Hello, World! This is a test of FlateDecode compression.\";\n        let compressed = encode_flate(original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_flate_empty() {\n        let original = b\"\";\n        let compressed = encode_flate(original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_flate_compression_levels() {\n        let data = b\"Test data for different compression levels\";\n\n        // Level 0 (no compression)\n        let comp0 = encode_flate(data, 0).unwrap();\n        let dec0 = decode_flate(\u0026comp0, None).unwrap();\n        assert_eq!(\u0026dec0, data);\n\n        // Level 1 (fast)\n        let comp1 = encode_flate(data, 1).unwrap();\n        let dec1 = decode_flate(\u0026comp1, None).unwrap();\n        assert_eq!(\u0026dec1, data);\n\n        // Level 9 (best)\n        let comp9 = encode_flate(data, 9).unwrap();\n        let dec9 = decode_flate(\u0026comp9, None).unwrap();\n        assert_eq!(\u0026dec9, data);\n    }\n\n    #[test]\n    fn test_flate_large_data() {\n        let original: Vec\u003cu8\u003e = (0..10000).map(|i| (i % 256) as u8).collect();\n        let compressed = encode_flate(\u0026original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, None).unwrap();\n        assert_eq!(decompressed, original);\n    }\n\n    // ============================================================================\n    // LZWDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_lzw_roundtrip() {\n        let original = b\"AAAAABBBBBCCCCC\";\n        let compressed = encode_lzw(original).unwrap();\n        let decompressed = decode_lzw(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    #[test]\n    fn test_lzw_longer_data() {\n        let original = b\"The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog.\";\n        let compressed = encode_lzw(original).unwrap();\n        let decompressed = decode_lzw(\u0026compressed, None).unwrap();\n        assert_eq!(\u0026decompressed, original);\n    }\n\n    // ============================================================================\n    // ASCII85Decode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ascii85_roundtrip() {\n        let original = b\"Hello, World!\";\n        let encoded = encode_ascii85(original).unwrap();\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_empty() {\n        let original = b\"\";\n        let encoded = encode_ascii85(original).unwrap();\n        assert_eq!(\u0026encoded, b\"~\u003e\");\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_zeros() {\n        // Four zeros should encode to 'z'\n        let original = b\"\\x00\\x00\\x00\\x00\";\n        let encoded = encode_ascii85(original).unwrap();\n        assert!(encoded.starts_with(b\"z\"));\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_with_whitespace() {\n        // Whitespace should be ignored during decoding\n        let encoded = b\"87cURD]j  \\n\\t  7BEbo~\u003e\";\n        let decoded = decode_ascii85(encoded).unwrap();\n        // The encoded value decodes to \"Hello worl\" (what the input encodes to)\n        assert_eq!(\u0026decoded, b\"Hello worl\");\n    }\n\n    #[test]\n    fn test_ascii85_partial_group() {\n        // Test non-multiple of 4 bytes\n        let original = b\"ABC\"; // 3 bytes\n        let encoded = encode_ascii85(original).unwrap();\n        let decoded = decode_ascii85(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii85_invalid_char() {\n        let encoded = b\"Hello{World~\u003e\";\n        let result = decode_ascii85(encoded);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_ascii85_invalid_z_position() {\n        // 'z' should only appear at the start of a group\n        let encoded = b\"abcz~\u003e\";\n        let result = decode_ascii85(encoded);\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // ASCIIHexDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ascii_hex_roundtrip() {\n        let original = b\"\\x00\\x11\\x22\\x33\\x44\\x55\";\n        let encoded = encode_ascii_hex(original).unwrap();\n        let decoded = decode_ascii_hex(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii_hex_empty() {\n        let original = b\"\";\n        let encoded = encode_ascii_hex(original).unwrap();\n        assert_eq!(\u0026encoded, b\"\u003e\");\n        let decoded = decode_ascii_hex(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_ascii_hex_lowercase() {\n        let encoded = b\"48656c6c6f\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_uppercase() {\n        let encoded = b\"48656C6C6F\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_with_whitespace() {\n        let encoded = b\"48 65 6C  \\n  6C 6F\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(\u0026decoded, b\"Hello\");\n    }\n\n    #[test]\n    fn test_ascii_hex_odd_digits() {\n        // Odd number of digits - last nibble padded with 0\n        let encoded = b\"123\u003e\";\n        let decoded = decode_ascii_hex(encoded).unwrap();\n        assert_eq!(decoded, vec![0x12, 0x30]);\n    }\n\n    #[test]\n    fn test_ascii_hex_invalid_char() {\n        let encoded = b\"48GG\u003e\";\n        let result = decode_ascii_hex(encoded);\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // RunLengthDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_run_length_roundtrip() {\n        let original = b\"AAAAAABBBCCCCCCCC\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_literal() {\n        // Data with no repeated bytes\n        let original = b\"ABCDEFGH\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_empty() {\n        let original = b\"\";\n        let encoded = encode_run_length(original).unwrap();\n        // Should just be EOD marker (128)\n        assert_eq!(encoded, vec![128]);\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_long_run() {\n        // Long run of identical bytes\n        let original = vec![0x42u8; 200];\n        let encoded = encode_run_length(\u0026original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_mixed() {\n        // Mix of runs and literals\n        let original = b\"AAABBBBCCCCCDDDDDDEEEEEEE\";\n        let encoded = encode_run_length(original).unwrap();\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_run_length_eod() {\n        // Just the EOD marker\n        let encoded = vec![128u8];\n        let decoded = decode_run_length(\u0026encoded).unwrap();\n        assert!(decoded.is_empty());\n    }\n\n    // ============================================================================\n    // DCTDecode Tests (JPEG)\n    // ============================================================================\n\n    // Note: DCT encoding requires image dimensions, so we test decoding with valid JPEG\n\n    // ============================================================================\n    // CCITTFaxDecode Tests\n    // ============================================================================\n\n    #[test]\n    fn test_ccitt_default_params() {\n        let params = CCITTFaxDecodeParams::default();\n        assert_eq!(params.k, 0);\n        assert!(!params.end_of_line);\n        assert!(!params.encoded_byte_align);\n        assert_eq!(params.columns, 1728);\n        assert_eq!(params.rows, 0);\n        assert!(params.end_of_block);\n        assert!(!params.black_is_1);\n        assert_eq!(params.damaged_rows_before_error, 0);\n    }\n\n    // ============================================================================\n    // FlateDecodeParams Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_decode_params_default() {\n        let params = FlateDecodeParams::default();\n        assert_eq!(params.predictor, 0);\n        assert_eq!(params.colors, 0);\n        assert_eq!(params.bits_per_component, 0);\n        assert_eq!(params.columns, 0);\n    }\n\n    // ============================================================================\n    // LZWDecodeParams Tests\n    // ============================================================================\n\n    #[test]\n    fn test_lzw_decode_params_default() {\n        let params = LZWDecodeParams::default();\n        assert_eq!(params.predictor, 0);\n        assert_eq!(params.colors, 0);\n        assert_eq!(params.bits_per_component, 0);\n        assert_eq!(params.columns, 0);\n        assert_eq!(params.early_change, 0);\n    }\n\n    // ============================================================================\n    // FilterChain Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_chain_single() {\n        let original = b\"Test data for single filter\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::FlateDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_multiple() {\n        let original = b\"Test data for multiple filters\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::FlateDecode);\n        chain.add(FilterType::ASCII85Decode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_all_text() {\n        let original = b\"Test data for text filter chain\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::ASCIIHexDecode);\n        chain.add(FilterType::ASCII85Decode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_empty() {\n        let original = b\"No filters applied\";\n\n        let chain = FilterChain::new();\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_default() {\n        let chain: FilterChain = Default::default();\n        let data = b\"Test\";\n        let result = chain.decode(data.to_vec()).unwrap();\n        assert_eq!(\u0026result, data);\n    }\n\n    #[test]\n    fn test_filter_chain_with_lzw() {\n        let original = b\"LZW compressed data test with repeated patterns AAAAAABBBBBB\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::LZWDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    #[test]\n    fn test_filter_chain_with_run_length() {\n        let original = b\"AAAAAABBBBBBCCCCCC run length test\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::RunLengthDecode);\n\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        let decoded = chain.decode(encoded).unwrap();\n\n        assert_eq!(\u0026decoded, original);\n    }\n\n    // ============================================================================\n    // Predictor Tests\n    // ============================================================================\n\n    #[test]\n    fn test_flate_with_predictor_none() {\n        let params = FlateDecodeParams {\n            predictor: 1,\n            colors: 3,\n            bits_per_component: 8,\n            columns: 10,\n        };\n\n        let original = vec![0u8; 30];\n        let compressed = encode_flate(\u0026original, 6).unwrap();\n        let decompressed = decode_flate(\u0026compressed, Some(\u0026params)).unwrap();\n        assert_eq!(decompressed, original);\n    }\n\n    // ============================================================================\n    // Unsupported Filter Tests\n    // ============================================================================\n\n    #[test]\n    fn test_jpx_decode_without_feature() {\n        #[cfg(not(feature = \"jpeg2000\"))]\n        {\n            let result = decode_jpx(\u0026[]);\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_jbig2_decode_without_feature() {\n        #[cfg(not(feature = \"jbig2\"))]\n        {\n            let result = decode_jbig2(\u0026[], None);\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_filter_chain_unsupported_encode() {\n        let original = b\"Test\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::CCITTFaxDecode);\n\n        let result = chain.encode(original.to_vec());\n        assert!(result.is_err());\n    }\n\n    // ============================================================================\n    // BitReader Tests\n    // ============================================================================\n\n    #[test]\n    fn test_bit_reader() {\n        let data = [0b10110100, 0b11001010];\n        let mut reader = BitReader::new(\u0026data);\n\n        // Read individual bits\n        assert_eq!(reader.read_bit(), Some(true));\n        assert_eq!(reader.read_bit(), Some(false));\n        assert_eq!(reader.read_bit(), Some(true));\n        assert_eq!(reader.read_bit(), Some(true));\n\n        // Read multiple bits at once\n        assert_eq!(reader.read_bits(4), Some(0b0100));\n        assert_eq!(reader.read_bits(8), Some(0b11001010));\n\n        // Read past end\n        assert_eq!(reader.read_bit(), None);\n    }\n\n    #[test]\n    fn test_bit_reader_empty() {\n        let data: \u0026[u8] = \u0026[];\n        let mut reader = BitReader::new(data);\n        assert_eq!(reader.read_bit(), None);\n        assert_eq!(reader.read_bits(8), None);\n    }\n\n    // ============================================================================\n    // Crypt Filter Tests\n    // ============================================================================\n\n    #[test]\n    fn test_filter_chain_crypt_passthrough() {\n        let original = b\"Encrypted data passthrough\";\n\n        let mut chain = FilterChain::new();\n        chain.add(FilterType::Crypt);\n\n        // Crypt is a passthrough in the filter chain\n        let encoded = chain.encode(original.to_vec()).unwrap();\n        assert_eq!(\u0026encoded, original);\n\n        let decoded = chain.decode(original.to_vec()).unwrap();\n        assert_eq!(\u0026decoded, original);\n    }\n}\n","traces":[{"line":39,"address":[2418272],"length":1,"stats":{"Line":1}},{"line":41,"address":[1756504],"length":1,"stats":{"Line":1}},{"line":42,"address":[2418378],"length":1,"stats":{"Line":1}},{"line":43,"address":[2418460],"length":1,"stats":{"Line":1}},{"line":44,"address":[1756750],"length":1,"stats":{"Line":1}},{"line":45,"address":[1756832],"length":1,"stats":{"Line":1}},{"line":46,"address":[2418706],"length":1,"stats":{"Line":1}},{"line":47,"address":[1756996],"length":1,"stats":{"Line":1}},{"line":48,"address":[2418924,2418870],"length":1,"stats":{"Line":2}},{"line":49,"address":[1757109,1757180],"length":1,"stats":{"Line":2}},{"line":50,"address":[1757157,1757202],"length":1,"stats":{"Line":2}},{"line":51,"address":[2418987],"length":1,"stats":{"Line":1}},{"line":56,"address":[1757232],"length":1,"stats":{"Line":1}},{"line":57,"address":[1757237],"length":1,"stats":{"Line":1}},{"line":58,"address":[2419060],"length":1,"stats":{"Line":1}},{"line":59,"address":[1757294],"length":1,"stats":{"Line":1}},{"line":60,"address":[1757320],"length":1,"stats":{"Line":1}},{"line":61,"address":[1757346],"length":1,"stats":{"Line":1}},{"line":62,"address":[1757372],"length":1,"stats":{"Line":1}},{"line":63,"address":[2419187],"length":1,"stats":{"Line":1}},{"line":64,"address":[1757418],"length":1,"stats":{"Line":1}},{"line":65,"address":[2419233],"length":1,"stats":{"Line":1}},{"line":66,"address":[1757464],"length":1,"stats":{"Line":1}},{"line":67,"address":[1757487],"length":1,"stats":{"Line":1}},{"line":122,"address":[1757520],"length":1,"stats":{"Line":1}},{"line":155,"address":[1758490,1758496,1757568],"length":1,"stats":{"Line":3}},{"line":156,"address":[1757606],"length":1,"stats":{"Line":1}},{"line":157,"address":[1757620],"length":1,"stats":{"Line":1}},{"line":158,"address":[1757876,1758475,1757765,1757680],"length":1,"stats":{"Line":5}},{"line":159,"address":[1757844],"length":1,"stats":{"Line":0}},{"line":162,"address":[1757921],"length":1,"stats":{"Line":3}},{"line":163,"address":[1758436,1757967],"length":1,"stats":{"Line":1}},{"line":164,"address":[1758313,1758441,1758084],"length":1,"stats":{"Line":0}},{"line":168,"address":[1757977],"length":1,"stats":{"Line":3}},{"line":172,"address":[2420880,2420886,2420272],"length":1,"stats":{"Line":1}},{"line":173,"address":[1758566],"length":1,"stats":{"Line":2}},{"line":174,"address":[1758571],"length":1,"stats":{"Line":1}},{"line":175,"address":[1758587,1758664],"length":1,"stats":{"Line":6}},{"line":176,"address":[1758649,1758697],"length":1,"stats":{"Line":4}},{"line":177,"address":[1758681],"length":1,"stats":{"Line":1}},{"line":180,"address":[1758608],"length":1,"stats":{"Line":1}},{"line":181,"address":[1758626],"length":1,"stats":{"Line":1}},{"line":182,"address":[1758755,1758838,1758949],"length":1,"stats":{"Line":4}},{"line":183,"address":[1758917],"length":1,"stats":{"Line":0}},{"line":185,"address":[1758999],"length":1,"stats":{"Line":1}},{"line":193,"address":[1760411,1760371,1759168],"length":1,"stats":{"Line":1}},{"line":194,"address":[1705008,1705013],"length":1,"stats":{"Line":1}},{"line":197,"address":[1759261],"length":1,"stats":{"Line":3}},{"line":198,"address":[2421009],"length":1,"stats":{"Line":1}},{"line":201,"address":[1759327,1760409,1759392,1759502],"length":1,"stats":{"Line":3}},{"line":202,"address":[1759473],"length":1,"stats":{"Line":0}},{"line":205,"address":[1759626],"length":1,"stats":{"Line":1}},{"line":206,"address":[1759673],"length":1,"stats":{"Line":1}},{"line":207,"address":[2422012,2421450],"length":1,"stats":{"Line":0}},{"line":209,"address":[1759849],"length":1,"stats":{"Line":0}},{"line":210,"address":[1759851],"length":1,"stats":{"Line":0}},{"line":211,"address":[1759854],"length":1,"stats":{"Line":0}},{"line":212,"address":[1759857],"length":1,"stats":{"Line":0}},{"line":214,"address":[1760166,1759888,1759987],"length":1,"stats":{"Line":0}},{"line":218,"address":[1759729],"length":1,"stats":{"Line":2}},{"line":222,"address":[1760432,1760617,1760611],"length":1,"stats":{"Line":1}},{"line":223,"address":[1760466],"length":1,"stats":{"Line":1}},{"line":224,"address":[1760516,1760574],"length":1,"stats":{"Line":2}},{"line":225,"address":[2116608,2116625],"length":1,"stats":{"Line":0}},{"line":233,"address":[1762646,1762640,1760640],"length":1,"stats":{"Line":2}},{"line":234,"address":[1760818,1760692],"length":1,"stats":{"Line":1}},{"line":235,"address":[1760775],"length":1,"stats":{"Line":2}},{"line":236,"address":[1760786],"length":1,"stats":{"Line":1}},{"line":238,"address":[1760885,1760797],"length":1,"stats":{"Line":3}},{"line":240,"address":[1761025,1760994],"length":1,"stats":{"Line":3}},{"line":245,"address":[1761031],"length":1,"stats":{"Line":2}},{"line":250,"address":[1761041],"length":1,"stats":{"Line":1}},{"line":251,"address":[1761714],"length":1,"stats":{"Line":1}},{"line":252,"address":[1761848,1761797],"length":1,"stats":{"Line":2}},{"line":254,"address":[1761835,1761759],"length":1,"stats":{"Line":2}},{"line":259,"address":[1761726,1761978],"length":1,"stats":{"Line":3}},{"line":260,"address":[1761984,1762043],"length":1,"stats":{"Line":2}},{"line":263,"address":[1762011,1762263,1762382],"length":1,"stats":{"Line":3}},{"line":264,"address":[1762429,1762362,1762407],"length":1,"stats":{"Line":3}},{"line":266,"address":[2424343,2424122],"length":1,"stats":{"Line":3}},{"line":267,"address":[1762450],"length":1,"stats":{"Line":1}},{"line":268,"address":[1762494],"length":1,"stats":{"Line":1}},{"line":269,"address":[1762538],"length":1,"stats":{"Line":1}},{"line":270,"address":[2424288],"length":1,"stats":{"Line":1}},{"line":271,"address":[1762613],"length":1,"stats":{"Line":1}},{"line":272,"address":[2424332],"length":1,"stats":{"Line":1}},{"line":277,"address":[1761005],"length":1,"stats":{"Line":1}},{"line":279,"address":[1761688,1761164],"length":1,"stats":{"Line":2}},{"line":280,"address":[1761642,1761693,1761254],"length":1,"stats":{"Line":2}},{"line":283,"address":[1761286],"length":1,"stats":{"Line":1}},{"line":284,"address":[1761503,1761453],"length":1,"stats":{"Line":2}},{"line":288,"address":[1761068],"length":1,"stats":{"Line":1}},{"line":292,"address":[1764504,1762672,1764510],"length":1,"stats":{"Line":1}},{"line":293,"address":[2424426,2424534],"length":1,"stats":{"Line":4}},{"line":295,"address":[1762824],"length":1,"stats":{"Line":4}},{"line":296,"address":[1764199,1762836,1762859],"length":1,"stats":{"Line":11}},{"line":297,"address":[1763118,1762915],"length":1,"stats":{"Line":6}},{"line":298,"address":[1763178],"length":1,"stats":{"Line":3}},{"line":300,"address":[1763334],"length":1,"stats":{"Line":3}},{"line":301,"address":[1764478,1763345],"length":1,"stats":{"Line":6}},{"line":302,"address":[1764483,1763613,1764372],"length":1,"stats":{"Line":6}},{"line":306,"address":[1763650],"length":1,"stats":{"Line":4}},{"line":307,"address":[1763737],"length":1,"stats":{"Line":1}},{"line":308,"address":[1763768],"length":1,"stats":{"Line":1}},{"line":312,"address":[1763674],"length":1,"stats":{"Line":1}},{"line":313,"address":[1763693],"length":1,"stats":{"Line":1}},{"line":314,"address":[1763839,1764359,1763707],"length":1,"stats":{"Line":6}},{"line":315,"address":[1764229,1763976,1764310],"length":1,"stats":{"Line":4}},{"line":316,"address":[1764336,1764303],"length":1,"stats":{"Line":3}},{"line":320,"address":[1764093,1764000],"length":1,"stats":{"Line":2}},{"line":321,"address":[1764134,1764044],"length":1,"stats":{"Line":6}},{"line":323,"address":[2425896,2425860],"length":1,"stats":{"Line":1}},{"line":327,"address":[1762869],"length":1,"stats":{"Line":1}},{"line":329,"address":[2424707],"length":1,"stats":{"Line":1}},{"line":337,"address":[1765693,1764528,1765687],"length":1,"stats":{"Line":1}},{"line":338,"address":[1764579],"length":1,"stats":{"Line":1}},{"line":339,"address":[1764613],"length":1,"stats":{"Line":1}},{"line":341,"address":[1764618,1764690],"length":1,"stats":{"Line":2}},{"line":343,"address":[1764809,1764775],"length":1,"stats":{"Line":3}},{"line":348,"address":[2426511],"length":1,"stats":{"Line":3}},{"line":353,"address":[1765519,1764822,1765003],"length":1,"stats":{"Line":6}},{"line":354,"address":[2427150,2426742,2426689],"length":1,"stats":{"Line":7}},{"line":355,"address":[1765368,1765103,1765036],"length":1,"stats":{"Line":3}},{"line":356,"address":[1765079,1765136],"length":1,"stats":{"Line":2}},{"line":359,"address":[1765431],"length":1,"stats":{"Line":4}},{"line":360,"address":[1765562],"length":1,"stats":{"Line":1}},{"line":361,"address":[1765546],"length":1,"stats":{"Line":4}},{"line":362,"address":[1765560,1765614],"length":1,"stats":{"Line":6}},{"line":363,"address":[1765649],"length":1,"stats":{"Line":1}},{"line":369,"address":[1764786,1764839],"length":1,"stats":{"Line":2}},{"line":370,"address":[1764854,1764949],"length":1,"stats":{"Line":2}},{"line":373,"address":[1764861],"length":1,"stats":{"Line":1}},{"line":377,"address":[1766563,1765712,1766569],"length":1,"stats":{"Line":1}},{"line":378,"address":[1765758,1765867],"length":1,"stats":{"Line":1}},{"line":380,"address":[1765931,1765846],"length":1,"stats":{"Line":2}},{"line":381,"address":[1766030,1766167],"length":1,"stats":{"Line":2}},{"line":382,"address":[1766185],"length":1,"stats":{"Line":1}},{"line":384,"address":[1766199],"length":1,"stats":{"Line":1}},{"line":385,"address":[1766377],"length":1,"stats":{"Line":1}},{"line":388,"address":[1766035],"length":1,"stats":{"Line":1}},{"line":390,"address":[1766073],"length":1,"stats":{"Line":1}},{"line":398,"address":[1768036,1768042,1766592],"length":1,"stats":{"Line":1}},{"line":399,"address":[1766647],"length":1,"stats":{"Line":1}},{"line":400,"address":[2428357],"length":1,"stats":{"Line":2}},{"line":402,"address":[1766681],"length":1,"stats":{"Line":2}},{"line":403,"address":[2428581,2428499],"length":1,"stats":{"Line":2}},{"line":404,"address":[1766958,1766976,1766848],"length":1,"stats":{"Line":5}},{"line":406,"address":[1766966],"length":1,"stats":{"Line":3}},{"line":409,"address":[1766998,1767890],"length":1,"stats":{"Line":4}},{"line":411,"address":[1767576,1767604,1767058],"length":1,"stats":{"Line":2}},{"line":412,"address":[1767638,1767584],"length":1,"stats":{"Line":4}},{"line":413,"address":[1767704,1767924],"length":1,"stats":{"Line":0}},{"line":415,"address":[1767671,1767771],"length":1,"stats":{"Line":4}},{"line":416,"address":[1767861,1767895],"length":1,"stats":{"Line":2}},{"line":419,"address":[1767024,1767097,1767117],"length":1,"stats":{"Line":3}},{"line":420,"address":[1767105],"length":1,"stats":{"Line":1}},{"line":421,"address":[1767445,1767166],"length":1,"stats":{"Line":0}},{"line":423,"address":[1767220,1767146,1767271],"length":1,"stats":{"Line":3}},{"line":424,"address":[1767329,1767234,1767297],"length":1,"stats":{"Line":3}},{"line":425,"address":[1767360,1767305],"length":1,"stats":{"Line":3}},{"line":429,"address":[2428395],"length":1,"stats":{"Line":2}},{"line":433,"address":[1769910,1769916,1768064],"length":1,"stats":{"Line":1}},{"line":434,"address":[1768119],"length":1,"stats":{"Line":1}},{"line":435,"address":[2429829],"length":1,"stats":{"Line":1}},{"line":437,"address":[2429849],"length":1,"stats":{"Line":1}},{"line":439,"address":[1768202],"length":1,"stats":{"Line":1}},{"line":440,"address":[2430127,2429922,2430162],"length":1,"stats":{"Line":2}},{"line":441,"address":[1769884,1768448,1768556,1768494],"length":1,"stats":{"Line":6}},{"line":442,"address":[1769889,1769876,1768721],"length":1,"stats":{"Line":3}},{"line":444,"address":[1768763,1768779,1768512],"length":1,"stats":{"Line":4}},{"line":446,"address":[1768771],"length":1,"stats":{"Line":2}},{"line":448,"address":[2430543,2431474],"length":1,"stats":{"Line":3}},{"line":449,"address":[1769834],"length":1,"stats":{"Line":2}},{"line":452,"address":[2430504],"length":1,"stats":{"Line":1}},{"line":453,"address":[1768816],"length":1,"stats":{"Line":2}},{"line":455,"address":[2430533,2430583],"length":1,"stats":{"Line":2}},{"line":457,"address":[2430733,2430631],"length":1,"stats":{"Line":2}},{"line":460,"address":[2431185,2430694,2431151],"length":1,"stats":{"Line":3}},{"line":461,"address":[2431159,2431211],"length":1,"stats":{"Line":4}},{"line":466,"address":[1768902,1769558,1769577],"length":1,"stats":{"Line":3}},{"line":467,"address":[2431262],"length":1,"stats":{"Line":1}},{"line":468,"address":[2431299],"length":1,"stats":{"Line":2}},{"line":469,"address":[2431392],"length":1,"stats":{"Line":2}},{"line":475,"address":[1768163],"length":1,"stats":{"Line":1}},{"line":477,"address":[2430012],"length":1,"stats":{"Line":1}},{"line":485,"address":[2431632,2432743,2432749],"length":1,"stats":{"Line":0}},{"line":489,"address":[2431688],"length":1,"stats":{"Line":0}},{"line":490,"address":[2431705],"length":1,"stats":{"Line":0}},{"line":497,"address":[2431787,2431741],"length":1,"stats":{"Line":0}},{"line":498,"address":[2431777,2431805],"length":1,"stats":{"Line":0}},{"line":500,"address":[1770298,1770229],"length":1,"stats":{"Line":0}},{"line":504,"address":[2431974,2432017],"length":1,"stats":{"Line":0}},{"line":505,"address":[2432138,2432494],"length":1,"stats":{"Line":0}},{"line":508,"address":[1770471,1770412,1770643],"length":1,"stats":{"Line":0}},{"line":512,"address":[1770771],"length":1,"stats":{"Line":0}},{"line":513,"address":[2432504,2432632,2432741],"length":1,"stats":{"Line":0}},{"line":514,"address":[2432734],"length":1,"stats":{"Line":0}},{"line":518,"address":[1770842],"length":1,"stats":{"Line":0}},{"line":522,"address":[2433864,2432768,2433815],"length":1,"stats":{"Line":0}},{"line":526,"address":[1771240,1771177],"length":1,"stats":{"Line":0}},{"line":527,"address":[1771232,1771253],"length":1,"stats":{"Line":0}},{"line":529,"address":[2432965,2433053],"length":1,"stats":{"Line":0}},{"line":530,"address":[1771345],"length":1,"stats":{"Line":0}},{"line":531,"address":[1771432],"length":1,"stats":{"Line":0}},{"line":533,"address":[2433205],"length":1,"stats":{"Line":0}},{"line":534,"address":[1771573],"length":1,"stats":{"Line":0}},{"line":536,"address":[1771585],"length":1,"stats":{"Line":0}},{"line":538,"address":[2433384],"length":1,"stats":{"Line":0}},{"line":540,"address":[2433641,2433562],"length":1,"stats":{"Line":0}},{"line":541,"address":[2433683],"length":1,"stats":{"Line":0}},{"line":542,"address":[2433690],"length":1,"stats":{"Line":0}},{"line":543,"address":[2433795,2433742],"length":1,"stats":{"Line":0}},{"line":549,"address":[1771611],"length":1,"stats":{"Line":0}},{"line":560,"address":[1772240],"length":1,"stats":{"Line":1}},{"line":568,"address":[2433952],"length":1,"stats":{"Line":1}},{"line":569,"address":[1772302],"length":1,"stats":{"Line":2}},{"line":570,"address":[1772342],"length":1,"stats":{"Line":1}},{"line":573,"address":[1772362,1772486,1772317],"length":1,"stats":{"Line":2}},{"line":574,"address":[2434183,2434172,2434132],"length":1,"stats":{"Line":2}},{"line":575,"address":[2434254,2434175],"length":1,"stats":{"Line":2}},{"line":576,"address":[1772554],"length":1,"stats":{"Line":1}},{"line":577,"address":[1772558,1772592],"length":1,"stats":{"Line":1}},{"line":580,"address":[2434200],"length":1,"stats":{"Line":1}},{"line":583,"address":[2434288],"length":1,"stats":{"Line":1}},{"line":584,"address":[1772643],"length":1,"stats":{"Line":1}},{"line":585,"address":[1772823,1772651],"length":1,"stats":{"Line":2}},{"line":586,"address":[2434359,2434441],"length":1,"stats":{"Line":2}},{"line":588,"address":[2434412],"length":1,"stats":{"Line":1}},{"line":593,"address":[2434496],"length":1,"stats":{"Line":0}},{"line":601,"address":[2434564],"length":1,"stats":{"Line":0}},{"line":602,"address":[2434582],"length":1,"stats":{"Line":0}},{"line":610,"address":[1773543,1772944,1773511],"length":1,"stats":{"Line":0}},{"line":615,"address":[1772992],"length":1,"stats":{"Line":0}},{"line":616,"address":[2434667],"length":1,"stats":{"Line":0}},{"line":619,"address":[2434692,2434849,2434882],"length":1,"stats":{"Line":0}},{"line":620,"address":[1773124],"length":1,"stats":{"Line":0}},{"line":622,"address":[1773326,1773447],"length":1,"stats":{"Line":0}},{"line":626,"address":[1773552,1774448,1774442],"length":1,"stats":{"Line":0}},{"line":631,"address":[1773619,1773797],"length":1,"stats":{"Line":0}},{"line":632,"address":[1705664,1705678],"length":1,"stats":{"Line":0}},{"line":634,"address":[2435622,2435562],"length":1,"stats":{"Line":0}},{"line":635,"address":[1774204,1773996,1774085],"length":1,"stats":{"Line":0}},{"line":636,"address":[1774172],"length":1,"stats":{"Line":0}},{"line":640,"address":[2435878],"length":1,"stats":{"Line":0}},{"line":686,"address":[2436112],"length":1,"stats":{"Line":1}},{"line":687,"address":[1774487],"length":1,"stats":{"Line":1}},{"line":695,"address":[1774608],"length":1,"stats":{"Line":1}},{"line":709,"address":[1774637],"length":1,"stats":{"Line":1}},{"line":718,"address":[2436416],"length":1,"stats":{"Line":0}},{"line":719,"address":[2436472],"length":1,"stats":{"Line":0}},{"line":720,"address":[2436481],"length":1,"stats":{"Line":0}},{"line":721,"address":[2436515],"length":1,"stats":{"Line":0}},{"line":722,"address":[1774901],"length":1,"stats":{"Line":0}},{"line":725,"address":[1775043,1774943],"length":1,"stats":{"Line":0}},{"line":726,"address":[1775028,1775179,1775066],"length":1,"stats":{"Line":0}},{"line":728,"address":[1775150],"length":1,"stats":{"Line":0}},{"line":729,"address":[2436870],"length":1,"stats":{"Line":0}},{"line":730,"address":[2436959],"length":1,"stats":{"Line":0}},{"line":731,"address":[1775572,1775192],"length":1,"stats":{"Line":0}},{"line":732,"address":[1775329],"length":1,"stats":{"Line":0}},{"line":737,"address":[2437280,2438540,2438546],"length":1,"stats":{"Line":0}},{"line":738,"address":[2437375],"length":1,"stats":{"Line":0}},{"line":740,"address":[1775775,1775845],"length":1,"stats":{"Line":0}},{"line":741,"address":[2437697],"length":1,"stats":{"Line":0}},{"line":743,"address":[2437925,2437855],"length":1,"stats":{"Line":0}},{"line":744,"address":[2438167,2438535,2438114],"length":1,"stats":{"Line":0}},{"line":745,"address":[2438393],"length":1,"stats":{"Line":0}},{"line":746,"address":[2438461],"length":1,"stats":{"Line":0}},{"line":747,"address":[2438495],"length":1,"stats":{"Line":0}},{"line":752,"address":[1776097],"length":1,"stats":{"Line":0}},{"line":756,"address":[2438560,2440449,2440455],"length":1,"stats":{"Line":0}},{"line":758,"address":[2438647,2438764],"length":1,"stats":{"Line":0}},{"line":759,"address":[2438696],"length":1,"stats":{"Line":0}},{"line":760,"address":[1777104],"length":1,"stats":{"Line":0}},{"line":762,"address":[2438842,2438909],"length":1,"stats":{"Line":0}},{"line":763,"address":[1777645,1777498],"length":1,"stats":{"Line":0}},{"line":767,"address":[1777749,1777663],"length":1,"stats":{"Line":0}},{"line":768,"address":[1777797,1777702],"length":1,"stats":{"Line":0}},{"line":770,"address":[1777813],"length":1,"stats":{"Line":0}},{"line":772,"address":[1777892],"length":1,"stats":{"Line":0}},{"line":773,"address":[2439867],"length":1,"stats":{"Line":0}},{"line":774,"address":[1778319],"length":1,"stats":{"Line":0}},{"line":776,"address":[1777842,1777946,1778215],"length":1,"stats":{"Line":0}},{"line":780,"address":[1778630,1778185],"length":1,"stats":{"Line":0}},{"line":781,"address":[2440267],"length":1,"stats":{"Line":0}},{"line":784,"address":[2439152],"length":1,"stats":{"Line":0}},{"line":788,"address":[1778880],"length":1,"stats":{"Line":0}},{"line":795,"address":[2440610],"length":1,"stats":{"Line":0}},{"line":798,"address":[1779301],"length":1,"stats":{"Line":0}},{"line":802,"address":[1779768,1779329],"length":1,"stats":{"Line":0}},{"line":803,"address":[2441629,2441490,2441503],"length":1,"stats":{"Line":0}},{"line":804,"address":[2441513,2441607,2441631],"length":1,"stats":{"Line":0}},{"line":806,"address":[1779879],"length":1,"stats":{"Line":0}},{"line":808,"address":[1779933],"length":1,"stats":{"Line":0}},{"line":813,"address":[2441644,2441053],"length":1,"stats":{"Line":0}},{"line":814,"address":[2441756],"length":1,"stats":{"Line":0}},{"line":815,"address":[2441801],"length":1,"stats":{"Line":0}},{"line":820,"address":[1780226,1779545],"length":1,"stats":{"Line":0}},{"line":821,"address":[2441956,2441972,2442127],"length":1,"stats":{"Line":0}},{"line":822,"address":[1780490,1780515,1780367],"length":1,"stats":{"Line":0}},{"line":824,"address":[2441961],"length":1,"stats":{"Line":0}},{"line":826,"address":[2442029],"length":1,"stats":{"Line":0}},{"line":827,"address":[2442199,2442073,2442150],"length":1,"stats":{"Line":0}},{"line":828,"address":[1780545],"length":1,"stats":{"Line":0}},{"line":833,"address":[1779653,1780598],"length":1,"stats":{"Line":0}},{"line":834,"address":[2442327,2442358,2442517],"length":1,"stats":{"Line":0}},{"line":835,"address":[1780906,1780754,1780882],"length":1,"stats":{"Line":0}},{"line":837,"address":[1780736],"length":1,"stats":{"Line":0}},{"line":839,"address":[2442415],"length":1,"stats":{"Line":0}},{"line":840,"address":[1780862,1780927],"length":1,"stats":{"Line":0}},{"line":841,"address":[2442673,2442555],"length":1,"stats":{"Line":0}},{"line":843,"address":[2442532],"length":1,"stats":{"Line":0}},{"line":845,"address":[1780968],"length":1,"stats":{"Line":0}},{"line":846,"address":[2442618],"length":1,"stats":{"Line":0}},{"line":850,"address":[2440656],"length":1,"stats":{"Line":0}},{"line":854,"address":[1779756],"length":1,"stats":{"Line":0}},{"line":858,"address":[2442736],"length":1,"stats":{"Line":0}},{"line":859,"address":[2442758],"length":1,"stats":{"Line":0}},{"line":860,"address":[2442769],"length":1,"stats":{"Line":0}},{"line":861,"address":[1781164],"length":1,"stats":{"Line":0}},{"line":863,"address":[2442791,2442861],"length":1,"stats":{"Line":0}},{"line":864,"address":[1781262,1781232,1781298],"length":1,"stats":{"Line":0}},{"line":865,"address":[1781351,1781315,1781285],"length":1,"stats":{"Line":0}},{"line":866,"address":[1781397,1781368,1781338],"length":1,"stats":{"Line":0}},{"line":868,"address":[1781432,1781444,1781391],"length":1,"stats":{"Line":0}},{"line":869,"address":[2443056],"length":1,"stats":{"Line":0}},{"line":870,"address":[1781418,1781454],"length":1,"stats":{"Line":0}},{"line":871,"address":[1781460],"length":1,"stats":{"Line":0}},{"line":873,"address":[1781450],"length":1,"stats":{"Line":0}},{"line":888,"address":[1781488],"length":1,"stats":{"Line":3}},{"line":889,"address":[2443117],"length":1,"stats":{"Line":1}},{"line":892,"address":[2443168],"length":1,"stats":{"Line":2}},{"line":893,"address":[2443184],"length":1,"stats":{"Line":1}},{"line":897,"address":[1785010,1781600],"length":1,"stats":{"Line":1}},{"line":898,"address":[2446404,2443373,2443274],"length":1,"stats":{"Line":4}},{"line":899,"address":[1784921,1782653,1784865,1781867],"length":1,"stats":{"Line":5}},{"line":900,"address":[1782030,1782397,1782672],"length":1,"stats":{"Line":2}},{"line":901,"address":[1782709,1782068],"length":1,"stats":{"Line":2}},{"line":902,"address":[1782988,1782106],"length":1,"stats":{"Line":2}},{"line":903,"address":[2443749,2444824],"length":1,"stats":{"Line":2}},{"line":904,"address":[1782173,1783500],"length":1,"stats":{"Line":2}},{"line":905,"address":[1782205,1783766],"length":1,"stats":{"Line":0}},{"line":906,"address":[1782237,1784059],"length":1,"stats":{"Line":0}},{"line":907,"address":[1782269,1784335],"length":1,"stats":{"Line":0}},{"line":908,"address":[1784591,1782301],"length":1,"stats":{"Line":0}},{"line":909,"address":[2443941],"length":1,"stats":{"Line":1}},{"line":912,"address":[1781918],"length":1,"stats":{"Line":2}},{"line":916,"address":[1787881,1785040],"length":1,"stats":{"Line":1}},{"line":917,"address":[1785098,1785201,1787779],"length":1,"stats":{"Line":7}},{"line":918,"address":[1785406,1787736,1786185,1787792],"length":1,"stats":{"Line":5}},{"line":919,"address":[1785944,1785563,1786204],"length":1,"stats":{"Line":2}},{"line":920,"address":[1785595,1786235],"length":1,"stats":{"Line":2}},{"line":921,"address":[1786491,1785627],"length":1,"stats":{"Line":2}},{"line":922,"address":[1786747,1785659],"length":1,"stats":{"Line":2}},{"line":923,"address":[1787002,1785691],"length":1,"stats":{"Line":2}},{"line":925,"address":[2448664,2447182],"length":1,"stats":{"Line":2}},{"line":928,"address":[1787376,1785755],"length":1,"stats":{"Line":0}},{"line":931,"address":[1787496,1785796],"length":1,"stats":{"Line":0}},{"line":934,"address":[1787616,1785837],"length":1,"stats":{"Line":0}},{"line":936,"address":[1785886],"length":1,"stats":{"Line":1}},{"line":939,"address":[1785451],"length":1,"stats":{"Line":1}},{"line":944,"address":[1787904],"length":1,"stats":{"Line":1}},{"line":945,"address":[1787912],"length":1,"stats":{"Line":1}}],"covered":218,"coverable":363},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","font.rs"],"content":"//! PDF font module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","form.rs"],"content":"//! PDF form module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","image.rs"],"content":"//! PDF image module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","interpret.rs"],"content":"//! PDF interpret module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","lexer.rs"],"content":"//! PDF tokenizer\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","mod.rs"],"content":"//! PDF-specific parsing and document handling\n\npub mod object;\npub mod lexer;\npub mod parser;\npub mod xref;\npub mod document;\npub mod crypt;\npub mod page;\npub mod font;\npub mod cmap;\npub mod colorspace;\npub mod image;\npub mod annot;\npub mod form;\npub mod filter;\npub mod interpret;\npub mod write;\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","object.rs"],"content":"//! PDF object types\nuse std::collections::HashMap;\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct Name(pub String);\nimpl Name { pub fn new(s: \u0026str) -\u003e Self { Self(s.to_string()) } }\nimpl fmt::Display for Name { fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result { write!(f, \"/{}\", self.0) } }\n\n#[derive(Debug, Clone)]\npub struct PdfString(Vec\u003cu8\u003e);\nimpl PdfString {\n    pub fn new(data: Vec\u003cu8\u003e) -\u003e Self { Self(data) }\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] { \u0026self.0 }\n    pub fn as_str(\u0026self) -\u003e Option\u003c\u0026str\u003e { std::str::from_utf8(\u0026self.0).ok() }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ObjRef { pub num: i32, pub generation: i32 }\nimpl ObjRef { pub fn new(num: i32, generation: i32) -\u003e Self { Self { num, generation } } }\n\npub type Dict = HashMap\u003cName, Object\u003e;\npub type Array = Vec\u003cObject\u003e;\n\n#[derive(Debug, Clone)]\npub enum Object {\n    Null,\n    Bool(bool),\n    Int(i64),\n    Real(f64),\n    String(PdfString),\n    Name(Name),\n    Array(Array),\n    Dict(Dict),\n    Stream { dict: Dict, data: Vec\u003cu8\u003e },\n    Ref(ObjRef),\n}\n\nimpl Object {\n    pub fn is_null(\u0026self) -\u003e bool { matches!(self, Object::Null) }\n    pub fn as_bool(\u0026self) -\u003e Option\u003cbool\u003e { if let Object::Bool(b) = self { Some(*b) } else { None } }\n    pub fn as_int(\u0026self) -\u003e Option\u003ci64\u003e { if let Object::Int(i) = self { Some(*i) } else { None } }\n    pub fn as_real(\u0026self) -\u003e Option\u003cf64\u003e {\n        match self { Object::Real(r) =\u003e Some(*r), Object::Int(i) =\u003e Some(*i as f64), _ =\u003e None }\n    }\n    pub fn as_name(\u0026self) -\u003e Option\u003c\u0026Name\u003e { if let Object::Name(n) = self { Some(n) } else { None } }\n    pub fn as_string(\u0026self) -\u003e Option\u003c\u0026PdfString\u003e { if let Object::String(s) = self { Some(s) } else { None } }\n    pub fn as_array(\u0026self) -\u003e Option\u003c\u0026Array\u003e { if let Object::Array(a) = self { Some(a) } else { None } }\n    pub fn as_dict(\u0026self) -\u003e Option\u003c\u0026Dict\u003e { if let Object::Dict(d) = self { Some(d) } else { None } }\n}\n\nimpl Default for Object { fn default() -\u003e Self { Object::Null } }\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Name tests\n    #[test]\n    fn test_name_new() {\n        let name = Name::new(\"Type\");\n        assert_eq!(name.0, \"Type\");\n    }\n\n    #[test]\n    fn test_name_display() {\n        let name = Name::new(\"Page\");\n        assert_eq!(format!(\"{}\", name), \"/Page\");\n    }\n\n    #[test]\n    fn test_name_eq() {\n        let n1 = Name::new(\"Test\");\n        let n2 = Name::new(\"Test\");\n        let n3 = Name::new(\"Other\");\n        assert_eq!(n1, n2);\n        assert_ne!(n1, n3);\n    }\n\n    #[test]\n    fn test_name_hash() {\n        use std::collections::HashSet;\n        let mut set = HashSet::new();\n        set.insert(Name::new(\"A\"));\n        set.insert(Name::new(\"B\"));\n        set.insert(Name::new(\"A\")); // duplicate\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_name_clone() {\n        let n1 = Name::new(\"Clone\");\n        let n2 = n1.clone();\n        assert_eq!(n1, n2);\n    }\n\n    // PdfString tests\n    #[test]\n    fn test_pdf_string_new() {\n        let s = PdfString::new(vec![72, 101, 108, 108, 111]);\n        assert_eq!(s.as_bytes(), b\"Hello\");\n    }\n\n    #[test]\n    fn test_pdf_string_as_str() {\n        let s = PdfString::new(b\"Hello World\".to_vec());\n        assert_eq!(s.as_str(), Some(\"Hello World\"));\n    }\n\n    #[test]\n    fn test_pdf_string_as_str_invalid_utf8() {\n        let s = PdfString::new(vec![0xFF, 0xFE]);\n        assert_eq!(s.as_str(), None);\n    }\n\n    #[test]\n    fn test_pdf_string_clone() {\n        let s1 = PdfString::new(b\"Test\".to_vec());\n        let s2 = s1.clone();\n        assert_eq!(s1.as_bytes(), s2.as_bytes());\n    }\n\n    // ObjRef tests\n    #[test]\n    fn test_obj_ref_new() {\n        let r = ObjRef::new(10, 0);\n        assert_eq!(r.num, 10);\n        assert_eq!(r.generation, 0);\n    }\n\n    #[test]\n    fn test_obj_ref_eq() {\n        let r1 = ObjRef::new(5, 0);\n        let r2 = ObjRef::new(5, 0);\n        let r3 = ObjRef::new(5, 1);\n        assert_eq!(r1, r2);\n        assert_ne!(r1, r3);\n    }\n\n    #[test]\n    fn test_obj_ref_hash() {\n        use std::collections::HashSet;\n        let mut set = HashSet::new();\n        set.insert(ObjRef::new(1, 0));\n        set.insert(ObjRef::new(2, 0));\n        set.insert(ObjRef::new(1, 0)); // duplicate\n        assert_eq!(set.len(), 2);\n    }\n\n    // Object tests\n    #[test]\n    fn test_object_null() {\n        let obj = Object::Null;\n        assert!(obj.is_null());\n        assert_eq!(obj.as_bool(), None);\n        assert_eq!(obj.as_int(), None);\n    }\n\n    #[test]\n    fn test_object_bool() {\n        let obj_true = Object::Bool(true);\n        let obj_false = Object::Bool(false);\n\n        assert!(!obj_true.is_null());\n        assert_eq!(obj_true.as_bool(), Some(true));\n        assert_eq!(obj_false.as_bool(), Some(false));\n    }\n\n    #[test]\n    fn test_object_int() {\n        let obj = Object::Int(42);\n        assert_eq!(obj.as_int(), Some(42));\n        assert_eq!(obj.as_real(), Some(42.0));\n    }\n\n    #[test]\n    fn test_object_real() {\n        let obj = Object::Real(3.14);\n        assert_eq!(obj.as_real(), Some(3.14));\n        assert_eq!(obj.as_int(), None);\n    }\n\n    #[test]\n    fn test_object_string() {\n        let obj = Object::String(PdfString::new(b\"Hello\".to_vec()));\n        let s = obj.as_string().unwrap();\n        assert_eq!(s.as_bytes(), b\"Hello\");\n    }\n\n    #[test]\n    fn test_object_name() {\n        let obj = Object::Name(Name::new(\"Type\"));\n        let n = obj.as_name().unwrap();\n        assert_eq!(n.0, \"Type\");\n    }\n\n    #[test]\n    fn test_object_array() {\n        let arr = vec![Object::Int(1), Object::Int(2), Object::Int(3)];\n        let obj = Object::Array(arr);\n        let a = obj.as_array().unwrap();\n        assert_eq!(a.len(), 3);\n    }\n\n    #[test]\n    fn test_object_dict() {\n        let mut dict = HashMap::new();\n        dict.insert(Name::new(\"Type\"), Object::Name(Name::new(\"Page\")));\n        let obj = Object::Dict(dict);\n        let d = obj.as_dict().unwrap();\n        assert_eq!(d.len(), 1);\n    }\n\n    #[test]\n    fn test_object_stream() {\n        let mut dict = HashMap::new();\n        dict.insert(Name::new(\"Length\"), Object::Int(5));\n        let obj = Object::Stream { dict, data: b\"Hello\".to_vec() };\n\n        if let Object::Stream { dict, data } = obj {\n            assert_eq!(data, b\"Hello\");\n            assert!(dict.contains_key(\u0026Name::new(\"Length\")));\n        } else {\n            panic!(\"Expected Stream\");\n        }\n    }\n\n    #[test]\n    fn test_object_ref() {\n        let obj = Object::Ref(ObjRef::new(10, 0));\n        if let Object::Ref(r) = obj {\n            assert_eq!(r.num, 10);\n            assert_eq!(r.generation, 0);\n        } else {\n            panic!(\"Expected Ref\");\n        }\n    }\n\n    #[test]\n    fn test_object_default() {\n        let obj: Object = Default::default();\n        assert!(obj.is_null());\n    }\n\n    #[test]\n    fn test_object_clone() {\n        let obj = Object::Int(123);\n        let cloned = obj.clone();\n        assert_eq!(cloned.as_int(), Some(123));\n    }\n\n    #[test]\n    fn test_object_debug() {\n        let obj = Object::Int(42);\n        let debug = format!(\"{:?}\", obj);\n        assert!(debug.contains(\"Int\"));\n        assert!(debug.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_complex_nested_structure() {\n        let mut inner_dict = HashMap::new();\n        inner_dict.insert(Name::new(\"Key\"), Object::String(PdfString::new(b\"Value\".to_vec())));\n\n        let arr = vec![\n            Object::Int(1),\n            Object::Real(2.5),\n            Object::Dict(inner_dict),\n        ];\n\n        let mut outer_dict = HashMap::new();\n        outer_dict.insert(Name::new(\"Array\"), Object::Array(arr));\n\n        let obj = Object::Dict(outer_dict);\n        let d = obj.as_dict().unwrap();\n        let arr_obj = d.get(\u0026Name::new(\"Array\")).unwrap();\n        let inner_arr = arr_obj.as_array().unwrap();\n\n        assert_eq!(inner_arr.len(), 3);\n        assert_eq!(inner_arr[0].as_int(), Some(1));\n        assert_eq!(inner_arr[1].as_real(), Some(2.5));\n    }\n}\n\n","traces":[{"line":7,"address":[1615687,1615664],"length":1,"stats":{"Line":4}},{"line":8,"address":[1524648,1524624],"length":1,"stats":{"Line":2}},{"line":13,"address":[1524739,1524736],"length":1,"stats":{"Line":2}},{"line":14,"address":[1524768,1524773],"length":1,"stats":{"Line":2}},{"line":15,"address":[1524784,1524793],"length":1,"stats":{"Line":3}},{"line":20,"address":[1524848,1524860],"length":1,"stats":{"Line":3}},{"line":40,"address":[1524864,1524869],"length":1,"stats":{"Line":3}},{"line":41,"address":[1524912,1524922],"length":1,"stats":{"Line":3}},{"line":42,"address":[1525008,1525018],"length":1,"stats":{"Line":2}},{"line":43,"address":[1525120],"length":1,"stats":{"Line":1}},{"line":44,"address":[1525130],"length":1,"stats":{"Line":1}},{"line":46,"address":[1525296,1525306],"length":1,"stats":{"Line":2}},{"line":47,"address":[1525392,1525402],"length":1,"stats":{"Line":2}},{"line":48,"address":[1525498,1525488],"length":1,"stats":{"Line":2}},{"line":49,"address":[1525594,1525584],"length":1,"stats":{"Line":2}},{"line":52,"address":[1525683,1525680],"length":1,"stats":{"Line":2}}],"covered":16,"coverable":16},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","page.rs"],"content":"//! PDF page implementation\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","parser.rs"],"content":"//! PDF parser\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","write.rs"],"content":"//! PDF write module stub\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","src","pdf","xref.rs"],"content":"//! Cross-reference tables\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joseph","Lexmata","micropdf","micropdf-rs","tests","integration_tests.rs"],"content":"//! Integration tests for MicroPDF\n//!\n//! These tests verify that the library can correctly parse and handle\n//! various PDF document types and content.\n\nuse std::path::PathBuf;\n\n/// Get the path to a test fixture\nfn fixture_path(name: \u0026str) -\u003e PathBuf {\n    let mut path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n    path.push(\"tests\");\n    path.push(\"fixtures\");\n    path.push(name);\n    path\n}\n\n/// Read a fixture file as bytes\nfn read_fixture(name: \u0026str) -\u003e Vec\u003cu8\u003e {\n    std::fs::read(fixture_path(name)).expect(\u0026format!(\"Failed to read fixture: {}\", name))\n}\n\nmod pdf_header {\n    use super::*;\n\n    #[test]\n    fn test_minimal_pdf_header() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.\"));\n        assert!(data.len() \u003e 100); // Minimal PDF should be at least this size\n    }\n\n    #[test]\n    fn test_comprehensive_pdf_header() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.7\"));\n    }\n\n    #[test]\n    fn test_multipage_pdf_header() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(data.starts_with(b\"%PDF-1.4\"));\n    }\n}\n\nmod pdf_structure {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    fn count_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e usize {\n        data.windows(pattern.len()).filter(|w| *w == pattern).count()\n    }\n\n    #[test]\n    fn test_minimal_has_catalog() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Catalog\"));\n    }\n\n    #[test]\n    fn test_minimal_has_pages() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Pages\"));\n    }\n\n    #[test]\n    fn test_minimal_has_one_page() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Page \"));\n        assert!(find_pattern(\u0026data, b\"/Count 1\"));\n    }\n\n    #[test]\n    fn test_minimal_has_font() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Font\"));\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Helvetica\"));\n    }\n\n    #[test]\n    fn test_minimal_has_content_stream() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Contents\"));\n        assert!(find_pattern(\u0026data, b\"stream\"));\n        assert!(find_pattern(\u0026data, b\"endstream\"));\n    }\n\n    #[test]\n    fn test_minimal_has_xref() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"xref\"));\n        assert!(find_pattern(\u0026data, b\"trailer\"));\n        assert!(find_pattern(\u0026data, b\"startxref\"));\n        assert!(find_pattern(\u0026data, b\"%%EOF\"));\n    }\n\n    #[test]\n    fn test_multipage_has_five_pages() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Count 5\"));\n\n        // Count individual page objects (use /Page followed by space to avoid matching /Pages)\n        let page_count = count_pattern(\u0026data, b\"/Type /Page \");\n        assert_eq!(page_count, 5, \"Expected 5 page objects\");\n    }\n\n    #[test]\n    fn test_comprehensive_has_three_pages() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Count 3\"));\n    }\n}\n\nmod pdf_content_types {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_comprehensive_has_outlines() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Outlines\"));\n        assert!(find_pattern(\u0026data, b\"/Title (Chapter 1\"));\n        assert!(find_pattern(\u0026data, b\"/Title (Chapter 2\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_metadata() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Metadata\"));\n        assert!(find_pattern(\u0026data, b\"\u003cx:xmpmeta\"));\n        assert!(find_pattern(\u0026data, b\"MicroPDF Comprehensive Test Document\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_annotations() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        // Link annotation\n        assert!(find_pattern(\u0026data, b\"/Subtype /Link\"));\n        // Text annotation (sticky note)\n        assert!(find_pattern(\u0026data, b\"/Subtype /Text\"));\n        // Highlight annotation\n        assert!(find_pattern(\u0026data, b\"/Subtype /Highlight\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_form_fields() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/AcroForm\"));\n        // Text field\n        assert!(find_pattern(\u0026data, b\"/FT /Tx\"));\n        // Button (checkbox)\n        assert!(find_pattern(\u0026data, b\"/FT /Btn\"));\n        // Choice (dropdown)\n        assert!(find_pattern(\u0026data, b\"/FT /Ch\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_image() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Subtype /Image\"));\n        assert!(find_pattern(\u0026data, b\"/ColorSpace /DeviceRGB\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_multiple_fonts() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Helvetica\"));\n        assert!(find_pattern(\u0026data, b\"/BaseFont /Times-Roman\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_named_destinations() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Names\"));\n        assert!(find_pattern(\u0026data, b\"/Dests\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_graphics_state() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /ExtGState\"));\n        assert!(find_pattern(\u0026data, b\"/CA \"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_pattern() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Type /Pattern\"));\n        assert!(find_pattern(\u0026data, b\"/PatternType 1\"));\n    }\n}\n\nmod pdf_text_content {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_minimal_has_hello_world() {\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"Hello, World!\"));\n    }\n\n    #[test]\n    fn test_multipage_has_page_numbers() {\n        let data = read_fixture(\"multipage.pdf\");\n        assert!(find_pattern(\u0026data, b\"Page 1\"));\n        assert!(find_pattern(\u0026data, b\"Page 2\"));\n        assert!(find_pattern(\u0026data, b\"Page 3\"));\n        assert!(find_pattern(\u0026data, b\"Page 4\"));\n        assert!(find_pattern(\u0026data, b\"Page 5\"));\n    }\n\n    #[test]\n    fn test_comprehensive_has_feature_list() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"Multiple fonts\"));\n        assert!(find_pattern(\u0026data, b\"Images\"));\n        assert!(find_pattern(\u0026data, b\"Annotations\"));\n        assert!(find_pattern(\u0026data, b\"Bookmarks/Outlines\"));\n    }\n}\n\nmod pdf_encryption {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_encrypted_has_encrypt_dict() {\n        let data = read_fixture(\"encrypted_empty_password.pdf\");\n        assert!(find_pattern(\u0026data, b\"/Encrypt\"));\n        assert!(find_pattern(\u0026data, b\"/Filter /Standard\"));\n    }\n\n    #[test]\n    fn test_encrypted_has_id() {\n        let data = read_fixture(\"encrypted_empty_password.pdf\");\n        assert!(find_pattern(\u0026data, b\"/ID\"));\n    }\n}\n\nmod pdf_geometry {\n    use super::*;\n\n    fn find_pattern(data: \u0026[u8], pattern: \u0026[u8]) -\u003e bool {\n        data.windows(pattern.len()).any(|w| w == pattern)\n    }\n\n    #[test]\n    fn test_all_pdfs_have_mediabox() {\n        for fixture in [\"minimal.pdf\", \"multipage.pdf\", \"comprehensive_test.pdf\"] {\n            let data = read_fixture(fixture);\n            assert!(find_pattern(\u0026data, b\"/MediaBox\"), \"Missing MediaBox in {}\", fixture);\n        }\n    }\n\n    #[test]\n    fn test_comprehensive_has_cropbox() {\n        let data = read_fixture(\"comprehensive_test.pdf\");\n        assert!(find_pattern(\u0026data, b\"/CropBox\"));\n    }\n\n    #[test]\n    fn test_standard_page_size() {\n        // US Letter: 612 x 792 points\n        let data = read_fixture(\"minimal.pdf\");\n        assert!(find_pattern(\u0026data, b\"[0 0 612 792]\"));\n    }\n}\n\nmod ffi_integration {\n    use micropdf::ffi::geometry::*;\n    use micropdf::ffi::buffer::*;\n    use micropdf::ffi::context::*;\n\n    #[test]\n    fn test_ffi_context_lifecycle() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        assert_ne!(ctx, 0);\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_ffi_buffer_lifecycle() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let buf = fz_new_buffer(ctx, 1024);\n        assert_ne!(buf, 0);\n\n        fz_append_byte(ctx, buf, b'H' as i32);\n        fz_append_byte(ctx, buf, b'i' as i32);\n\n        assert_eq!(fz_buffer_len(ctx, buf), 2);\n\n        fz_drop_buffer(ctx, buf);\n        fz_drop_context(ctx);\n    }\n\n    #[test]\n    fn test_ffi_matrix_operations() {\n        // Test identity\n        let identity = fz_matrix::identity();\n        assert_eq!(identity.a, 1.0);\n        assert_eq!(identity.d, 1.0);\n\n        // Test translation\n        let translate = fz_translate(100.0, 200.0);\n        assert_eq!(translate.e, 100.0);\n        assert_eq!(translate.f, 200.0);\n\n        // Test scale\n        let scale = fz_scale(2.0, 3.0);\n        assert_eq!(scale.a, 2.0);\n        assert_eq!(scale.d, 3.0);\n\n        // Test point transformation\n        let point = fz_point { x: 10.0, y: 20.0 };\n        let transformed = fz_transform_point(point, translate);\n        assert_eq!(transformed.x, 110.0);\n        assert_eq!(transformed.y, 220.0);\n    }\n\n    #[test]\n    fn test_ffi_rect_operations() {\n        let r1 = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let r2 = fz_rect { x0: 50.0, y0: 50.0, x1: 150.0, y1: 150.0 };\n\n        // Test intersection\n        let intersection = fz_intersect_rect(r1, r2);\n        assert_eq!(intersection.x0, 50.0);\n        assert_eq!(intersection.y0, 50.0);\n        assert_eq!(intersection.x1, 100.0);\n        assert_eq!(intersection.y1, 100.0);\n\n        // Test union\n        let union = fz_union_rect(r1, r2);\n        assert_eq!(union.x0, 0.0);\n        assert_eq!(union.y0, 0.0);\n        assert_eq!(union.x1, 150.0);\n        assert_eq!(union.y1, 150.0);\n\n        // Test contains\n        assert_eq!(fz_contains_rect(r1, fz_rect { x0: 10.0, y0: 10.0, x1: 50.0, y1: 50.0 }), 1);\n        assert_eq!(fz_contains_rect(r1, r2), 0);\n    }\n\n    #[test]\n    fn test_ffi_quad_operations() {\n        let rect = fz_rect { x0: 0.0, y0: 0.0, x1: 100.0, y1: 100.0 };\n        let quad = fz_quad_from_rect(rect);\n\n        assert_eq!(quad.ul.x, 0.0);\n        assert_eq!(quad.ul.y, 0.0);\n        assert_eq!(quad.lr.x, 100.0);\n        assert_eq!(quad.lr.y, 100.0);\n\n        // Test quad back to rect\n        let back = fz_rect_from_quad(quad);\n        assert_eq!(back.x0, rect.x0);\n        assert_eq!(back.y0, rect.y0);\n        assert_eq!(back.x1, rect.x1);\n        assert_eq!(back.y1, rect.y1);\n    }\n}\n\nmod colorspace_integration {\n    use micropdf::ffi::colorspace::*;\n\n    #[test]\n    fn test_device_colorspaces() {\n        let gray = fz_device_gray(0);\n        let rgb = fz_device_rgb(0);\n        let cmyk = fz_device_cmyk(0);\n\n        assert_eq!(fz_colorspace_n(0, gray), 1);\n        assert_eq!(fz_colorspace_n(0, rgb), 3);\n        assert_eq!(fz_colorspace_n(0, cmyk), 4);\n\n        assert_eq!(fz_colorspace_is_gray(0, gray), 1);\n        assert_eq!(fz_colorspace_is_rgb(0, rgb), 1);\n        assert_eq!(fz_colorspace_is_cmyk(0, cmyk), 1);\n    }\n\n    #[test]\n    fn test_color_conversion() {\n        let gray = fz_device_gray(0);\n        let rgb = fz_device_rgb(0);\n\n        let src = [0.5f32];\n        let mut dst = [0.0f32; 3];\n\n        fz_convert_color(0, gray, src.as_ptr(), rgb, dst.as_mut_ptr(), 0);\n\n        // Gray to RGB should produce equal components\n        assert!((dst[0] - 0.5).abs() \u003c 0.01);\n        assert!((dst[1] - 0.5).abs() \u003c 0.01);\n        assert!((dst[2] - 0.5).abs() \u003c 0.01);\n    }\n}\n\nmod pixmap_integration {\n    use micropdf::ffi::pixmap::*;\n    use micropdf::ffi::colorspace::*;\n\n    #[test]\n    fn test_pixmap_creation_and_manipulation() {\n        let rgb = fz_device_rgb(0);\n        let pix = fz_new_pixmap(0, rgb, 100, 100, 0, 1);\n\n        assert_ne!(pix, 0);\n        assert_eq!(fz_pixmap_width(0, pix), 100);\n        assert_eq!(fz_pixmap_height(0, pix), 100);\n        assert_eq!(fz_pixmap_alpha(0, pix), 1);\n        assert_eq!(fz_pixmap_components(0, pix), 4); // RGB + alpha\n\n        // Test clear\n        fz_clear_pixmap_with_value(0, pix, 128);\n        assert_eq!(fz_get_pixmap_sample(0, pix, 0, 0, 0), 128);\n\n        // Test set/get\n        fz_set_pixmap_sample(0, pix, 50, 50, 0, 255);\n        assert_eq!(fz_get_pixmap_sample(0, pix, 50, 50, 0), 255);\n\n        fz_drop_pixmap(0, pix);\n    }\n\n    #[test]\n    fn test_pixmap_bbox() {\n        use micropdf::ffi::geometry::fz_irect;\n\n        let rgb = fz_device_rgb(0);\n        let bbox = fz_irect { x0: 10, y0: 20, x1: 110, y1: 120 };\n        let pix = fz_new_pixmap_with_bbox(0, rgb, bbox, 0, 0);\n\n        assert_eq!(fz_pixmap_x(0, pix), 10);\n        assert_eq!(fz_pixmap_y(0, pix), 20);\n        assert_eq!(fz_pixmap_width(0, pix), 100);\n        assert_eq!(fz_pixmap_height(0, pix), 100);\n\n        fz_drop_pixmap(0, pix);\n    }\n}\n\nmod stream_integration {\n    use micropdf::ffi::stream::*;\n    use micropdf::ffi::context::*;\n\n    #[test]\n    fn test_stream_from_memory() {\n        let ctx = fz_new_context(std::ptr::null(), std::ptr::null(), 0);\n        let data = b\"Hello, Stream!\";\n        let stm = fz_open_memory(ctx, data.as_ptr(), data.len());\n\n        assert_ne!(stm, 0);\n\n        // Read byte by byte\n        assert_eq!(fz_read_byte(ctx, stm), b'H' as i32);\n        assert_eq!(fz_read_byte(ctx, stm), b'e' as i32);\n        assert_eq!(fz_read_byte(ctx, stm), b'l' as i32);\n\n        // Check position\n        assert_eq!(fz_tell(ctx, stm), 3);\n\n        // Seek to beginning\n        fz_seek(ctx, stm, 0, 0);\n        assert_eq!(fz_tell(ctx, stm), 0);\n        assert_eq!(fz_read_byte(ctx, stm), b'H' as i32);\n\n        // Check EOF\n        fz_seek(ctx, stm, 0, 2); // SEEK_END\n        assert_eq!(fz_is_eof(ctx, stm), 1);\n\n        fz_drop_stream(ctx, stm);\n        fz_drop_context(ctx);\n    }\n}\n\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>